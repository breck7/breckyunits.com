<!--

 This page was compiled by 📜 Scroll, the public domain
 static site publishing software.
 
 http://scroll.publicdomaincompany.com/
 
 Generally you don't want to edit it by hand.

-->
<head>
 <meta charset="utf-8"></meta>
 <title>Breck Yunits' Scroll</title>
 <style>html {
  background-color: rgb(244,244,244);
  font-family: Exchange,Georgia,serif;
  color: #000;
  font-size: 10pt;
}
html,body,div,span,h1,h2,h3,h4,h5,h6,p {
  margin: 0;
  padding: 0;
  border: 0;
  vertical-align: baseline;
}
.scrollChrome {
  text-align: center;
  font-family: Retina,Arial,Helvetica,sans-serif;
  color: #333;
}
.scrollDescription {
  padding: 3px;
}
.scrollLinks {
  text-align: left;
  position: absolute;
  left: 25px;
  top: 3px;
}
.scrollLinks a {
  text-decoration: none;
  color: rgba(0,0,0,0.8);
}
.scrollLinks a:hover {
  color: rgba(0,0,0,1);
}
.scrollPageContainer {
  border-top: 1px solid rgb(204,204,204);
  border-bottom: 1px solid rgb(204,204,204);
  margin-top: 8px;
  margin-bottom: 8px;
}
.scrollTitle {
  font-family: Exchange,Georgia,serif;
  color: #000;
}
.scrollIcons {
  padding-top: 3px;
}
.scrollIcons svg {
  width: 16px;
  fill: rgb(204,204,204);
}
.scrollIcons svg:hover {
  fill: #333;
}
.scrollTopRightBar {
  text-align: right;
  position: absolute;
  right: 25px;
  top: 3px;
}
.scrollPage {
  column-count: auto;
  column-width: 35ch;
  column-gap: 20px;
  column-rule: 1px solid rgb(204,204,204);
  padding-left: 20px;
  padding-right: 20px;
}
.scrollArticleDate {
  text-align: center;
  font-style: italic;
  font-size: 80%;
  display: inline;
}
.scrollArticleSourceLink {
  text-align: center;
  font-size: 80%;
  margin: 0;
}
.scrollArticleSourceLink a {
  color: #000;
  text-decoration: none;
}
.scrollArticleCell {
  border-bottom: 1px solid rgb(204,204,204);
  width: 35ch;
  padding: 1ch;
  break-inside: avoid;
  overflow: hidden;
  text-align: justify;
  margin: auto;
}
.scrollArticleCell ul,.scrollArticleCell ol {
  padding: 1em;
  margin: 0;
}
.scrollArticleCell p {
  text-indent: 1em;
}
.scrollArticleCell p:first-of-type {
  display: inline;
}
.scrollArticleCell img {
  max-width: 35ch;
}
.scrollArticleCell .scrollArticleCode,.scrollArticleCell table {
  margin-top: 15px;
  margin-bottom: 15px;
  background-color: rgb(234,234,234);
  padding: 1em;
  overflow: auto;
  font-size: 80%;
}
.scrollArticleCell .scrollArticleCode,.scrollArticleCell table code {
  margin: 0;
  display: block;
  white-space: pre;
}
.scrollArticleCell h1 a {
  text-decoration: none;
  color: #000;
}
.scrollArticleCell h1,.scrollArticleCell h2,.scrollArticleCell h3,.scrollArticleCell h4,.scrollArticleCell h5,.scrollArticleCell h6 {
  text-align: center;
}
.scrollArticleCell h2,.scrollArticleCell h3,.scrollArticleCell h4,.scrollArticleCell h5,.scrollArticleCell h6 {
  margin: .2em;
}
</style>
</head>
<body>
 <div class="scrollTopRightBar">
  <div class="scrollChrome scrollIcons">
   <a href="mailto:breck7@gmail.com"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Gmail icon</title><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"/></svg></a>
   <a href="https://twitter.com/breckyunits"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Twitter icon</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg></a>
   <a href="https://github.com/breck7/breckyunits.com"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub icon</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a>
</div>
</div>
 <h1 class="scrollChrome scrollTitle">Breck Yunits' Scroll</h1>
 <div class="scrollChrome scrollDescription">Some writing about probability, programming, economics and life.</div>
 <div class="scrollChrome scrollLinks">
  <a href="#about">about</a>
</div>
 <div class="scrollPageContainer">
  <div class="scrollPage">
   <div class="scrollArticleCell"><h1 id="scroll-beta"><a href="#scroll-beta">Scroll Beta</a></h1>
<div class="scrollArticleDate">February 22, 2021 — </div>

<p>
 Today I'm launching the beta of something new called

 
 <a href="https://github.com/treenotation/dumbdown/blob/master/scroll/readme.md">Scroll</a>.

 
</p>

<p>
 I've been reading the newspaper everyday since I was a kid.

 
 I remember I'd have my feet on the ground, my body tilted at

 
 an angle and my body weight pressed into the pages on the

 
 counter. I remember staring intently at the pages spread out

 
 before me. World news, local news, sports, business, comics.

 
 I remember the smell of the print. The feel of the pages.

 
 The ink that would be smeared on my forearms when I

 
 finished reading and stood back up straight. Scroll has none

 
 of that. But it does at least have the same big single page layout.

 
</p>

<p>
 Scroll brings back <em>some</em> of the magic of newspapers.

 
</p>

<p>
 In addition to the layout, Scroll has two important differences

 
 from existing static publishing software.

 
</p>

<p>
 First, Scroll is built for public domain sites and <em>only</em>

 
 public domain sites. Builders of Scroll will spend 100% of the

 
 time building for the amazing creators who understand and value

 
 the public domain.

 
</p>

<p>
 Second, Scroll uses <a

 
 href="https://github.com/treenotation/dumbdown">Dumbdown</a>,

 
 a language powered by <a

 
 href="https://treenotation.org/">Tree Notation</a>. Unlike

 
 Markdown, Dumbdown is easily extensible. We can create

 
 and combine thousands of new sub languages to help people

 
 be more creative and communicate more effectively.

 
</p>


<p>
 I've had fun building Scroll so far and am excited to start

 
 working on it with others.

 
</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//scroll-beta.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="2019-tree-notation-annual-report"><a href="#2019-tree-notation-annual-report">2019 Tree Notation Annual Report</a></h1>
<div class="scrollArticleDate">December 9, 2020 — </div>

<p><em>Note: I wrote this early draft in February 2020, but COVID-19 happened and somehow 11 months went by before I found this draft again. I am publishing it now as it was then, without adding the visuals I had planned but never got to, or making any major edits. This way it will be very easy to have next year's report be the best one yet, which will also include exciting developments in things like non-linear parsing and "forests".</em></p>

<p>In 2017 I wrote a <a href="https://breckyunits.com/show-hn-programming-is-now-two-dimensional.html">post</a> about a half-baked idea I named <a href="https://treenotation.org/">Tree Notation</a>.</p>

<p>Since then, thanks to the help of a lot of people who have provided feedback, criticism and guidance, a lot of progress has been made flushing out the idea. I thought it might be helpful to provide an annual report on the status of the research until, as I stated in my earlier post, I "have data definitively showing that Tree Notation is useful, or alternatively, to explain why it is suboptimal and why we need more complex syntax."</p>

<p>My template for this (and maybe future) reports will be as follows:</p>

<p>1. <a href="#status">High level status</a></p>
<p>2. <a href="#problem">Restate the problem</a></p>
<p>3. <a href="#pros">2019 Pros</a></p>
<p>4. <a href="#cons">2019 Cons</a></p>
<p>5. <a href="#next">Next Steps</a></p>
<p>6. <a href="#predictions">Status of Predictions</a></p>
<p>7. <a href="#org">Organization Status</a></p>

<p><a name="status"></a></p>
<h3>High Level Status</h3>

<p>I've followed the "Strong Opinions, Weakly Held" philosophy with this idea. I came out with a very strong claim: there is some natural and universal syntax that we could use for all of our symbolic languages that would be very useful—it would let us remove a lot of unnecessary complexity, allow us to focus more on semantics alone, and reap a lot of benefits by exploiting isomorphisms and network effects across domains. I've then spent a lot of time trying to destroy that claim.</p>

<p>After publishing my work I was expecting one of two outcomes. Most likely was that someone far smarter than I would put the nail in Tree Notation's coffin with a compelling case for why a such a universal notation is impossible or disadvantageous. My more optimistic—but less probable—outcome was that I would accumulate enough evidence through research and building to make a convincing case that a simplest universal notation is possible and highly advantageous (and it would be cool if Tree Notation evolves into that notation, but I'd be happy for any notation that solves the problem).</p>

<p>Unfortunately neither of those has happened yet. No one has convinced me that this is a dead-end idea and I haven't seen enough evidence that is a good idea<a href="#note-research">^</a>. At times it has seemed like a killer application of the notation was just around the corner that would demonstrate the advantages of this pattern, but while the technology has improved a lot, I can't say anything has turned out to be so compelling that I am certain of the idea.</p>

<p>So the high level status remains: strong opinion, weakly held. I am sticking to my big claim and still awaiting/working on proof or refutation.</p>

<p><a name="problem"></a></p>
<h3>Restating the Problem</h3>

<h4>What is the idea?</h4>

<p>In these reports I'll try and restate the idea in a fresh way, but you can also find the idea explained in different places via <a href="https://treenotation.org/">visuals</a>, an <a href="https://faq.treenotation.org/">FAQ</a>, a <a href="https://github.com/treenotation/faq.treenotation.org/blob/master/spec.txt">spec</a>, <a href="https://jtree.treenotation.org/designer/">demos</a>, etc.</p>

<p>My hypothesis is that there exists a <strong>Simplest Universal Notation for Symbolic Abstraction (SUNSA)</strong>. I propose Tree Notation as a potential candidate for that notation. It is hard to assign probabilities to events that haven't happened before, but I would say I am between 1% and 10% confident that a SUNSA exists and that Tree Notation is somewhat close to it<a href="#note-risk">^</a>. If Tree Notation is not the SUNSA, it at least gives me an angle of attack on the general problem.</p>

<p>Let's define a notation as a set of physical rules that can be used to represent abstractions. By simplest universal notation I mean the notation that can represent any and every abstraction representable by other notations that also has the smallest set of rules.</p>

<p>You could say there exists many "UNSAs", or Universal Notations for Symbolic Abstractions. For example, thousands of domain specific languages are built on the XML and JSON notations, but my hypothesis is that there is a single SUNSA. XML is not the SUNSA, because an XML document like <code><a>b</a></code> can be equivalently represented as <code>a b</code> using a notation with a smaller set of rules.</p>

<h4>Where would a SUNSA fit?</h4>

<p>Inventions aren't always built in a linear fashion. For example, when you add <code>2+3</code> on your computer, your machine will break down that statement into a binary form and compute something like <code>0010</code> + <code>0011</code>. The higher level base 10 <a href="https://en.wikipedia.org/wiki/Hindu%E2%80%93Arabic_numeral_system">Hindu-Arabic numerals</a> are converted into the lower level base 2 <a href="https://en.wikipedia.org/wiki/Binary_number">binary numbers</a>. So, before your computer solves <code>2+3</code>, it must do the equivalent of <code>import binary</code>. But we had Hindu-Arabic numerals centuries before we had boolean numerals. Dependencies can be built out of order.</p>

<p>Similarly, I think there is another missing dependency that fits somewhere between binary the idea and <code>binary</code> the symbolic word.</p>

<p>Consider <a href="https://en.wikipedia.org/wiki/Euclid's_Elements">Euclid's Elements</a>, maybe the most famous math book of all time written around 2,500 years ago. The book begins with the title "Στοιχεῖα"<a href="#note-euclid">^</a>. Already there is a problem: where is <code>import the letter Σ</code>?. Euclid has imported undefined abstractions: letters and a word. Now, if we were to digitally encode the Elements today from scratch, we would first include the binary dependency and then a character encoding dependency like <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. We abstract first from binary to symbols. Then maybe once we have things in a text stream, we might abstract again to encode the Elements book into something like XML and markdown. I think there is a missing notation in both of these abstractions: the abstraction leap from binary to characters, and abstraction leap from characters to words and beyond.</p>

<p>I think to represent the jumps from binary to symbols to systems, there is a best natural notation. A SUNSA that fits in between languages that let's us build mountains of abstraction without introducing extra syntax.</p>

<p>To get a little more concrete, let me show a rough approximation of how using Tree Notation you could imagine a document that starts with just the concept of a bit (here denoted on line 2 as ".") and work your way up to defining digits and characters and words and entities.  </p>
<p>There is a lot of hand-waving going on here, which is why Tree Notation is still, at best, a half-baked idea.</p>

<div class="scrollArticleCode">
<code> </code>
<code> .</code>
<code> ...</code>
<code> 0</code>
<code> 1 .</code>
<code> ...</code>
<code> Σ 10100011</code>
<code> ...</code>
<code> Στοιχεῖα</code>
<code> ...</code>
<code> book</code><code>  title Elements</code>
<code> ...</code>
</div>


<h3>Why would a SUNSA be advantageous?</h3>

<p>Given that I still consider this idea half-baked at best; given that I don't have compelling evidence that this notation is worthwhile; given that no one else has built a killer app using the idea (even though I've collaborated publically and privately with many dozens of people on project ideas at this point); why does this idea still excite me so much?</p>

<p>The reason is because I think IF we had a SUNSA, there would be tremendous benefits and applications. I'll throw out three potential application domains that I personally find very interesting.</p>

<h4>Idea #1: Mapping the Frontiers of Symbolic Science</h4>

<p>A SUNSA would greatly <em>reduce the cost</em> of a common knowledge base of science. While it may be possible to do it today without a SUNSA, having one would be at least a one order of magnitude cost reduction. Additionally, if there is not a SUNSA, than it may take just as long to come to agreement on what UNSA to use for a common knowledge base of science as it would to actual build the base!</p>

<p>By encoding all of science into a universal syntax, in addition to tremendous pedagogical benefits, we could take analogies like this:</p>

<p><a href="http://matt.might.net/articles/phd-school-in-pictures/"><img src="phd.png" /></a></p>

<p>And make them actual concrete visualizations.</p>

<h4>Idea #2: Law (and Taxes)</h4>

<p>This one always gets me excited. I believe there is a deep connection between simplicity, justice, and fairness. I believe legal systems with unnecessary complexity are unfair, prima facie. While legal systems will always be human-made, rich in depth, nuanced, and evolving, we could shed the noise. I dream of a world where paychecks, receipts, and taxes are all written in the same language; where medical records can be cut and pasted; and where when I want to start a business I don't have to fill out forms in Delaware (the codesmell in that last one is so obvious!).</p>

<p>I believe a SUNSA would give us a way to measure complexity as neatly as we measure distance, and allow us to simplify laws to their signal, so that they serve all people, and we don't suffer from all that noise and inefficiency.</p>


<h4>Idea #3: Showcasing the Common Patterns in Computing From Low Level to High Level</h4>

<p>I love projects like <a href="https://godbolt.org/">https://godbolt.org/</a>, that let you jump up and down all the levels of abstraction in computing. I think there's an opportunity to do some incredible things if there is a SUNSA and the patterns in languages at different layers of computing all looked roughly the same (since they <em>are</em> roughly the same!).</p>


<h3>What would the properties of a SUNSA be?</h3>

<p>Tree Notation might not be the SUNSA, but it has a few properties that I think a SUNSA would have.</p>

<p>1. 2 or more physical dimensions: Every symbolic abstraction would have to be contained in the SUNSA, so to include an abstraction like the letter "a" would require a medium have at least more than one physical dimension.</p>

<p>2. Directional: A SUNSA would not just define how symbols are laid out, but it would also contain concepts of directionality.</p>

<p>3. Scopes: Essential for growth and collaboration.</p>

<p>4. Brevity: I think a SUNSA will have fewer components, not more. I often see new replacements for S-Expressions or JSON come out with more concepts, not less. I don't think this is the way to go—I think a SUNSA will be like a <a href="https://en.wikipedia.org/wiki/Functional_completeness">NAND gate</a> and not a suite of gates, although the latter are handy and pragmatic.</p>

<p>I also will list one thing I don't think a SUNSA will have:</p>

<p>1. A single entry point. Currently most documents and programs are parsed with a start to finish in a linear order. With Tree Notation you can parse things in any order you want—start from anywhere, move in any direction, or even start in multiple places at the same time. I think this will be a property of a SUNSA. Maybe SUNSA programs will look more like <a href="https://en.wikipedia.org/wiki/M%C3%B6bius_strip">this</a> than <a href="https://en.wikipedia.org/wiki/Source_code#/media/File:CodeCmmt002.svg">this</a>.</p>

<p>So those are a few things that I think we'll find in a SUNSA. Will we ever find a SUNSA?</p>

<h3>Why might there not be a SUNSA?</h3>

<p>I think a really good piece of evidence that we don't need a SUNSA is that we've seen <strong>STUPENDOUS SUCCESS WITH THOUSANDS OF SYNTAXES</strong>. The pace of progress in computing in the 1900's and 2000's has been tremendous, perhaps <strong>because</strong> of the Smörgåsbord of notations.</p>

<p>Who's to say that a SUNSA is needed? I guess my retort to that, is that although we do indeed have thousands of digital notations and languages, all of them, without exception, compile down to binary, so clearly having some low level universal notation has proved incredibly advantageous so far.</p>

<p><a name="pros"></a></p>
<h3>2019 Pros</h3>

<p>So that concludes my restatement of the Tree Notation idea in terms of a more generic SUNSA concept. Now let me continue on and mention briefly some developments in 2019.</p>

<p>Here I'll just write some bullet points of work done this past ~ year advancing the idea.</p>

<p>- Types and Cells</p>
<p>- Tree Notation as a Subset of Grid Notation</p>
<p>- New homepage</p>
<p>- TreeBase</p>
<p>- CopyPaster</p>
<p>- Dozens of new Tree Languages</p>
<p>- More feedback than ever. Tens of thousands of visitors. Hundreds of conversations.</p>


<p><a name="cons"></a></p>
<h3>2019 Cons</h3>

<p>Here I just list some marks against this idea.</p>

<p>- It still sucks.</p>
<p>- No killer app yet.</p>
<p>- No good General Purpose Tree Language.</p>
<p>- No good Assembly Tree Language.</p>
<p>- No good LISP Tree Language.</p>
<p>- No good LLVM IR tie in yet.</p>
<p>- One argument put to me: "there's no need for a universal syntax with deep learning—complexity IS the universal syntax."</p>
<p>- Another argument put to me: "sure it is still simple BUT there are 2 types of inventions: ones that get more complex over time and ones that no one uses"</p>

<p><a name="next"></a></p>

<h3>Next Steps</h3>

<p>Next steps is more of the same. Keep attempting to solve problems by simplifying the encoding of them to their essence (which happens to be Tree Notation, according to the theory). Build tools ot make that easier and leverage those encodings. This year LSP will likely be a focus, Grid Notation, and the PLDB.</p>

<p><a name="predictions"></a></p>

<p>Tree Notation has a secret weapon: Simplicity does not go out of style. Slippers today look just like slippers in Egypt 3,000 years ago</p>

<h3>Status of Predictions in Paper</h3>

<p>My Tree Notation <a href="https://github.com/treenotation/research/blob/master/papers/paper/treenotation.pdf">paper</a> was my first ever attempt at writing a scientific paper and my understanding was that a good theory would make some refutable predictions. Here are the predictions I made in that paper and where they stand today.</p>

<h4>Prediction 1: no structure will be found that cannot serialize to TN.</h4>

<p>While this prediction has held, a number of people have commented that it doesn't predict much, as the same could really be said about most languages. Anything you can represent in Tree Notation you can represent in many encodings like XML.</p>

<p>What I should have predicted is something along the lines of this: <em>Tree Notation is the smallest set of syntax rules that can represent all abstractions</em>. I think trying to formalize a prediction along those lines would be a worthwhile endeavor (possibly for the reason that in trying to do what I just said, I may learn that what I just said doesn't make sense).</p>

<h4>Prediction 2: TLs will be found for every popular 1DL.</h4>

<p>This one has not come true yet. While I have made many <a href="https://jtree.treenotation.org/designer/">public Tree Languages</a> myself and many more private ones, and I have prototyped many with other people, the net utility of Tree Languages is not high enough that people are rushing to design these things. Many people have kicked the tires, but things are not good enough and there is a lack of demand.</p>

<p>On the supply side, it has turned out to be a bit harder to design useful Tree Languages than I expected. Not by 100x, but maybe by as much as 10x. I learned a lot of bad design patterns not to put in Tree Languages. I learned that bad tooling will force compromises in language design. For example, before I had syntax highlighting I relied on wierd punctation like "@" vs "#" prefixes for distinguishing types. I also learned a lot of patterns that seem to be useful in Tree Languages (like word suffixes for types). I learned good tooling leads to simpler and better languges.</p>

<h4>Prediction 3: Tree Oriented Programming (TOP) will supersede Object Oriented Programming.</h4>

<p>This one has not come true yet. While there is a tremendous amount of what I would call "Tree Oriented Programming" going on, programmers are still talking about objects and message passing and are not viewing the world as trees.</p>

<h4>Prediction 4: The simplest 2D text encodings for neural networks will be TLs.</h4>

<p>This one is a fun one. Definitely has not come true yet. But I've got a new attack vector to try and potentially crack it.</p>

<h4>Status of Long Bet</h4>

<p>After someone suggested it, I made a <a href="http://longbets.org/793/">Long Bet</a> predicting the rise of Tree Notation or a SUNSA within ten years of my initial Tree Notation post. Clearly I am far off from winning this bet at this point, as there are not any candidate languages even noted in TIOBE, never mind in the Top 10. However, IF I were to win the bet, I'd expect it wouldn't be until around 2025 that we'd see any candidate languages even appear on TIOBE's radar. In other words, absense of evidence is not evidence of absense.</p>

<p>As an aside, I really like the idea of Long Bet, and I'm hoping it may prompt someone to come up with a theoretical argument against a SUNSA that buries my ideas for good. Now, it would be very easy to take the opposing side of my bet with the simple argument that the idea of 7/10 TIOBE languages dropping by 2027 won't happen because such a shift has never happened so quickly. However, I'd probably reject that kind of challenge as non-constructive, unless it was accompanied by something like a detailed data-backed case with models showing potential speed limits on the adoption of any language (which would be a constructive contribution).</p>


<p><a name="org"></a></p>

<h3>Organization Status</h3>

<p>In 2019 I explored the idea of putting together a proper research group and a more formal organization around the idea.</p>

<p>I put the breaks on that for three reasons. The first is I just don't have a particularly keen interest in building an organization. I love to be <em>part of a team</em>, but I like to be more hands on with the ideas and the work of the team rather than the meta aspect. I've gotten great help for this project at an informal level, so there's no rush to formalize it. The second reason is I don't have a great aptitude for team building, and I'm not ready yet to dedicate the time to that. I get excited by ideas and am good at quickly explore new idea spaces, but being the captain who calmly guides the ship toward a known destination just isn't me right now. The third reason is just the idea remains too risky and ill-defined. If it's a good idea, growth will happen eventually, and there's no need to force it.</p>

<p>There is a loose confederation of folks I work on this idea with, but no formal organization with an office so far.</p>

<h2>Conclusion</h2>

<p>That's it for the recap of 2019! Tune in next year for a recap of 2020.</p>

<h3>Notes</h3>

<p><a name="note-research"></a></p>
<p>^ Regardless of whether or not Tree Notation turns out to be a good idea, as one part of the effort to prove/disprove it I've built a lot of big datasets on languages and notations, which seem to be useful for other people. Credit for that is due to a number of people who advised me back in 2017 to "learn to research properly".</p>

<p><a name="note-risk"></a></p>
<p>^ Note that this means I am between 90-99% confident that Tree Notation is <em>not</em> a good idea. However, if it's a bad idea I am 40% confident the attempt to prove it a bad idea will have positive second-order effects. I am 50% confident that it will turn out I should have dropped this idea years ago, and it's a crackpot or Dunning–Kruger theory, and I'd be lying if I said I didn't recognize that as a highly probably scenario that has kept me up some nights.</p>

<p><a name="note-euclid"></a></p>
<p>^ When it was first coming together, it wasn't a "book" as we think of books today and authorship is very fuzzy, but that doesn't affect things for my purposes here.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//tree-notation-annual-report.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="medical-records-to-the-moon"><a href="#medical-records-to-the-moon">Medical Records to the Moon</a></h1>
<div class="scrollArticleDate">March 2, 2020 — </div>

<p>A sea change is coming to medical records. In this post I do some back-of-the-envelope math to explore the changes ahead, both qualitative and quantitative. I also attempt to answer the question no one is asking: <strong>in the future will someone's medical record stretch to the moon?</strong></p>

<h3>Medical Records at the Provider</h3>

<p>Medical records are generally stored with healthcare providers and currently at least <a href="https://dashboard.healthit.gov/apps/health-information-technology-data-summaries.php?state=National&cat9=all+data&cat1=ehr+adoption#summary-data">86%-96%</a> of providers use an EHR system.</p>

<p>Americans visit their healthcare providers an <a href="https://www.cdc.gov/nchs/fastats/physician-visits.htm">average of 4 times per year</a>.</p>

<p>If you were to plot the cumulative medical data storage use for the average American patient, it would look something like the abstract chart below, going up in small increments during each visit to the doctor:</p>

<p><img src="medicalRecords/providers.png" /></p>

<p>A decade ago, this chart would not only show the quantity of a patient's medical data stored at their providers, but also the quantity of <em>all</em> of the patient's medical data. Simply put: people did not generally keep their own medical records. But this has changed.</p>

<h3>Medical Records at Home</h3>

<p>Now people own wearables like FitBits and Apple Watches. People use do-it-yourself services like 23andMe and uBiome. And in the not-too-distant future, the trend of ever-miniaturizing <a href="https://nanoporetech.com/products">lab devices</a> will enable advanced protocols at home. So now we have an additional line, reflecting the quantity of the patient's medical data from their own devices and services:</p>

<p><img src="medicalRecords/devices.png" /></p>

<p>When you put the two together you can see the issue:</p>

<p><img src="medicalRecords/both.png" /></p>

<p><strong>Patients will log <em>far</em> more medical data on their own than they do at their providers'.</strong></p>

<h3>Implication #1: Change in Ownership</h3>

<p>It seems highly likely then that the possession of medical records will flip from providers to patients. I now have 120 million heart rate readings from my own devices, while I might have a few dozen from my providers. The gravity of the former will be harder and harder to overcome.</p>

<p>Patients won't <em>literally</em> be in possession of their records. While some nerdy patients—the kind of people who host their own email servers—might host their own open records, most will probably use a service provider. Prior attempts at creating <a href="https://en.wikipedia.org/wiki/Personal_health_record">personal health record systems</a>, including some from the <a href="https://en.wikipedia.org/wiki/Microsoft_HealthVault">biggest</a> <a href="https://en.wikipedia.org/wiki/Google_Health">companies</a> around, did not catch on. But back then we didn't have the exponential increase in personal medical data, and the data gravity that creates, that we have today.</p>

<p>I'm noticing a <a href="https://www.khealth.ai/">number</a> of <a href="https://www.humanapi.co/">startups</a> innovating along this wave (and if you know of other exciting ones, please share!). However, it seems that <a href="https://en.wikipedia.org/wiki/Health_(Apple">Apple Health</a>) and <a href="https://en.wikipedia.org/wiki/Fitbit">FitBit</a> are in strong positions to emerge as leading providers of PHR as-a-service due to data gravity.</p>

<h3>Implication #2: Change in Design</h3>

<p>Currently EHR providers like <a href="https://www.epic.com/">Epic</a> design and sell their products for providers first. If patients start making the decisions about which PHR tool to use, product designers will have to consider the patient experience first.</p>

<p>I think this extends beyond products to standards. While there are some <a href="https://www.ohdsi.org/data-standardization/the-common-data-model/">great</a> <a href="https://en.wikipedia.org/wiki/Fast_Healthcare_Interoperability_Resources">groups</a> working on open standards for medical records, none, as far as I'm aware, consider patients as a first class user of their grammars and definitions. I personally think that a standards system can be developed that is fully understandable by patients without compromising on the needs of experts.</p>

<p>One simple UX innovation in medical records that I love is <a href="https://www.va.gov/bluebutton/">BlueButton</a>. Developed by the V.A. in 2010, BlueButton allows patients to download their entire medical records as a single file. While the grammar and parse-ability of BlueButton leave much to be desired, I think the concept of "your entire medical history in a single document" is a very elegant design.</p>

<h3>Implication #3: Change in Scale</h3>

<p>As more and more different devices contribute to patients' medical documents, what will the documents look like and how big will they get? Will someone's medical records stretch to the moon?</p>

<p>I think the BlueButton concept provides a helpful mental model here: you can visualize any person's medical record as a single document. Let's call this document an <em>MRD</em> for "Medical Record Document".</p>

<p>Let's imagine a 30 year old in 2050. They'd have around 11,200 days worth of data (I included some days for in utero records). Let's say there are 4 "buckets" of medical data in their MRD:</p>

<p>1. Time series sensor data</p>
<p>2. Image and point cloud data</p>
<p>3. Data from microbio protocols like genomic and metabolomic data</p>
<p>4. Text data</p>

<p>This is my back of the envelope math of how many megabytes of data might be in each of those buckets:</p>

<p><img src="medicalRecords/categories.png" /></p>

<p>I am assuming that sensor development advances <em>a lot</em> in 40 years. I am assuming our patient of the future has:</p>

<p>1. 1,000 different passive 1-D biomedical sensors recording a reading once per second</p>
<p>2. 10 different passive photo and 3-D cameras capturing 100 frames per day each</p>
<p>3. 100 passive microbio systems generating 1GB of data per protocol (don't ask me how these will work, maybe something like <a href="https://www.youtube.com/watch?v=DJklHwoYgBQ">this</a>)</p>
<p>4. For good measure I throw in a fourth bucket of 100k characters a day of plain text data</p>

<p>By my estimate this person would log about <strong>100GB of medical data per day, or about 100 petabytes of data in 30 years</strong>. That would fit on roughly 1,000 of today's <a href="https://nimbusdata.com/products/exadrive-platform/scalable-ssds/">hard drives</a>.</p>

<p>If you printed this record in a single doc, on 8.5 x 11 sheets of paper, in a human readable form—i.e. print the text, print the time series data as line charts, print the images, and print various types of output for the various protocols—the printed version would be about <strong>138,000,000 pages</strong> which laid end-to-end would stretch <strong>24,000 miles</strong>. If you printed it double-sided and stacked it like a book it would be <strong>4.2 miles high</strong>.</p>

<p><img src="medicalRecords/moon.png" /></p>

<p><strong>So for a 120 year old in 2140, their printed MRD would not reach the moon.</strong> Though it may make it halfway there.</p>

<p>Published 03/02/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//medical-records-to-the-moon.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="musing-on-the-future-of-healthcare"><a href="#musing-on-the-future-of-healthcare">Musing on the Future of Healthcare</a></h1>
<div class="scrollArticleDate">March 1, 2020 — </div>

<p>I expect the future of healthcare will be powered by consumer devices. Devices you wear. Devices you keep in your home. In the kitchen. In the bathroom. In the medicine cabinet.</p>

<p>These devices record medical data. Lots of data. They record data from macro signals like heart rate, temperature, hydration, physical activity, oxygen levels, body temperature, brain waves, voice activity. They also record data from micro signals like antibodies, RNA expression levels, metabolomics, microbiome, etc.</p>

<p>Most of the data is collected passively and regularly. But sometimes your Health app prompts you to take out the digital otoscope or digital stethoscope to examine an unusual condition more closely.</p>

<p>This data is not stored in a network at the hospital you don't have access to. Instead you can access all of that data as easily as you can access your email. You can see that data on your wrist, on your phone, on your tablet.</p>

<p>You can understand that data too. You can click and dive into the definitions of every term. You can see what is meant by macro concepts like "VO2 max" and micro concepts like "RBC Count" or "BRC1 expression". Everything is explained precisely and thoroughly. Not only in words but in interactive visualizations that are customized to your body. The algorithms and models that turn the raw signals into higher level concepts are constantly improving.</p>

<p>When you get flu like symptoms, you don't alternate between anxiously Googling symptoms and scheduling doctor's appointments. Instead, your Health app alerts you that your signals have changed, it diagnoses your condition, shows you how your patterns compare to tens of thousands of people who have experienced similar changes, and makes recommendations about what to do next. You can even see forecasts of how your condition will change in the days ahead, and you can simulate how different treatment strategies might affect those outcomes.</p>

<p>You can not only reduce illness, but you can improve well-being too. You can see how your physical habits, social habits, eating habits, sleeping habits, correlate with hundreds of health and other signals.</p>

<p>The best part of all of this? Healthcare powered by consumer devices seems like it will be a lot cheaper.</p>

<p>Published 03/02/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//musing-on-the-future-of-healthcare.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="how-old-are-these-keys"><a href="#how-old-are-these-keys">How Old Are These Keys?</a></h1>
<div class="scrollArticleDate">February 25, 2020 — </div>

<p><img src="keyboard/screenshot.png"></p>

<p>One of the questions I often come back to is this: how much of our collective wealth is inherited by our generations versus created by our generations?</p>

<p>I realized that the keys on the keyboard in front of me might make a good dataset to attack that problem. So I built a small little <a href="/keyboard/">experiment to explore the history of the keys on my keyboard</a>.</p>

<h3>The Five Waves of Symbols</h3>

<p>Painting with broad strokes, there were approximately five big waves of inventions that have left their mark on the keyboard. The first wave was the invention of the phonetic alphabet letters. The second wave was the Hindu-Arabic Numerals. The third wave was the mathematical punctuation of the Enlightenment period. The fourth wave was the invention of the typewriter. And the fifth and most recent wave was the invention of the personal computer.</p>

<p>I haven't made any traditional charts yet with this dataset, but you can roughly make out these waves in the interactive visualization by moving the slider around.</p>

<h3>Concentric Circles</h3>

<p>An interesting pattern that I never saw before is how the five waves above are roughly arranged in circles. The oldest symbols (letters) are close to the center, followed by the Hindu-Arabic Numbers, surrounded by the punctuation of the Englightenment, surrounded by the keys of the keyboard, surrounded by the recent additions in the P.C. era. Again, painting with broad strokes, but I found that to be an interesting pattern.</p>

<h3>Standing on the Shoulders of Giants</h3>

<p>All of these waves happened invented before my generation. Almost all of them before any generation alive today. The keyboard dataset provides strong evidence that most of our collective wealth is inherited.</p>

<h3>Build Notes</h3>

<p>I got this idea last week and couldn't get it out of my head. Yesterday I took a quick crack at it. I didn't have much time to spare, just enough to explore the big ideas. I started by typing all the characters on my keyboard into a Tree Notation document. Then I dug up some years for a handful of the symbols. Then I found the great Apple CSS keyboard. I stitched together the two and it seemed to be at least mildly interesting so I opted to continue. I then flushed out most of the dataset. Finally I played around with a number of visualization effects. At first I thought heatmaps would work well, and tried a few variations on that, but wasn't happy with anything. I posted my work-in-progress to a few friends last night and called it a day. Today I switched to the "disappearing keys" visualization. That definitely felt like a better approach than the heatmap. I made the thing as fun as I could given time constraints and then shipped.</p>

<p>Published 2/25/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//how-old-are-these-keys.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="integrity-and-perseverance-in-business-ensure-success-1853"><a href="#integrity-and-perseverance-in-business-ensure-success-1853">"Integrity and Perseverance in Business ensure success" (1853)</a></h1>
<div class="scrollArticleDate">February 9, 2020 — </div>

<p><a href="integrity.png"><img src="integrity.png"/></a></p>

<p><em>Richard Brhel of <a href="http://placepeep.com/">placepeep</a> shared a great quote the other day on <a href="https://www.startupschool.org/">Startup School</a>. He saw the quote on a poster years ago when he was helping a digitization effort in Ohio. I had never seen this exact quote before so wanted to transcribe it for the web.</em></p>

<p>In 1851 an instructor named Ezekiel G. Folsom incorporated a college in Ohio called <a href="https://case.edu/ech/articles/f/folsoms-mercantile-college">Folsom's Mercantile College</a>. Folsom's taught bookkeeping, banking, and "Railroading", amongst other things.</p>

<p>The image above is a screenshot of an <a href="https://ohiomemory.org/digital/collection/p267401coll36/id/7636/rec/1">1850's poster promoting the college</a>. The poster includes a motto (which I boxed in green) that I think is great guidance:  <b>"Integrity and Perseverance in Business ensure success"</b>.</p>

<p>Guess who went to Folsom's and presumably saw this poster and was influenced by this motto? <a href="https://en.wikipedia.org/wiki/John_D._Rockefeller">John D. Rockefeller</a>.</p>


<p>Published 2/09/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//integrity-and-perseverance-in-business-ensure-success.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="building-a-treebase-with-6.5-million-files"><a href="#building-a-treebase-with-6.5-million-files">Building a TreeBase with 6.5 million files</a></h1>
<div class="scrollArticleDate">January 29, 2020 — </div>

<p>In this long post I'm going to do a stupid thing and see what happens. Specifically I'm going to create 6.5 million files in a single folder and try to use Git and Sublime and other tools with that folder. All to explore this new thing I'm working on.</p>

<p><a href="https://treebase.treenotation.org/">TreeBase</a> is a new system I am working on for long-term, strongly-typed collaborative knowledge bases. The design of TreeBase is dumb. It's just a folder with a bunch of files encoded with <a href="https://treenotation.org/">Tree Notation</a>. A row in a normal SQL table in TreeBase is roughly equivalent to a file. The filenames serve as IDs. Instead of each using an optimized binary storage format it just uses plain text like UTF-8. Field names are stored alongside the values in every file. Instead of starting with a schema you can just start adding files and evolve your schema and types as you go.</p>

<p>For example, in this tiny demo <a href="https://github.com/treenotation/jtree/blob/master/treeBase/planets">TreeBase of the planets</a> the file <code>mars.planet</code> looks like this:</p>

<div class="scrollArticleCode">
<code> diameter 6794</code>
<code> surfaceGravity 4</code>
<code> yearsToOrbitSun 1.881</code>
<code> moons 2</code>
</div>

<p>TreeBase is composed of 3 key ingredients.</p>

<p><strong>Ingredient 1: A folder</strong> All that TreeBase requires is a file system (although in theory you could build an analog TreeBase on paper). This means that you can use any tools on your system for editing files for editing your database.</p>

<p><strong>Ingredient 2: Git</strong> Instead of having code to implement any sort of versioning or metadata tracking, you just use Git. Edit your files and use Git for history, branching, collaboration, etc. Because Tree Notation is a line and word based syntax it meshes really well with Git workflows.</p>

<p><strong>Ingredient 3: Tree Notation</strong> The Third Ingredient for making a TreeBase is Tree Notation. Both schemas and data use <a href="https://treenotation.org/">Tree Notation</a>. This is a new very simple syntax for encoding strongly typed data. It's simple, extensible, and plays well with Git.</p>

<h3>TreeBase Compared to Other Database Systems</h3>

<p>Probably hundreds of billions of dollars has gone into designing robust database systems like <a href="https://www.microsoft.com/en-us/sql-server/default.aspx">SQL Server</a>, <a href="https://en.wikipedia.org/wiki/Oracle_Database">Oracle</a>, <a href="https://www.postgresql.org/">PostgreSQL</a>, <a href="https://www.mysql.com/">MySQL</a>, <a href="https://www.mongodb.com/">MongoDB</a>, <a href="https://www.sqlite.org/index.html">SQLite</a>, and so forth. These things run the world. They are incredibly robust and battle-hardened. Everything that can happen is thought of and planned for, and everything that can go wrong has gone wrong (and learned from). These databases can handle trillions of rows, can conduct complex real-time transactions, and survive disasters of all sort. They use sophisticated binary formats and are tuned for specific file systems. Thousands of people have gotten their PhD's working on database technology.</p>

<p>TreeBase doesn't have any of that. TreeBase is stupid. It's just a bunch of files in a folder.</p>

<p>You might be asking yourself "Why use TreeBase at all when great databases exist?". To further put the stupidity of the current TreeBase design into perspective, the <a href="https://devblogs.microsoft.com/bharry/the-largest-git-repo-on-the-planet/">Largest Git Repo on the Planet is Windows</a> which has 3.5 million files. I'm going to try and create a repo with 6.5 million files on my laptop.</p>

<p>Even if you think TreeBase is silly aren't you curious what happens when I try to put 6.5 million files into one folder? I kind of am. If you want an explanation of <em>why</em> TreeBase, I'll get to that near the end of this post.</p>

<p>But first...</p>

<h3>Let's Break TreeBase</h3>

<p>Here again is <a href="https://github.com/treenotation/jtree/tree/master/treeBase/planets">a demo TreeBase</a> with only 8 files.</p>

<p>The biggest TreeBase I work with has on the order of 10,000 files. Some files have thousands of lines, some just a handful.</p>

<p>While TreeBase has been great at this small scale, a question I've been asked, and have wondered myself, is what happens when a TreeBase gets too big?</p>

<p>I'm about to find out, and I'll document the whole thing.</p>

<p>Every time something bad happens I'll include a 💣.</p>

<h3>Choosing a Topic</h3>

<p>TreeBase is meant for knowledge bases. So all TreeBases center around a topic.</p>

<p>To test TreeBase on a big scale I want something realistic. I wanted to choose some big structured database that thousands of people have contributed to that's been around for a while and see what it would look like as a TreeBase.</p>

<p>IMDB is just such a database and amazingly makes a lot of their data available for <a href="https://www.imdb.com/interfaces/">download</a>. So movies will be the topic and the IMDB dataset will be my test case. </p>

<h3>The Dataset</h3>

<p>First I grabbed the data. I downloaded the 7 files from IMDB to my laptop. After unzipping, they were about 7GB.</p>

<p>One file, the 500MB <code>title.basics.tsv</code>, contained basic data for all the movie and shows in the database.</p>

<p>Here's what that file looks like with <code>head -5 title.basics.tsv</code>:</p>

<div class="scrollArticleCode">
<code> tconst  titleType primaryTitle  originalTitle isAdult startYear endYear runtimeMinutes  genres</code>
<code> tt0000001 short Carmencita  Carmencita  0 1894  \N  1 Documentary,Short</code>
<code> tt0000002 short Le clown et ses chiens  Le clown et ses chiens  0 1892  \N  5 Animation,Short</code>
<code> tt0000003 short Pauvre Pierrot  Pauvre Pierrot  0 1892  \N  4 Animation,Comedy,Romance</code>
<code> tt0000004 short Un bon bock Un bon bock 0 1892  \N  \N  Animation,Short</code>
</div>

<p>This looks like a good candidate for TreeBase. With this TSV I can create a file for each movie. I don't need the other 6 files for this experiment, though if this was a real project I'd like to merge in that data as well (in that case I'd probably create a second TreeBase for the <code>names</code> in the IMDB dataset).</p>

<p>Doing a simple line count <code>wc -l title.basics.tsv</code> I learn that there are around 6.5M titles in <code>title.basics.tsv</code>. With the current implementation of TreeBase this would be 6.5M files in 1 folder. That should handily break things.</p>

<p>The TreeBase design calls for me to create 1 file for every row in that TSV file. To again stress how dumb this design is keep in mind a 500MB TSV with 6.5M rows can be parsed and analyzed with tools like R or Python in seconds. You could even load the thing near instantly into a SQLite database and utilize any SQL tool to explore the dataset. Instead I am about to spend hours, perhaps days, turning it into a TreeBase.</p>

<h3>From 1 File to 6.5 Million Files</h3>

<p>What will happen when I split 1 file into 6.5 million files? Well, it's clear I am going to waste some space.</p>

<p>A file doesn't just take up space for its contents: it also has metadata. Every file contains metadata like permissions, modification time, etc. That metadata must take up some space, right? If I were to create 6.5M new files, how much extra space would that take up?</p>

<p>My MacBook uses <a href="https://en.wikipedia.org/wiki/Apple_File_System">APFS</a>. It can hold up to 9,000,000,000,000,000,000 files. I can't easily find hard numbers on how much metadata one file takes up but can at least start with a ballpark estimate.</p>

<p>I'll start by considering the space filenames will take up.</p>

<p>In TreeBase filenames are composed of a permalink and a file extension. The file extension is to make it easier for editors to understand the schema of a file. In the planets TreeBase above, the files all had the <code>planet</code> extension and there is a <code>planet.grammar</code> file that contains information for the tools like syntax highlighters and type checkers. For my new IMDB TreeBase there will be a similar <code>title.grammar</code> file and each file will have the ".title" extension. So that is 6 bytes per file. Or merely 36MB extra for the file extensions.</p>

<p>Next, the body of each filename will be a readable ID. TreeBase has meaningful filenames to work well with Git and existing file tools. It keeps things simple. For this TreeBase, I will make the ID from the primaryTitle column in the dataset. Let's see how much space that will take.</p>

<p>I'll try <code>xsv select primaryTitle title.basics.tsv | wc</code>.</p>

<p>💣 I got this error:</p>

<div class="scrollArticleCode">
<code> CSV error: record 1102213 (line: 1102214, byte: 91470022): found record with 8 fields, but the previous record has 9 fields</code><code>  1102213 3564906 21815916</code>
</div>

<p><a href="https://github.com/BurntSushi/xsv">XSV</a> didn't like something in that file. Instead of getting bogged down, I'll just work around it.</p>

<p>I'll build a subset from the first 1M rows with <code>head -n 1000000 title.basics.tsv > 1m.title.basics.tsv</code>. Now I will compute against that subset with <code>xsv select primaryTitle 1m.title.basics.tsv | wc</code>. I get <code>19751733</code> so an average of 20 characters per title.</p>

<p>I'll combine that with the space for file extension and round that to say 30 extra bytes of file information for each of the 6.5 million titles. <strong>So about 200MB of extra data required to split this 500MB file into filenames. Even though that's a 50% increase, 200MB is dirt cheap so that doesn't seem so bad.</strong></p>

<p>You may think that I could save a roughly equivalent amount by dropping the primaryTitle field. However, even though my filenames now contain information from the title, my permalink schema will generally distort the title so I need to preserve it in each file and won't get savings there. I use a more restrictive character set in the permalink schema than the file contents just to make things like URLs easier.</p>

<p>Again you might ask why not just an integer for the permalink? You could but that's not the TreeBase way. The human readable permalinks play nice with tools like text editors, URLs, and Git. TreeBase is about leveraging software that already works well with file systems. If you use meaningless IDs for filenames you do away with one of the very useful features of the TreeBase system.</p>

<p>But I won't just waste space in metadata. I'm also going to add duplicate data to the contents of each file. That's because I won't be storing just values like <code>1999</code> but I'll also be repeating column names in each file like <code>startYear 1999</code>.</p>

<p>How much space will this take up? The titles file has 9 columns and using <code>head -n 1 1m.title.basics.tsv | wc</code> I see that adds up to 92 bytes. I'll round that up to 100, and multiple by 6.5M, and that adds up to about 65,000,000 duplicate words and 650MB. In other words the space requirements roughly doubled (of course, assuming no compression by the file system under the hood).</p>

<p>You might be wondering why not just drop the column names from each file? Again, it's just not the TreeBase way. By including the column names, each file is self-documenting. I can open up any file with a text editor and easily change it.</p>

<p><strong>So to recap: splitting this 1 TSV file into 6.5 million files is going to take up 2-3x more space due to metadata and repetition of column names.</strong></p>

<p>Because this is text data, that's actually not so bad. I don't foresee problems arising from wasted disk space.</p>

<h3>Foreseeing Speed Problems</h3>

<p>Before I get to the fun part, I'm going to stop for a second and try and predict what the problems are going to be.</p>

<p>Again, in this experiment I'm going to build and attempt to work with a TreeBase roughly 1,000 times larger than any I've worked with before. A 3 order of magnitude jump.</p>

<p>Disk space won't be a problem. But are the software tools I work with on a day-to-day basis designed to handle millions of files in a single folder? How will they hold up?</p>

<ul>
 <li><strong>Bash</strong> How will the basics like <code>ls</code> and <code>grep</code> hold up in a folder with 6.5M files?</li>
 <li><strong>Git</strong> How slow will <code>git status</code> be? What about <code>git add</code> and <code>git commit</code>?</li>
 <li><strong>Sublime Text</strong> Will I even be able to open this folder in Sublime Text? Find/replace is something I so commonly use, will that work?  How about regex find/replace?</li>
 <li><strong>Finder</strong> Will I be able to visually browse around?</li>
 <li><strong>TreeBase Scripts</strong> Will my simple TreeBase scripts be usable? Will I be able to type check a TreeBase?</li>
 <li><strong>GitHub</strong> Will GitHub be able to handle 6.5M files?</li>
</ul>

<h3>Proceeding in Stages</h3>

<p>Since I am going to make a 3 order of magnitude jump, I figured it would be best to make those jumps one at a time.</p>

<p>Actually, to be smart, I will create 5 TreeBases and make 4 jumps. I'll make 1 small TreeBase for sanity checks and then four where I increase by 10x 3 times and see how things hold up.</p>

<p>First, I'll create 5 folders: <code>mkdir 60; mkdir 6k; mkdir 60k; mkdir 600k; mkdir 6m</code></p>

<p>Now I'll create 4 smaller subsets for the smaller bases. For the final 6.5M base I'll just use the original file.</p>

<div class="scrollArticleCode">
<code> head -n 60 title.basics.tsv > 60/titles.tsv</code>
<code> head -n 6000 title.basics.tsv > 6k/titles.tsv</code>
<code> head -n 60000 title.basics.tsv > 60k/titles.tsv</code>
<code> head -n 600000 title.basics.tsv > 600k/titles.tsv</code>
</div>

<p>Now I'll write a script to turn those TSV rows into TreeBase files.</p>

<div class="scrollArticleCode">
<code> #! /usr/local/bin/node --use_strict</code>
<code> const { jtree } = require("jtree")</code>
<code> const { Disk } = require("jtree/products/Disk.node.js")</code>
<code> const folder = "600k"</code>
<code> const path = <code>${__dirname}/../imdb/${folder}.titles.tsv</code></code>
<code> const tree = jtree.TreeNode.fromTsv(Disk.read(path).trim())</code>
<code> const permalinkSet = new Set()</code>
<code> tree.forEach(node => {</code><code>   let permalink = jtree.Utils.stringToPermalink(node.get("primaryTitle"))</code><code>   let counter = ""</code>
<code>   let dash = ""</code>
<code>   while (permalinkSet.has(permalink + dash + counter)) {</code><code>     dash = "-"</code><code>     counter = counter ? counter + 1 : 2</code>
<code>   }</code>
<code>   const finalPermalink = permalink + dash + counter</code>
<code>   permalinkSet.add(finalPermalink)</code>
<code>   // Delete Null values:</code>
<code>   node.forEach(field => {</code><code>     if (field.getContent() === "\\N") field.destroy()</code>
<code>   })</code>
<code>   if (node.get("originalTitle") === node.get("primaryTitle")) node.getNode("originalTitle").destroy()</code>
<code>   Disk.write(<code>${__dirname}/../imdb/${folder}/${finalPermalink}.title</code>, node.childrenToString())</code>
<code> })</code>
</div>

<p>The script iterates over each node and creates a file for each row in the TSV.</p>

<p>This script required a few design decisions. For permalink uniqueness, I simply keep a set of titles and number them if a name comes up multiple times. There's also the question of what to do with nulls. IMDB sets the value to <code>\N</code>. Generally the TreeBase way is to not include the field in question. So I filtered out null values. For cases where <code>primaryTitle === originalTitle</code>, I stripped the latter. For the Genres field, it's a CSV array. I'd like to make that follow the TreeBase convention of a SSV. I don't know all the possibilities though without iterating, so I'll just skip this for now.</p>

<p>Here are the results of the script for the small 60 file TreeBase:</p>

<p><img src="60files.png" /></p>

<h3>Building the Grammar File</h3>

<p>The Grammar file adds some intelligence to a TreeBase. You can think of it as the schema for your base. TreeBase scripts can read those Grammar files and then do things like provide type checking or syntax highlighting.</p>

<p>Now that we have a sample <code>title</code> file, I'm going to take a first pass at the grammar file for our TreeBase. I copied the file <code>the-photographical-congress-arrives-in-lyon.title</code> and pasted it into the right side of the <a href="https://jtree.treenotation.org/designer/">Tree Language Designer</a>. Then I clicked <code>Infer Prefix Grammar</code>.</p>

<p>That gave me a decent starting point for the grammar:</p>

<div class="scrollArticleCode">
<code> inferredLanguageNode</code><code>  root</code>
<code>  inScope tconstNode titleTypeNode primaryTitleNode originalTitleNode isAdultNode startYearNode runtimeMinutesNode genresNode</code>
<code> keywordCell</code>
<code> anyCell</code>
<code> bitCell</code>
<code> intCell</code>
<code> tconstNode</code><code>  crux tconst</code>
<code>  cells keywordCell anyCell</code>
<code> titleTypeNode</code><code>  crux titleType</code>
<code>  cells keywordCell anyCell</code>
<code> primaryTitleNode</code><code>  crux primaryTitle</code>
<code>  cells keywordCell anyCell anyCell anyCell anyCell anyCell anyCell</code>
<code> originalTitleNode</code><code>  crux originalTitle</code>
<code>  cells keywordCell anyCell anyCell anyCell anyCell anyCell anyCell anyCell anyCell</code>
<code> isAdultNode</code><code>  crux isAdult</code>
<code>  cells keywordCell bitCell</code>
<code> startYearNode</code><code>  crux startYear</code>
<code>  cells keywordCell intCell</code>
<code> runtimeMinutesNode</code><code>  crux runtimeMinutes</code>
<code>  cells keywordCell bitCell</code>
<code> genresNode</code><code>  crux genres</code>
<code>  cells keywordCell anyCell</code>
</div>

<p>The generated grammar needed a little work. I renamed the root node and added catchAlls and a base "abstractFactType". The Grammar language and tooling for TreeBase is very new, so all that should improve as time goes on.</p>

<p>My <code>title.grammar</code> file now looks like this:</p>

<div class="scrollArticleCode">
<code> titleNode</code><code>  root</code>
<code>  pattern \.title$</code>
<code>  inScope abstractFactNode</code>
<code> keywordCell</code>
<code> anyCell</code>
<code> bitCell</code>
<code> intCell</code>
<code> abstractFactNode</code><code>  abstract</code>
<code>  cells keywordCell anyCell</code>
<code> tconstNode</code><code>  crux tconst</code>
<code>  extends abstractFactNode</code>
<code> titleTypeNode</code><code>  crux titleType</code>
<code>  extends abstractFactNode</code>
<code> primaryTitleNode</code><code>  crux primaryTitle</code>
<code>  extends abstractFactNode</code>
<code>  catchAllCellType anyCell</code>
<code> originalTitleNode</code><code>  crux originalTitle</code>
<code>  extends abstractFactNode</code>
<code>  catchAllCellType anyCell</code>
<code> isAdultNode</code><code>  crux isAdult</code>
<code>  cells keywordCell bitCell</code>
<code>  extends abstractFactNode</code>
<code> startYearNode</code><code>  crux startYear</code>
<code>  cells keywordCell intCell</code>
<code>  extends abstractFactNode</code>
<code> runtimeMinutesNode</code><code>  crux runtimeMinutes</code>
<code>  cells keywordCell intCell</code>
<code>  extends abstractFactNode</code>
<code> genresNode</code><code>  crux genres</code>
<code>  cells keywordCell anyCell</code>
<code>  extends abstractFactNode</code>
</div>

<p>Next I coped that file into the <code>60</code> folder with <code>cp /Users/breck/imdb/title.grammar 60/</code>. I have the <code>jtree</code> package installed on my local machine so I registered this new language with that with the command <code>jtree register /Users/breck/imdb/title.grammar</code>. Finally, I generated a Sublime syntax file for these title files with <code>jtree sublime title #pathToMySublimePluginDir</code>.</p>

<p>Now I have rudimentary syntax highlighting for these new title files:</p>

<p><img src="sublimeText.png" /></p>

<p>Notice the syntax highlighting is a little broken. The Sublime syntax generating still <a href="https://github.com/treenotation/jtree/issues/8">needs some work</a>.</p>

<p>Anyway, now we've got the basics done. We have a script for turning our CSV rows into Tree Notation files and we have a basic schema/grammar for our new TreeBase.</p>

<p>Let's get started with the bigger tests now.</p>

<h3>A 6k TreeBase</h3>

<p>I'm expecting this to be an easy one. I update my script to target the 6k files and run it with <code>/Users/breck/imdb/build.js</code>. A little alarmingly, it takes a couple of seconds to run:</p>

<div class="scrollArticleCode">
<code> real  0m3.144s</code>
<code> user  0m1.203s</code>
<code> sys 0m1.646s</code>
</div>

<p>The main script is going to iterate over 1,000x as many items so if this rate holds up it would take 50 minutes to generate the 6M TreeBase!</p>

<p>I do have some optimization ideas in mind, but for now let's explore the results.</p>

<p>First, let me build a catalog of typical tasks that I do with TreeBase that I will try to repeat with the 6k, 60k, 600k, and 6.5M TreeBases.</p>

<p>I'll just list them in Tree Notation:</p>

<div class="scrollArticleCode">
<code> task ls</code><code>  category bash</code>
<code>  description</code>
<code> task open sublime</code><code>  category sublime</code>
<code>  description Start sublime in the TreeBase folder</code>
<code> task sublime responsiveness</code><code>  category sublime</code>
<code>  description scroll and click around files in the treebase folder and see how responsive it feels.</code>
<code> task sublime search</code><code>  category sublime</code>
<code>  description find all movies with the query "titleType movie"</code>
<code> task sublime regex search</code><code>  category sublime</code>
<code>  description find all comedy movies with the regex query "genres ._Comedy._"</code>
<code> task open finder</code><code>  category finder</code>
<code>  description open the folder in finder and browse around</code>
<code> task git init</code><code>  category git</code>
<code>  description init git for the treebase</code>
<code> task git first status</code><code>  category git</code>
<code>  description see git status</code>
<code> task git first add</code><code>  category git</code>
<code>  description first git add for the treebase</code>
<code> task git first commit</code><code>  category git</code>
<code>  description first git commit</code>
<code> task sublime editing</code><code>  category sublime</code>
<code>  description edit some file</code>
<code> task git status</code><code>  category git</code>
<code>  description git status when there is a change</code>
<code> task git add</code><code>  category git</code>
<code>  description add the change above</code>
<code> task git commit</code><code>  category git</code>
<code>  description commit the change</code>
<code> task github push</code><code>  category github</code>
<code>  description push the treebase to github</code>
<code> task treebase start</code><code>  category treebase</code>
<code>  description how long will it take to start treebase</code>
<code> task treebase error check</code><code>  category treebase</code>
<code>  description how long will it take to scan the base for errors.</code>
</div>

<p>💣 Before I get to the results, let me note I had 2 bugs. First I needed to update my <code>title.grammar</code> file by adding a <code>cells fileNameCell</code> to the root node and also adding a <code>fileNameCell</code> line. Second, my strategy above of putting the CSV file for each TreeBase into the same folder as the TreeBase was not ideal as Sublime Text would open that file as well. So I moved each file up with <code>mv titles.tsv ../6k.titles.tsv</code>.</p>

<p>The results for 6k are below.</p>

<div class="scrollArticleCode">
<code> category,description,result</code>
<code> bash,ls,instant</code>
<code> sublime,Start sublime in the TreeBase folder,instant</code>
<code> sublime,scroll and click around files in the treebase folder and see how responsive it feels.,nearInstant</code>
<code> sublime,find all movies with the query "titleType movie",neaerInstant</code>
<code> sublime,find all comedy movies with the regex query "genres ._Comedy._",nearInstant</code>
<code> finder,open and browse,instant</code>
<code> git,init git for the treebase,instant</code>
<code> git,see git status,instant</code>
<code> git,first git add for the treebase,aFewSeconds</code>
<code> git,first git commit,instant</code>
<code> sublime,edit some file,instant</code>
<code> git,git status when there is a change,instant</code>
<code> git,add the change above,instant</code>
<code> git,commit the change,instant</code>
<code> github,push the treebase to github,~10 seconds</code>
<code> treebase,how long will it take to start treebase,instant</code>
<code> treebase,how long will it take to scan the base for errors.,nearInstant</code>
</div>

<p>So 6k worked without a hitch. Not surprising as this is in the ballpark of where I normally operate with TreeBases.</p>

<p>Now for the first of three 10x jumps.</p>

<h3>A 60k TreeBase</h3>

<p>💣 This markdown file that I'm writing was in the parent folder of the 60k directory and Sublime text seemed to be slowing a bit, so I closed Sublime and created a new unrelated folder to hold this writeup separate from the TreeBase folders.</p>

<p>The build script for the 60k TreeBase took 30 seconds or so, as expected. I can optimize for that later.</p>

<p>I now repeat the tasks from above to see how things are holding up.</p>

<div class="scrollArticleCode">
<code> category,description,result</code>
<code> bash,ls,aFewSeconds</code>
<code> sublime,Start sublime in the TreeBase folder,aFewSeconds with Beachball</code>
<code> sublime,scroll and click around files in the treebase folder and see how responsive it feels.,instant</code>
<code> sublime,find all movies with the query "titleType movie",~20 seconds with beachball</code>
<code> sublime,find all comedy movies with the regex query "genres ._Comedy._",~20 seconds with beachball</code>
<code> git,init git for the treebase,instant</code>
<code> finder,open and browse,6 seconds</code>
<code> git,see git status,nearInstant</code>
<code> git,first git add for the treebase,1 minute</code>
<code> git,first git commit,10 seconds</code>
<code> sublime,edit some file,instant</code>
<code> git,git status when there is a change,instant</code>
<code> git,add the change above,instant</code>
<code> git,commit the change,instant</code>
<code> github,push the treebase to github,~10 seconds</code>
<code> treebase,how long will it take to start treebase,~10 seconds</code>
<code> treebase,how long will it take to scan the base for errors.,~5 seconds</code>
</div>

<p>Uh oh. Already I am noticing some scaling delays with a few of these tasks.</p>

<p>💣 The first <code>git add</code> took about 1 minute. I used to know the internals of Git well but that was a decade ago and my knowledge is rusty.</p>

<p>I will now look some stuff up. Could Git be creating 1 file for each file in my TreeBase? I found <a href="https://www.monperrus.net/martin/one-million-files-on-git-and-github">this post</a> from someone who created a Git repo with 1.7M files which should turn out to contain useful information. From that post it looks like you can indeed expect 1 file for Git for each file in the project.</p>

<p>The first <code>git commit</code> took about 10 seconds. Why? Git printed a message about <a href="https://stackoverflow.com/questions/8633981/what-does-auto-packing-the-repository-for-optimum-performance-mean/16233094">Autopacking</a>. It seems Git will combine a lot of small files into packs (perhaps in bundles of 6,700, though I haven't dug in to this) to speed things up. Makes sense.</p>

<p>💣 I forgot to mention, while doing the tasks for the 60k TreeBase, my computer fan kicked on. A brief look at Activity Monitor showed a number of <code>mdworker_shared</code> processes using single digit CPU percentages each, which appears to be some <a href="https://discussions.apple.com/thread/8510132">OS level indexing process</a>. That's hinting that a bigger TreeBase might require at least some basic OS/file system config'ing.</p>

<p>Besides the delays with <code>git</code> everything else seemed to remain fast. The 60k TreeBase choked a little more than I'd like but seems with a few tweaks things could remain screaming fast.</p>

<p>Let's move on to the first real challenge.</p>

<h3>A 600k TreeBase</h3>

<p>💣 The first problem I hit immediately in that my <code>build.js</code> is not efficient. I hit a v8 out of memory error. I could solve this by either 1) streaming the TSV one row at a time or 2) cleaning up the unoptimized jtree library to handle bigger data better. I chose to spend a few minutes and go with option 1).</p>

<p>💣 It appears the first build script started writing files to the 600k directory before it failed. I had to <code>rm -rf 600k/</code> and that took a surprisingly long time. Probably a minute or so. Something to keep an eye on.</p>

<p>💣  I updated my build script to use streams. Unfortunately the streaming <a href="https://www.npmjs.com/package/csv-parse">csv parser</a> I switched to choked on line 32546. Inspecting that vicinity it was hard to detect what it was breaking on. Before diving in I figured I'd try a <a href="https://www.npmjs.com/package/csv-parser">different library</a>.</p>

<p>💣 The new library seemed to be working but it was taking a while so I added some instrumentation to the script. From those logs the new script seems to generate about 1.5k files per second. So should take about 6 minutes for all 600k. For the 6.5M files, that would grow to an hour, so perhaps there's more optimization work to be done here.</p>

<p>💣 Unfortunately the script exited early with:</p>

<div class="scrollArticleCode">
<code> Error: ENAMETOOLONG: name too long, open '/Users/breck/imdbPost/../imdb/600k/mord-an-lottomillionr-karl-hinrich-charly-l.sexualdelikt-an-carola-b.bankangestellter-zweimal-vom-selben-bankruber-berfallenmord-an-lottomillionr-karl-hinrich-charly-l.sexualdelikt-an-carola-b.bankangestellter-zweimal-vom-selben-bankruber-berfallen01985nncrimenews.title'</code>
</div>

<p>Turns out the Apple File System has a filename <a href="https://en.wikipedia.org/wiki/Comparison_of_file_systems">size limit</a> of 255 UTF-8 characters so this error is understandable. However, inspecting the filename shows that for some reason the permalink was generated by combining the original title with the primary title. Sounds like a bug.</p>

<p>I <code>cd</code> into the <code>600k</code> directory to see what's going on.</p>

<p>💣 Unfortunately <code>ls</code> hangs. <code>ls -f -1 -U</code> seems to go faster.</p>

<p>The titles look correct. I'm not sure why the script got hung up on that one entry. For now I'll just wrap the function call in a Try/Catch and press on. I should probably make this script resumable but will skip that for now.</p>

<p>Rerunning the script...it worked! That line seemed to be the only problematic line.</p>

<p>We now have our 600k TreeBase.</p>

<div class="scrollArticleCode">
<code> category,description,result</code>
<code> bash,ls,~30 seconds</code>
<code> sublime,Start sublime in the TreeBase folder,failed</code>
<code> sublime,scroll and click around files in the treebase folder and see how responsive it feels.,X</code>
<code> sublime,find all movies with the query "titleType movie",X</code>
<code> sublime,find all comedy movies with the regex query "genres ._Comedy._",X</code>
<code> finder,open and browse,3 minutes</code>
<code> git,init git for the treebase,nearInstant</code>
<code> git,see git status,6s</code>
<code> git,first git add for the treebase,40 minutes</code>
<code> git,first git commit,10 minutes</code>
<code> sublime,edit some file,X</code>
<code> git,git status when there is a change,instant</code>
<code> git,add the change above,instant</code>
<code> git,commit the change,instant</code>
<code> github,push the treebase to github,~10 seconds</code>
<code> treebase,how long will it take to start treebase,~10 seconds</code>
<code> treebase,how long will it take to scan the base for errors.,~5 seconds</code>
</div>

<p>💣 <code>ls</code> is now nearly unusable. <code>ls -f -1 -U</code> takes about 30 seconds. A straight up <code>ls</code> takes about 45s.</p>

<p>💣 Sublime Text failed to open. After 10 minutes of 100% CPU usage and <a href="Spinning_pinwheel">beachball'ing</a> I force quit the program. I tried twice to be sure with the same result.</p>

<p>💣 <code>mdworker_shared</code> again kept my laptop running hot. I found a way of potentially <a href="http://osxdaily.com/2011/12/30/exclude-drives-or-folders-from-spotlight-index-mac-os-x/">disabling Mac OS X Spotlight Indexing</a> of the IMDB folder.</p>

<p>💣 Opening the <code>600k</code> folder in Apple's Finder gave me a loading screen for about 3 minutes</p>

<p><img src="600k-finder-loading.png"></p>

<p>At least it eventually came up:</p>

<p><img src="600k-finder.png"></p>

<p>Now, how about Git?</p>

<p>💣 The first <code>git add .</code> took <em>40 minutes</em>! Yikes.</p>

<div class="scrollArticleCode">
<code> real  39m30.215s</code>
<code> user  1m19.968s</code>
<code> sys 13m49.157s</code>
</div>

<p>💣 <code>git status</code> after the initial git add took about a minute.</p>

<p>💣 The first <code>git commit</code> after the git add took about 10 minutes.</p>

<p>GitHub turns out to be a real champ. Even with 600k files the first <code>git push</code> took less than 30 seconds.</p>

<div class="scrollArticleCode">
<code> real  0m22.406s</code>
<code> user  0m2.657s</code>
<code> sys 0m1.724s</code>
</div>

<p>The <a href="https://github.com/breck7/600k">600k repo</a> on GitHub comes up near instantly. GitHub just shows the first 1k out of 600k files which I think is a good compromise, and far better than a multiple minute loading screen.</p>

<p>💣 Sadly there doesn't seem to be any pagination for this situation on GitHub, so not sure how to view the rest of the directory contents.</p>

<p>I can pull up a file quickly on GitHub, like the entry for <a href="https://github.com/breck7/600k/blob/master/007-licence-to-kill.title">License to Kill</a>.</p>

<p>How about editing files locally? Sublime is no use so I'll use <code>vim</code>. Because <code>ls</code> is so slow, I'll find the file I want to edit on GitHub. Of course because I can't find pagination in GitHub I'll be limited to editing one of the first 1k files. I'll use just that License to Kill entry.</p>

<p>So the command I use <code>vim 007-licence-to-kill.title</code>. Editing that file is simple enough. Though I wish we had support for Tree Notation in vim to get syntax highlighting and such.</p>

<p>💣 Now I do <code>git add .</code>. Again this takes a while. What I now realize is that my fancy command prompt does some <code>git status</code> with every command. So let's disable that.</p>

<p>After going in and cleaning up my shell (including switching to zsh) I've got a bit more performance back on the command line.</p>

<p>💣 But just a bit. A <code>git status</code> still takes about 23 seconds! Even with the <code>-uno</code> option it takes about 15 seconds. This is with 1 modified file.</p>

<p>Now adding this 1 file seems tricky. Most of the time I do a <code>git status</code> and see that I want to add everything so I do a <code>git add .</code>.</p>

<p>💣 But I tried <code>git add .</code> in the 600k TreeBase and after 100 seconds I killed the job. Instead I resorted to <code>git add 007-licence-to-kill.title</code> which worked pretty much instantly.</p>

<p>💣 <code>git commit</code> for this 1 change took about 20 seconds. Not too bad but much worse than normal.</p>

<p><code>git push</code> was just a few seconds.</p>

<p>I was able to <a href="https://github.com/breck7/600k/blob/master/007-licence-to-kill.title">see the change on GitHub</a> instantly. Editing that file on GitHub and committing was a breeze. Looking at the change history and blame on GitHub was near instant.</p>

<p>Git blame locally was also just a couple of seconds.</p>

<h4>Pause to Reflect</h4>

<p>So TreeBase struggles at the 600k level. You cannot just use TreeBase at the 100k level without preparing your system for it. Issues arise with GUIs like Finder and Sublime, background file system processes, shells, git, basic bash utilities, and so forth.</p>

<p>I haven't looked yet into RAM based file systems or how to setup my system to make this use case work well, but for now, out of the box, I cannot recommend TreeBase for databases of more than 100,000 entities.</p>

<p>Is there even a point now to try 6.5M? Arguably no.</p>

<p>However, I've come this far! No turning back now.</p>

<h3>A 6.5M TreeBase</h3>

<p>To recap what I am doing here: I am taking a single 6.5 million row 500MB TSV file that could easily be parsed into a SQLite or other battle hardened database and instead turning it into a monstrous 6.5 million file TreeBase backed by Git and writing it to my hard disk with no special configuration.</p>

<p>By the way, I forgot to mention my system specs for the record. I'm doing this on a MacBook Air running macOS Catalina on a 2.2Ghz Dual-core i7 with 8GB of 1600 Mhz DDR3 Ram with a 500GB Apple SSD using APFS. This is the last MacBook with a great keyboard, so I really hope it doesn't break.</p>

<p>Okay, back to the task at hand.</p>

<p>I need to generate the 6.5M files in a single directory. The 600k TreeBase took 6 minutes to generate so if that scales linearly 6.5M should take an hour. The first <code>git add</code> for 600k took 40 minutes, so that for 6.5M could take 6 hours. The first <code>git commit</code> for 600k took 10 minutes, so potentially 1.5 hours for 6.5M. So this little operation might take about 10 hours.</p>

<p>I'll stitch these operations together into a shell script and run it overnight (I'll make sure to check the batteries in my smoke detectors first).</p>

<p>Here's the script to run the whole routine:</p>

<div class="scrollArticleCode">
<code> time node buildStream.js</code>
<code> time cd ~/imdb/6m/</code>
<code> time git add .</code>
<code> time git commit -m "initial commit"</code>
<code> time git push</code>
</div>

<p>Whenever running a long script, it's smart to test it with a smaller dataset first. I successfully tested this script with the 6k file dataset. Everything worked. Everything should be all set for the final test.</p>

<p>(Later the next day...)</p>

<h3>It's Alive!</h3>

<p>It worked!!! I now have a TreeBase with over 6 million files in a single directory. Well, a few things worked, most things did not.</p>

<div class="scrollArticleCode">
<code> category,description,result</code>
<code> bash,ls,X</code>
<code> sublime,Start sublime in the TreeBase folder,X</code>
<code> sublime,scroll and click around files in the treebase folder and see how responsive it feels.,X</code>
<code> sublime,find all movies with the query "titleType movie",X</code>
<code> sublime,find all comedy movies with the regex query "genres ._Comedy._",X</code>
<code> finder,open and browse,X</code>
<code> git,init git for the treebase,nearInstant</code>
<code> git,first git add for the treebase,12 hours</code>
<code> git,first git commit,5 hours</code>
<code> sublime,edit some file,X</code>
<code> git,git status when there is a change,X</code>
<code> git,add the change above,X</code>
<code> git,commit the change,X</code>
<code> github,push the treebase to github,X</code>
<code> treebase,how long will it take to start treebase,X</code>
<code> treebase,how long will it take to scan the base for errors.,X</code>
</div>

<p>💣 There was a slight hiccup in my script where somehow v8 again ran out of memory. But only after creating 6,340,000 files, which is good enough for my purposes.</p>

<p>💣 But boy was this slow! The creation of the 6M+ files took 3 hours and 20 minutes.</p>

<p>💣  The first <code>git add .</code> took a whopping 12 hours!</p>

<p>💣 The first <code>git commit</code> took 5 hours!</p>

<p>💣 A few times when I checked on the machine it was running hot. Not sure if from CPU or Disk or a combination.</p>

<p>💣 I eventually quit <code>git push</code>. It quickly completed <code>Counting objects: 6350437, done.</code> but then nothing happened except lots of CPU usage for hours.</p>

<p>Although most programs failed, I was at least able to successfully create this monstrosity and navigate the folder.</p>

<p>The experiment has completed. I took a perfectly usable 6.5M row TSV file and transformed it into a beast that brings some of the most well-known programs out there to their knees.</p>

<p>💣 NOTE: I do not recommend trying this at home. My laptop became lava hot at points. Who knows what wear and tear I added to my hard disk.</p>

<h3>What have I learned?</h3>

<p>So that is the end of the experiment. Can you build a Git-backed TreeBase with 6.5M files in a single folder? Yes. Should you? No. Most of your tools won't work or will be far too slow. There's infrastructure and design work to be done.</p>

<p>I was actually pleasantly surprised by the results of this early test. I was confident it was going to fail but I wasn't sure exactly how it would fail and at what scale. Now I have a better idea of that. TreeBase currently sucks at the 100k level.</p>

<p>I also now know that the hardware for this type of system feels ready and it's just parts of some software systems that need to be adapted to handle folders with lots of files. I think those software improvements across the stack will be made and this dumb thing could indeed scale.</p>

<h3>What's Next?</h3>

<p>Now, my focus at the moment is not on big TreeBases. My focus is on making the experience of working with little TreeBases great. I want to help get things like <a href="https://github.com/treenotation/jtree/issues/2">Language Server Protocol</a> going for TreeBases and a Content Management System backed by TreeBase.</p>

<p>But I now can envision how, once the tiny TreeBase experience is nailed, you should be able to use this for bigger tasks. The infrastructure is there to make it feasible with just a few adjustments. There are some config tweaks that can be made, more in-memory approaches, and some straightforward algorithmic additions to make to a few pieces of software. I also have had some fun conversations where people have suggested good sharding strategies that may prove useful without changing the simplicity of the system.</p>

<p>That being said, it would be fun to do this experiment again but this time try and make it work. Once that's a success, it would be fun to try and scale it another 100x, and try to build a TreeBase for something like the 180M paper <a href="https://www.semanticscholar.org/">Semantic Scholar</a> dataset.</p>

<h3>Why Oh Why TreeBase?</h3>

<p>Okay, you might be wondering what is the point of this system? Specifically, why use the file system and why use Tree Notation?</p>

<h4>1) The File System is Going to Be Here for a Long Long Time</h4>

<p>1) About 30m programmers use approximately 100 to 500 general purpose programming languages. All of these actively used general purpose languages have battle tested APIs for interacting with file systems. They don't all have interfaces to every database program. Any programmer, no matter what language they use, without having to learn a new protocol, language, or package, could write code to interact with a TreeBase using knowledge they already have. Almost every programmer uses Git now as well, so they'd be familiar with how TreeBase change control works.</p>

<p>2) Over one billion more casual users are familiar with using their operating system tools for interacting with Files (like Explorer and Finder). Wouldn't it be cool if they could use tools they already know to interact with structured data?</p>

<p>Wouldn't it be cool if we could combine sophisticated type checking, querying, and analytical capabilities of databases with the simplicity of files? Programmers can easily build GUIs on top of TreeBase that have any and all of the functionality of traditional database-backed programs but have the additional advantage of an extremely well-known access vector to their information.</p>

<p>People have been predicting the death of files but these predictions are wrong. Even Apple recently backtracked and added a Files interface to iOS. Files and folders aren't going anywhere. It's a very simple and useful design pattern that works in the analog and digital realm. Files have been around for <a href="https://en.wikipedia.org/wiki/Papyrus">at least 4,500 years</a> and my guess is will be around for another 5,000 years, if the earth doesn't blow up. Instead of dying, on the contrary file systems will keep getting better and better. </p>

<h4>2) Tree Notation is All You Need to Create Meaningful Semantic Content</h4>

<p>People have recognized the value of semantic, strongly typed content for a long time. Databases have been strongly typed since the beginning of databases. Strongly typed programming languages have dominated the software world since the beginning of software.</p>

<p>People have been attempting to build a system for collaborative semantic content for decades. <a href="https://en.wikipedia.org/wiki/XML">XML</a>, <a href="https://www.w3.org/RDF/">RDF</a>, <a href="https://www.w3.org/TR/owl2-overview/">OWL2</a>, <a href="https://json-ld.org/">JSON-LD</a>, <a href="http://schema.org/">Schema.org</a>—these are all great projects. I just think they can be simplified and I think one strong refinement is Tree Notation.</p>

<p>I imagine a world where you can effortlessly pass TreeBases around and combine them in interesting ways. As a kid I used to collect baseball cards. I think it would be cool if you could just as easily pass around "cards" like a "TreeBase of all the World's Medicines" or a "TreeBase of all the world's academic papers" or a "TreeBase of all the world's chemical compounds" and because I know how to work with one TreeBase I could get value out of any of these TreeBases. Unlike books or weakly typed content like Wikipedia, TreeBases are computable. They are like specialized little brains that you can build smart things out of.</p>

<p>So I think this could be pretty cool. As dumb as it is.</p>

<p>I would love to hear your thoughts.</p>

<p>Published 1/29/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//building-a-treebase-with-6-point-5-million-files.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="dataset-needed"><a href="#dataset-needed">Dataset Needed</a></h1>
<div class="scrollArticleDate">January 23, 2020 — </div>

<p>The phrase "citation needed" needs to go. In its place we should use the far superior "dataset needed".</p>

<p>Whether it's an academic paper, news report, blog post, or marketing ad, citations linking to text summaries should be frowned upon.</p>

<p>Link to the dataset. If you want to include a conclusion, provide a deep link to the relevant query of the dataset. Do not repeat conclusions that don't have an accompanying query. Otherwise like a game of Telephone the truth gets distorted with each relay.</p>

<p>Of course, most sources don't currently publish their datasets. And almost none of them publish their datasets in deep-linkable way. So step one is fixing that problem. <a href="https://observablehq.com/">Lots</a> <a href="https://cloud.google.com/bigquery/">of</a> <a href="https://datarepository.wolframcloud.com/">cool</a> <a href="https://public.tableau.com/en-us/s/">work</a> <a href="https://idl.cs.washington.edu/">is</a> <a href="https://github.com/BurntSushi/xsv">going</a> <a href="https://github.com/jupyterlab/jupyterlab">on</a> <a href="https://github.com/awesomedata/awesome-public-datasets">in</a> <a href="https://usafacts.org/">these</a> <a href="https://datasetsearch.research.google.com/">areas</a>.</p>

<p>I remember being a high school student and getting graded on our dataset notebooks we made in the lab. Writing clean data should be widely taught in school, and there's an army of potential workers who could help us create more public, deep-linkable datasets.</p>

<p>Thanks to DL for helping me refine my thinking from this <a href="https://breckyunits.com/dreaming-of-a-data-checked-language.html">earlier post</a>.</p>

<p>1/23/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//dataset-needed.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="type-the-world"><a href="#type-the-world">Type the World</a></h1>
<div class="scrollArticleDate">January 20, 2020 — </div>

<p>In this post I briefly describe eleven threads in languages and programming. Then I try to connect them together to make some predictions about the future of knowledge encoding.</p>

<p>This might be hard to follow unless you have experience working with types, whether that be types in programming languages, or types in databases, or types in Excel. Actually, this may be hard to follow regardless of your experience. I'm not sure I follow it. Maybe just stay for the links. Skimming is encouraged.</p>

<h4>First, from the Land of Character Sets</h4>

<p>Humans invented characters roughly <a href="https://en.wikipedia.org/wiki/List_of_languages_by_first_written_accounts">5,000 years ago</a>.</p>

<p><a href="https://en.wikipedia.org/wiki/Binary_code">Binary notation</a> was invented roughly 350 years ago.</p>

<p>The first widely adopted system for using binary notation to represent characters was ASCII, which was created only <a href="https://en.wikipedia.org/wiki/ASCII">60 years ago</a>. ASCII encodes little more than the characters used by English.</p>

<p>In 1992 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8 was designed</a> which went on to become the first widespread system that encodes all the characters for all the world's languages.</p>

<p><strong>For about 99.6% of recorded history we did not have a globally used system to encode all human characters into a single system. Now we do.</strong></p>

<h4>Meanwhile, in the Land of Standards Organization</h4>

<p>Scientific standards are the original type schemas. Until recently, <a href="https://en.wikipedia.org/wiki/Standards_organization">Standards Organizations</a> dominated the creation of standards.</p>

<p>You might be familiar with terms like meter, gram, amp, and so forth. These are well defined units of measure that were pinned down in the <a href="https://en.wikipedia.org/wiki/International_System_of_Units">International System of Units</a>, which was first published in 1960.</p>

<p>The International Organization for Standardization (ISO) began around 100 years ago and is the organization behind a number of <a href="https://www.iso.org/popular-standards.html">popular standards</a> from <a href="https://www.iso.org/iso-4217-currency-codes.html">currency codes</a> to <a href="https://www.iso.org/iso-8601-date-and-time-format.html">date and time</a> formats.</p>

<p><strong>For 98% of recorded history we did not have global standards. Now we do.</strong></p>

<h4>Meanwhile, in Math Land</h4>

<p>My grasp of the history of mathematics isn't strong enough to speak confidently to trends in the field, but I do want to mention that in the past century there has been a lot of important research into <a href="https://en.wikipedia.org/wiki/Type_theory">type theories</a>.</p>

<p>In the past 100 years type theories have taken their place as part of the <a href="https://en.wikipedia.org/wiki/Foundations_of_mathematics">foundation of mathematics</a>.</p>

<p><strong>For 98% of recorded history we did not have strong theories of type systems. Now we do.</strong></p>

<h4>Meanwhile, in Programming Language Land</h4>

<p>The research into mathematical type and set theories in the 1900's led directly into the creation of useful new programming languages and programming language features.</p>

<p>From the <a href="https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus">typed lambda calculus in the 1940's</a> to the static type system in languages like <a href="https://en.wikipedia.org/wiki/C_(programming_language">C</a>) to the ongoing experiments of <a href="https://www.haskell.org/">Haskell</a> or the rapid growth of the <a href="https://www.typescriptlang.org/">TypeScript ecosystem</a>, the research into types has led to hundreds of software inventions.</p>

<p>In the late 1990's and 2000's, a slew of programming languages that underutilized innovations from type theory in the name of easier prototyping, like Python and Ruby and Javascript, became very popular. For a while this annoyed programmers who understood the benefits of type systems. But now they too are benefiting, as there is a bigger demand for richer type systems now due to the increase in the number of programmers.</p>

<p><strong>95%+ of the most popular programming languages use increasingly smarter type systems.</strong></p>

<h4>Meanwhile, in API Land</h4>

<p>Before the Internet became widespread, the job of most programmers was to write software that interacted only with other software on the local machine. That other software was generally under their control or well documented.</p>

<p>In the late 1990's and 2000's, a big new market arose for programmers to write software that could interact over the Internet with software on other machines that they had no control of or knowledge about.</p>

<p>At first there was not a good standard language to use that was agreed upon by many people. 1996's <a href="https://en.wikipedia.org/wiki/XML">XML</a>, a variant of <a href="https://en.wikipedia.org/wiki/Standard_Generalized_Markup_Language">SGML</a> from 1986, was the first attempt to get some traction for this job. But XML and the dialects of XML for APIs like <a href="https://en.wikipedia.org/wiki/SOAP">SOAP (1998)</a> and <a href="https://en.wikipedia.org/wiki/Web_Services_Description_Language">WSDL (2000)</a> were not easy to use. Then <a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a> created a new language called <a href="https://www.json.org/">JSON</a> in 2001. JSON made web API programming easier and helped create a huge wave of web API businesses. For me this was great. In the beginning of my programming career I got jobs working on these new JSON APIs.</p>

<p>The main advantage that JSON had over XML was simple, well defined types. It had just a few primitive types—like numbers, booleans and strings—and a couple of complex types—lists and dicts. It was a very useful collection of structures that were important across all programming languages, put together in a simple and concise way. It took very little time to learn the entire thing. In contrast, XML was "extensible" and defined no types, leading to many massive dialects defined by committee.</p>

<p><strong>For 99.8% of recorded history we did not have a global network conducting automated business transactions with a typed language. Now we do.</strong></p>

<h4>Meanwhile, in SQL Land</h4>

<p>When talking about types and data one must pay homage to <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> databases, which store most of the world's structured data and perform the transactions that our businesses depend on.</p>

<p>SQL programmers spend a lot of time thinking about the structure of their data and defining it well in a SQL <a href="https://en.wikipedia.org/wiki/Data_definition_language">data definition language</a>.</p>

<p>Types play a huge role in SQL. The dominant SQL databases such as MySQL, SQL Server, and Oracle all contain common primitives like ints, floats, and strings. Most of the main SQL databases also have more extensive type systems for things like dates and money and even geometric primitives like <a href="https://www.postgresql.org/docs/9.5/datatype-geometric.html">circles and polygons</a> in PostgreSQL.</p>

<p>Critical information is stored in strongly typed SQL databases: Financial information; information about births, health and deaths; information about geography and addresses; information about inventories and purchase histories; information about experiments and chemical compounds.</p>

<p><strong>98% of the world's most valuable, processed information is now stored in typed databases.</strong></p>

<h4>Meanwhile, in the Land of Types as Code</h4>

<p>The standards we get from the Standards Organizations are vastly better than not having standards, but in the past they've been released as non-computable, weakly typed documents.</p>

<p>There are lots of projects that are now writing schemas in computable languages. The <a href="http://schema.org/">Schema.org project</a> is working to build a common global database of rich type schemas. <a href="https://json-ld.org/">JSON LD</a> aims to make the types of JSON more extensible. The <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> project has a rich collection of commonly used interfaces. <a href="https://developers.google.com/protocol-buffers">Protocol buffers</a> and <a href="https://capnproto.org/">similar</a> are another approach at language agnostic schemas. There are <a href="https://www.typedefs.com/">attempts</a> at languages just for types. <a href="https://graphql.org/">GraphQL</a> has a useful schema language with rich typing.</p>

<p><strong>100% of standards/type schemas can now themselves be written in strongly typed documents.</strong></p>

<h4>Meanwhile, in Git Land</h4>

<p><a href="https://en.wikipedia.org/wiki/Git">Git</a> is a distributed version control system created in 2005.</p>

<p>Git can be used to store and track changes to any type of data. You could theoretically put all of the English Wikipedia in Git, then CAPITALIZE all verbs, and save that as a single patch file. Then you could post your patch to the web and say "I propose the new standard is we should CAPITALIZE all verbs. Here's what it would look like." While this is a dumb idea, it demonstrates how Git makes it much cheaper to iterate on standards. Someone can propose both a change to the standard and the global updates all in a single operation. Someone can fork and branch to their heart's content.</p>

<p><strong>For 99.9% of recorded history, there was not a cheap way to experiment and evolve type schemas nor a safe way to roll them out. Now there is.</strong></p>

<h4>Meanwhile, in Hub Land</h4>

<p>In the past 30 years, central code hubs have emerged. There were early ones like <a href="https://sourceforge.net/">SourceForge</a> but in the past ten years <a href="http://github.com/">GitHub</a> has become the breakout star. GitHub has around 30 million users, which is also a good estimate of the total number of programmers worldwide, meaning nearly every programmer uses git.</p>

<p>In addition to source code hubs, package hubs have become quite large. Some early pioneers are still going strong like 1993's <a href="https://cran.r-project.org/">CRAN</a> but the breakout star is 2010's <a href="http://npmjs.com/">NPM</a>, which has more packages than the package managers of all other languages combined. </p>

<p>Types are arbitrary. The utility of a type depends not only on its intrinsic utility but also on its popularity. You can create a better type system—maybe a simpler universal day/time schema—but unless it gains popularity it will be of limited value.</p>

<p>Code hubs allow the sharing of code, including type definitions, and can help make type definitions more popular, which also makes them more useful.</p>

<p><strong>99% of programmers now use code hubs and hubs are a great place to increase adoption of types, making them even more useful.</strong></p>

<h4>Meanwhile, in Semantic Web Land</h4>

<p>The current web is a collection of untyped HTML pages. So if I were to open a web page with lots of information about diseases and had a semantic question requiring some computation, I'd have to read the page myself and use my slow brain to parse the information and then figure out the answer to my semantic question.</p>

<p><a href="https://en.wikipedia.org/wiki/Semantic_Web">The Semantic Web dream</a> is that the elements on web pages would be annotated with type information so the computer could do the parsing for us and compute the answers to our semantic questions.</p>

<p>While the "Semantic Web" did not achieve adoption like the untyped web, that dream remains very relevant and is ceaselessly worked upon. In a sense <a href="https://www.wolframalpha.com/">Wolfram Alpha</a> embodies an early version of the type of UX that was envisioned for the Semantic Web. The typed data in Wolfram Alpha comes from a nicely <a href="https://datarepository.wolframcloud.com/">curated collection</a>.</p>

<p>While lots of strongly typed proprietary databases exist on the web for various domains from <a href="http://imdb.com/">movies</a> to <a href="https://www.crunchbase.com/">startups</a>, and while Wikipedia is arguable undergoing <a href="https://en.wikipedia.org/wiki/Gradual_typing">gradual typing</a>, the open web still remains largely untyped and we don't have a universally accessible interface yet to the world's typed information.</p>

<p><strong>99% of the web is untyped while 99% of the world's typed information is silo-ed and proprietary.</strong></p>

<h4>Meanwhile, in Deep Learning Land</h4>

<p>Deep Learning is creeping in everywhere. In the past decade it has come to be the dominant strategy for NLP. In the past two years, a new <a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">general</a> learning strategy has become <a href="https://github.com/google-research/ALBERT">feasible</a>, where models learn some intrinsic structure of language and can use this knowledge to perform many different language tasks.</p>

<p>One of those tasks could be to rewrite untyped data in a typed language.</p>

<p><strong>AI may soon be able to write a strongly typed semantic web from the weakly typed web.</strong></p>

<h3>Tying All These Threads Together</h3>

<p>I see a global pattern here that I call the "Type the World" trend. Here are some future predictions from these past trends.</p>

<p>- We will always have creative, ambiguous, untyped human languages where new ideas can evolve freely</p>
<p>- In the future great new ideas from the untyped realm will be adopted faster by the typed realm</p>
<p>- Nearly all transactions in business and government will be in typed languages</p>
<p>- Someone will invent a wildly popular new domain specific language(s) for type definitions</p>
<p>- All the popular standards will be ones written in these new and improved TypeDSLs</p>
<p>- Git—or git like systems—will be used to store both the TypeDSLs and the typed data</p>
<p>- TypeHubs will arise hosting these widely used type schemas</p>
<p>- Programmers will get their types from TypeHubs regardless of which programming language they use</p>
<p>- Deep learning agents will be used to rewrite the web's untyped data into typed data</p>
<p>- Deep learning agents will be used to improve type schemas</p>
<p>- Human editors will review and sign off on the typing work of the deep learning agents</p>
<p>- Silo-ed domain specific standards will merge into one or a handful of global monolithic type systems</p>

<p>The result of this will be a future where all business, from finance to shopping to healthcare to law, is conducted in a rich, open type system, and untyped language work is relegated to research, entertainment and leisure.</p>

<p>While I didn't dive into the benefits of what Type the World will bring, and instead merely pointed out some trends that I think indicate it is happening, I do indeed believe it will be a fantastic thing. Maybe I'll give my take on why Type the World is a great thing in a future post.</p>

<p>Posted 1/20/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//type-the-world.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="if-stories-are-lies-why-do-they-work"><a href="#if-stories-are-lies-why-do-they-work">If stories are lies why do they work?</a></h1>
<div class="scrollArticleDate">January 16, 2020 — </div>

<p>I often <a href="https://breckyunits.com/narratives-misrepresent-complex-systems.html">rail</a> <a href="https://breckyunits.com/english-cannot-encode-real-news.html">against</a> <a href="https://breckyunits.com/dreaming-of-a-data-checked-language.html">narratives</a>. I think stories always oversimplify things, have hindsight bias, and often mislead. I spend a lot of time trying to invent tools for making data derived thinking as effortless as narrative thinking (so far, mostly in vain). And yet, as much as I rail on stories, I have to admit stories work.</p>

<p>I read an article that put it more succinctly:</p>


<p>I would agree with that. Despite the fact that 90% of stories are lies, they motivate people better than anything else. Stories make people feel something. They get people going.</p>

<p>What is the math here? On a population level, it seems people who follow stories have a survival advantage. On a local level, it seems people who can weave stories have an even greater survival advantage.</p>

<p>Why?</p>

<p>Perhaps it's due to risk taking. Perhaps the people who follow stories take more risks, on average, than people who don't, and even though many of those don't pan out some of those risks do pay off and the average is worth it.</p>

<p>Perhaps it's due to productivity. Perhaps people who are storiers spend less time analyzing and more time doing. The act of doing generates experience (data), so often the best way to be data-driven isn't to analyze more it's to go out there and do more to collect more data. As they say in machine learning, data trumps algorithms.</p>

<p>Perhaps it's due to focus. If you just responded to your senses all the time the world is a shimmering place, and perhaps narratives are necessary to get anything done at all.</p>

<p>Perhaps it's due to memory. A story like 'The Boy who Cried Wolf' is shorter and more memorable than  'Table of Results from a Randomized Experiment on the Effect of False Alarms on Subsequent Human Behavior'.</p>

<p>Perhaps it's healthier. Our brains are not much more advanced than the chimp. Uncertainty can create stress and anxiety. Perhaps the confidence that comes from belief in a story leads to less stress and anxiety leading to better health, which outweighs any downsides from decisions that go against the data.</p>

<p>Perhaps it's a cooperation advantage. If everyone is analyzing their individual decisions all the time, perhaps that comes at the cost of cooperation. Storiers go along with the group story, and so over time their populations get more done together. Maybe the opposite of stories isn't truth, it's anarchy.</p>

<p>Perhaps it's just more fun. Maybe stories are suboptimal for decision making and lead us astray all the time, and yet are still a survival advantage simply because it's a more enjoyable way to live. Even when you screw up royally, it can make a good story. As the saying goes, "don't take life too seriously, you'll never make it out alive."</p>

<p>Despite my problems with narratives and my quest for something better, it seems quite possible to me that at the end of the day it may turn out that there is nothing better, and it's best to make peace with stories, despite their flaws. And regardless of the future, I can't argue with the value of stories today for motivation and enjoyment. Nothing else works.</p>

<p>Written on 1/17/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//if-stories-are-lies-why-do-they-work.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="dreaming-of-a-data-checked-language"><a href="#dreaming-of-a-data-checked-language">Dreaming of a Data Checked Language</a></h1>
<div class="scrollArticleDate">January 3, 2020 — </div>

<p><span class="redSquig">Speling</span> errors and <span class="greenSquig">errors grammar</span> are <span class="dataError">nearly extinct in published content</span>. <b>Data errors</b>, however, <span class="dataError">are prolific</span>.</p>

<p>By data error I mean one the following errors: a statement without a backing dataset and/or definitions, a statement with data but a bad reduction(s), or a statement with backing data but lacking integrated context. I will provide examples of these errors later.</p>

<p>The hard sciences like physics, chemistry and most branches of engineering have low tolerance for data errors. <span class="dataError">But outside of those domains data errors are everywhere</span>.</p>

<p><span class="dataError">Fields like medicine, law, media, policy,  the social sciences, and many more are teeming with data errors, which are far more consequential than spelling or grammar errors</span>. If a drug company misspells the word <span class="redSquig">dockter</span> in some marketing material the effect will be trivial. But if that material contains data errors those <span class="dataError">often influence terrible medical decisions that lead to many deaths and wasted resources</span>.</p>

<h4>If Data Errors Were Spelling Errors</h4>

<p>You would be skeptical of National Geographic if their homepage looked like this:</p>

<p><img src="dataChecked_spellCheck.png"></p>

<p>We generally expect zero spelling errors when reading any published material.</p>

<p>Spell checking is now an effortless technology and <span class="dataError">everyone uses it</span>. Published books, periodicals, websites, tweets, advertisements, product labels: <span class="dataError">we are accustomed to reading content at least 99% free of spelling and grammar errors</span>. But there's no equivalent to a spell checker for data errors and when you look for them you see them everywhere.</p>


<h3>The Pandemic: An Experiment</h3>

<p>Data errors are so pervasive that I came up with a hypothesis today and put it to the test. My hypothesis was this: <b>100% of "reputable" publications will have at least one data error on their front page</b>.</p>

<h4>Method</h4>

<p>I wrote down 10 reputable sources off the top of my head: the <a href="https://www.wsj.com/">WSJ</a>, <a href="https://www.nejm.org/">the New England Journal of Medicine</a>, <a href="https://www.nature.com/">Nature</a>, <a href="https://www.economist.com/">the Economist</a>, <a href="https://www.newyorker.com/">the New Yorker</a>, <a href="https://www.aljazeera.com/">Al Jazeera</a>, <a href="https://hbr.org/">Harvard Business Review</a>, <a href="https://news.google.com/">Google News: Science</a>, <a href="https://www.fda.gov/home">the FDA</a>, and the <a href="https://www.nih.gov/">NIH</a>.</p>

<p>For each source, I went to their website and took a single screenshot of their homepage, above the fold, and skimmed their top stories for data errors.</p>

<h4>Results</h4>

<p><img src="dataErrorPandemic.jpg"></p>

<p>In the screenshots above, you can see that 10/10 of these publications had data errors front and center.</p>

<h4>Breaking Down These Errors</h4>

<p>Data errors in English fall into common categories. My working definition provides three: a lack of dataset and/or definitions, a bad reduction, or a lack of integrated context. There could be more, this experiment is just a starting point where I'm naming some of the common patterns I see.</p>

<p>The top article in the WSJ begins with "Tensions Rise in the Middle East". There are at least 2 data errors here. First is the <b>Lack of Dataset</b> error. Simply put: you need a dataset to make a statement like that. There is no longitudinal dataset in that article on tensions in the Middle East. There is also a <b>Lack of Definitions</b>. Sometimes you can not yet have a dataset but at least define what a dataset would be that could back your assertions. In this case we have neither a dataset nor a definition of what some sort of "Tensions" dataset would look like.</p>

<p>In the New England Journal of Medicine, the lead figure shows "excessive alcohol consumption is associated with atrial fibrillation" between 2 groups. One group had 0 drinks over a 6 month period and the other group had over 250 drinks (10+ per week). There was a small impact on atrial fibrillation. This is a classic <b>Lack of Integrated Context</b> data error. If you were running a lightbulb factory and found soaking lightbulbs in alcohol made them last longer, that might be an important observation. But humans are not as disposable, and health studies must always include <b>integrated context</b> to explore whether there is something of significance. Having one group make any sort of similar drastic lifestyle change will likely have some impact on any measurement. A good rule of thumb is anything you read that includes p-values to explain why it is significant is not significant.</p>

<p>In Nature we see the line "world's growing water shortage". This is a <b>Bad Reduction</b>, another very common data error. While certain areas have a water shortage, other areas have a surplus. Any time you see a broad diverse things grouped into one term, or "averages", or "medians", it's usually a data error. You always need access to the data, and you'll often see a more complex distribution that would prevent broad true statements like those.</p>

<p>In The Economist the lead story talks about an action that "will have profound consequences for the region". Again we have the <b>Lack of Definitions</b> error. We also have a <b>Forecast without a Dataset</b> error. There's nothing wrong with making a forecast--creating a hypothetical dataset of observations about the future--but one needs to actually create and publish that dataset and not just a vague unfalsifiable statement.</p>

<p>The New Yorker lead paragraph claims an event "was the most provocative U.S. act since...". I'll save you the suspense: the article did not include a thorough dataset of such historical acts with a defined measurement of provocative. Another <b>Lack of Dataset</b> error.</p>

<p>In Al Jazeera we see "Iran is transformed" and also a <b>Bad Reduction</b>, <b>Lack of Dataset</b> and <b>Lack of Definition</b> errors.</p>

<p>Harvard Business Review has a lead article about the Post-Holiday funk. In that article the phrase "research...suggests" is often a dead giveaway for a <b>Hidden Data</b> error, where the data is behind a paywall and even then often inscrutable. Anytime someone says "studies/researchers/experts" it is a data error.  We all know the earth revolves around the sun because we can all see the data for ourselves. Don't trust any data you don't have access to.</p>

<p>Google News has a link to an interesting article on the invention of a new type of color changing fiber, but the article goes beyond the matter at hand to make the claim: "What Exactly Makes One Knot Better Than Another Has Not Been Well-Understood – Until Now". There is a <b>Lack of Dataset</b> error for meta claims about the <em>knowledge of knot models</em>.</p>

<p>The FDA's lead article is on the Flu and begins with the words "Most viral respiratory infections...", then proceeds for many paragraphs with zero datasets. There is an overall huge <b>Lack of Datasets</b> in that article. There's also a <b>Lack of Monitoring</b>. Manufacturing facilities are a controlled, static environment. In uncontrolled, heterogeneous environments like human health, things are always changing, and to make ongoing claims without having infrastructure in place to monitor and adjust to changing data is a data error.</p>

<p>The NIH has an article on how increased exercise may be linked to reduced cancer risk. This is actually an informative article with 42 links to many studies with lots of datasets, however the huge data error here is <b>Lack of Integration</b>. It is very commendable to do the grunt work and gather the data to make a case, but simply linking to static PDFs is not enough—they must be integrated. Not only does that make it much more useful, but if you've never tried to integrate them, you have no idea if the pieces actually will fit together to support your claims.</p>

<p>While my experiment didn't touch books or essays, I'm quite confident the hypothesis will hold in those realms as well. If I flipped through some "reputable" books or essayist collections I'm 99.9% confident you'd see the same classes of errors. This site is no exception.</p>

<h3>The Problem is Language Tools</h3>

<p>I don't think anyone's to blame for the proliferation of data errors. I think it's still relatively recent that we've harnessed the power of data in specialized domains, and no one has yet invented ways to easily and fluently incorporate true data into our human languages.</p>

<p><span class="dataError">Human languages have absorbed a number of sublanguages over thousands of years</span> that have made it easier to communicate with ease in a more precise way. The base 10 number system (0,1,2,3,4,5,6,7,8,9) is one example that made it a lot easier to utilize arithmetic.</p>

<h4>Taking Inspiration from Programming Language Design</h4>

<p>Domains with low tolerance for data errors, <span class="dataError">like aeronautical engineering or computer chip design</span>, are heavily reliant on programming languages. I think it's worthwhile to explore the world of programming language design for ideas that might inspire improvements to our everyday human languages.</p>

<p>Some quick numbers for people not familiar with the world of programming languages. <span class="dataError">Around 10,000 computer languages have been released in history (most of them in the past 70 years)</span>. <span class="dataError">About 50-100 of those have more than a million users worldwide</span> and the names of some of them may be familiar to even non-programmers such as Java, Javascript, Python, HTML or Excel.</p>

<p>Not all programming languages are created equal. The designers of a language end up making <span class="dataError">thousands of decisions</span> about how their particular language works. While <span class="dataError">English has evolved with little guidance over millennia</span>, programming languages are often designed consciously by small groups and <span class="dataError">can evolve much faster</span>.</p>

<p>Often the designers change a language to make it easier to do something good or harder to do something bad.</p>

<p>Sometimes what is good and bad is up to the whims of the designer. Imagine I was an overly optimistic person and decided that English was too boring or pessimistic. I may invent a language without periods, where all sentences must end with an exclamation point! I'll call it Relish!</p>

<p><span class="dataError">Most of the time though, as data and experience accumulates, a rough consensus emerges</span> about what is good and bad in language design (though this too seesaws).</p>

<h5>Typed Checked Languages</h5>

<p>One of the patterns that has <span class="dataError">emerged</span> as generally a good thing over the decades to many languages is what's called "type checking". When you are programming you often create buckets that can hold values. For example, if you were programming a function that regulated how much power a jet engine should supply, you might take into account the reading from a wind speed sensor and so create a bucket named "windSpeed".</p>

<p><span class="dataError">Some languages</span> are designed to enforce stricter logic checking of your buckets to help catch mistakes. <span class="dataError">Others</span> will try to make your program work as written. For example, if later in your jet engine program you mistakenly assigned the indoor air temperature to the "windSpeed" bucket, the parsers of some languages would alert you while you are writing the program, while with some other languages you'd discover your error in the air. The former style of languages generally do this by having "type checking".</p>

<p>Type Checking of programming languages is somewhat similar to Grammar Checking of English, though it can be a lot more extensive. If you make a change in one part of the program in a typed language, the type checker can recheck the entire program to make sure everything still makes sense. This sort of thing would be very useful in a data checked language. If your underlying dataset changes and conclusions anywhere are suddenly invalid, it would be helpful to have the checker alert you.</p>

<p>Perhaps lessons learned from programing language design, like Type Checking, could be useful for building the missing data checker for English.</p>

<h3>A Blue Squiggly to Highlight Data Errors</h3>

<p>Perhaps what we need is a new color of squiggly:</p>

<p>✅ Spell Checkers: <span class="redSquig">red squiggly</span></p>
<p>✅ Grammar Checkers: <span class="greenSquig">green squiggly</span></p>
<p>❌ Data Checkers: <span class="blueSquig">blue squiggly</span></p>

<p>If we had a data checker that highlighted data errors <span class="dataError" title="Dataless Forecast. Lack of Definitions.">we would eventually see a drastic reduction in data errors</span>.</p>

<p>If we had a checker for data errors appear today our screens <span class="dataError">would be full of blue</span>. For example, click the button below to highlight just some of the data errors on this page alone.</p>

<p><style id="styleHolder"></style></p>
<p><button class="bigButton" onclick="document.getElementById('styleHolder').innerHTML = '.dataError {text-decoration: underline;text-decoration-style: wavy;text-decoration-color: blue;}'">Highlight data errors</button></p>

<h3>How Do We Reduce Data Errors?</h3>

<p>If someone created a working data checker today and applied it to all of our top publications, <span class="dataError" title="Dataless Forecast">blue squigglies would be everywhere</span>.</p>

<p><span class="dataError">It is very expensive and time consuming to build datasets</span> and make data driven statements without data errors, so am I saying until we can publish content free of data errors we should stop publishing most of our content? <b>YES</b>! If you don't have anything true to say, perhaps it's best not to say anything at all. At the very least, I wish all the publications above had disclaimers about how laden with data errors their stories are.</p>

<p>Of course I don't believe either of those are likely to happen. I think we are stuck with data errors until people have invented great new things so that it becomes a lot easier to publish material without data errors. I hope we somehow create a data checked language.</p>

<p>I still don't know what that looks like, exactly. I spend half my work time attempting to create such new languages and tools and the other half searching the world to see if someone else has already solved it. I feel like I'm making decent progress on both fronts but I still have no idea whether we are months or decades away from a solution.</p>

<p>While I don't know what the solution will be, I would not be surprised if the following patterns play a big role in moving us to a world where data errors are extinct:</p>

<p>1. <b>Radical increases in collaborative data projects</b>. It is very easy for a person or small group to crank out content laden with data errors. It takes small armies of people making steady contributions over a long time period to build the big datasets that can power content free of data errors.</p>
<p>2. <b>Widespread improvements in data usability</b>. <span class="dataError">Lots of people and organizations have moved in the past decade to make more of their data open</span>. However, it generally <span class="dataError">takes hours</span> to become fluent with one dataset, and there are <span class="dataError">millions</span> of them out there. Imagine if it took you hours to ramp on a single English word. That's the state of data usability right now. We need widespread improvements here to make integrated contexts easier.</p>
<p>3. <b>Stop subsidizing content laden with data errors</b>. We grant monopolies on information and so there's even more incentive to create stories laden with data errors—because there are more ways to lie than to tell the truth. We should revisit intellectual monopoly laws.</p>
<p>4. <b>Novel innovations in language</b>. Throughout history novel new sublanguages have enhanced our cognitive abilities. Things like geometry, Hindu-Arabic numerals, calculus, binary notation, etc. I hope some innovators will create very novel data sublanguages that make it much easier to communicate with data and reduce data errors.</p>

<p>Have you invented a data checked language, or are working on one? If so, please get in touch.</p>


<p>Written on 1/3/2020</p>


<p><style></p>
<p></style></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//dreaming-of-a-data-checked-language.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="english-cannot-encode-real-news"><a href="#english-cannot-encode-real-news">English cannot encode Real News</a></h1>
<div class="scrollArticleDate">August 19, 2019 — </div>

<h3>The Attempt to Capture Truth</h3>

<p>Back in the 2000's <a href="https://www.fooledbyrandomness.com/">Nassim Taleb's books</a> set me on a new path in search of truth. One truth I became convinced of is that <a href="https://breckyunits.com/narratives-misrepresent-complex-systems.html">most stories are false due to oversimplification</a>. I largely stopped writing over the years because I didn't want to contribute more false stories, and instead I've been searching for and building new <a href="https://breckyunits.com/ohayo.html">forms of communication</a> and <a href="https://treenotation.org/">ways of representing data</a> that hopefully can get us closer to truth.</p>

<p>I've tried my best to make my writings encode "real" and "true" information, but it's impossible to overcome the limitations of language. The longer any work of English writing is, the more inaccuracies it contains. This post itself will probably be more than 50% false.</p>

<p>But most people aren't aware of the problem.</p>

<h3>Fake news is a great idea.</h3>

<p>Then came DT and "fake news". One nice thing I can say about DT is that "fake news" is a great idea.</p>

<p><em>If your ideas are any good, you'll have to ram them down people's throats. - Howard H. Aiken</em></p>

<p><em>..in science the credit goes to the man who convinces the world, not to the man to whom the idea first occurs. - Francis Darwin</em></p>

<p>DT has done a great job at spreading this idea. Hundreds of millions of people, at least, now are at least vaguely familiar that there's a serious problem, even if people can't describe precisely what that is. Some people mistakenly believe "their news" is real and their opponents' news is fake. It's all fake news.</p>

<h3>What's the underlying problem?</h3>

<p>English is a fantastic story telling language that has been very effective at sharing stories, coordinating commerce and motivating armies, but English evolved in a simpler time with simpler technologies and far less understanding about how the world really works.</p>

<p>English oversimplifies the world which makes it easy to communicate something to be done. English is a modern day cave painting language. Nothing motivates a person better than a good story, and that motivation was essential to get us out of the cave. It didn't matter so much in which direction people went, as long as they went in some direction together.</p>

<p>But we are now out of the cave, and it is not enough to communicate what is to be done. We have many more options now and it's important that we have langauges that can better decide what is the best thing to do.</p>

<h3>What will a language that supports Real News look like?</h3>

<p>Real News is starting to emerge in a few places. The <a href="https://www.wsj.com">WSJ</a> has long been on the forefront but newer things like <a href="http://observablehq.com/">Observable</a> are also popping up.</p>

<p>I don't know exactly what a language for truth will look like but I imagine it will have some of these properties:</p>

<p>- It will be a language that is hard to lie with</p>
<p>- It will contain more numerics and be more data driven</p>
<p>- It will be interactive, with assumptions made clear and adjustable by the reader</p>
<p>- It will be blameable, with the source and history of every line and character auditable</p>
<p>- It will be linked and auditable, with the ability to "go to definitions"</p>
<p>- It will discourage obfuscation, and will make it easy to compare 2 representations and choose the simpler one</p>
<p>- It will be more visual, expanding beyond character alphabets and embracing more charts and visualizations</p>
<p>- It will be more Random Access, like bullet points</p>

<h3>English and Sapir–Whorf</h3>

<p>I would say until we move away from English and other story-telling langauges to encodings that are better for truth telling, our thinking will also be limited.</p>

<p><em>A language that doesn’t affect the way you think about programming, is not worth knowing. – Alan Perlis</em></p>

<p>New languages designed for truth telling might not just be useful in our everyday lives, they could very much change the way we think.</p>

<h3>Finally</h3>

<p>Again, to channel Taleb, I'm not saying English is bad. By all means, <em>enjoy the stories</em>. But just remember they are stories. If you are reading English, know that you are not reading Real News.</p>

<p>8/19/2019</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//english-cannot-encode-real-news.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="ohayo"><a href="#ohayo">Ohayo</a></h1>
<div class="scrollArticleDate">June 23, 2017 — </div>

<p>I just pushed a project I've been working on called <a href="http://ohayo.computer">Ohayo</a>.</p>

<p>You can also view it on GitHub: <a href="https://github.com/treenotation/ohayo">https://github.com/treenotation/ohayo</a></p>

<p>I wanted to try and make a fast, visual app for doing data science. I can't quite recommend it yet, but I think it might get there. If you are interested you can try it now.</p>

<p>6/23/2017</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//ohayo.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="show-hn-programming-is-now-two-dimensional"><a href="#show-hn-programming-is-now-two-dimensional">Show HN: Programming is Now Two-Dimensional</a></h1>
<div class="scrollArticleDate">June 21, 2017 — </div>

<h2>Eureka!</h2>

<p>I wanted to announce something small, but slightly novel, and potentially useful.</p>

<p>What did I discover? That there might be useful general purpose programming languages that don't use any visible syntax characters at all.</p>

<p>I call the whitespace-based notation <a href="https://treenotation.org/">Tree Notation</a> and languages built on top of it Tree Languages.</p>

<p>Using a few simple atomic ingredients---words, spaces, newlines, and indentation--you can construct grammars for new programming languages that can do anything existing programming languages can do. A simple example:</p>

<div class="scrollArticleCode">
<code> if true</code><code>  print Hello world</code>
</div>

<p>This language has no parentheses, quotation marks, colons, and so forth. Types, primitives, control flow--all of that stuff can be determined by words and contexts instead of introducing additional syntax rules. If you are a Lisper, think of this "novel" idea as just "lisp without parentheses."</p>


<p><img src="3dprogram.png"></p>


<p>There are hundreds of very active programming languages, and they all have different syntax as well as different semantics.</p>

<p>I think there will always be a need for new semantic ideas. The world's knowledge domains are enormously complex (read: billions/trillions of concepts, if not more), machines are complex (billions of pieces), and both will always continue to get more complex.</p>

<p>But I wonder if we always need a new syntax for each new general purpose programming language. I wonder if we could unlock potentially very different editing environments and experiences with a simple geometric syntax, and if by making the syntax simpler folks could build better semantic tooling.</p>

<p>Maybe there's nothing useful here. Perhaps it is best to have syntax characters and a unique syntax for each general purpose programming language. Tree Notation might be a bad idea or only useful for very small domains. But I think it's a long-shot idea worth exploring.</p>

<p>Thousands of language designers focus on the semantics and choose the syntax to best fit those semantics (or a syntax that doesn't deviate too much from a mainstream language). I've taken the opposite approach--on purpose--with the hopes of finding something overlooked but important. I've stuck to a simple syntax and tried to implement all semantic ideas without adding syntax.</p>

<p>Initially I just looked at Tree Notation as an alternative to declarative format languages like JSON and XML, but then in a minor "Eureka!" moment, realized it might work well as a syntax for general purpose Turing complete languages across all paradigms like functional, object-oriented, logic, dataflow, et cetera.</p>

<p>Someday I hope to have data definitively showing that Tree Notation is useful, or alternatively, to explain why it is suboptimal and why we need more complex syntax.</p>

<p>I always wanted to try my hand at writing an academic paper. So I put the announcement in a 2-page paper on GitHub and arxiv. The paper is titled <a href="https://github.com/treenotation/research/blob/master/papers/paper/treenotation.pdf">Tree Notation: an antifragile program notation</a>. I've since been informed that I should stick to writing blog posts and code and not academic papers, which is probably good advice :).</p>

<p>Two updates on 12/30/2017. After I wrote this I was informed that one other person from the Scheme world created a <a href="https://srfi.schemers.org/srfi-49/srfi-49.html">very similar notation</a> years ago. Very little was written in it, which I guess is evidence that the notation itself isn't that useful, or perhaps that there is still something missing before it catches on. The second note is I updated the wording of this post as the original was a bit rushed.</p>

<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//show-hn-programming-is-now-two-dimensional.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="big-data-notation"><a href="#big-data-notation">Big Data Notation</a></h1>
<div class="scrollArticleDate">September 24, 2013 — </div>

<h3>A Suggestion for a Simple Notation</h3>

<p>What if instead of talking about Big Data, we talked about 12 Data, 13 Data, 14 Data, 15 Data, et cetera? The # refers to the number of zeroes we are dealing with.</p>

<p>You can then easily differentiate problems. Some companies are dealing with 12 Data, some companies are dealing with 15 Data. No company is yet dealing with 19 Data. Big Data starts at 12 Data, and maybe over time you could say Big Data starts at 13 Data, et cetera.</p>

<p>What do you think?</p>

<p>This occurred to me recently as I just started following <a href="http://www.quora.com/Big-Data">Big Data on Quora</a> and was surprised to see the term used so loosely, when data is something so easily measurable. For example, a <a href="http://www.mckinsey.com/insights/business_technology/big_data_the_next_frontier_for_innovation">2011 Big Data report from McKinsey</a> defined</p>
<p>big data as ranging "from a few dozen terabytes to multiple petabytes (thousands of terabytes)." <a href="http://en.wikipedia.org/wiki/Big_data">Wikipedia defines Big Data</a> as "a collection of data sets so large and complex that it becomes</p>
<p>difficult to process using on-hand database management tools or traditional data processing applications."</p>

<p>I think these terms make Big Data seem mysterious and confusing, when in fact it could be completely straightforward.</p>

<p>Published September 24th 2013, 9:06:15am</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//big-data-notation.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="nudgepad-an-ide-in-your-browser"><a href="#nudgepad-an-ide-in-your-browser">NudgePad: An IDE in Your Browser</a></h1>
<div class="scrollArticleDate">September 23, 2013 — </div>

<p>Making websites is slow and frustrating.</p>

<p>I met a young entrepreneur who wanted to create a website for his bed  and breakfast. He had spent dozens of hours with different tools and was no  closer to having what he wanted.</p>

<p>I met a teacher who wanted his students to turn in web pages for  homework instead of paper pages. No existing tool allows his students to  easily create pages without restricting their creativity.</p>

<p>I met an artist who wanted a website with a slideshow for her portfolio.</p>

<p>A restaurant owner who wanted a website that could take online orders.</p>

<p>An author who wanted a website with a blog.</p>

<p>A saleswoman who wanted to build a members-only site for great deals she  gathered.</p>

<p>A candidate who wanted a website that could coordinate his volunteers.</p>

<p>A nonprofit founder who wanted a website that told the story of  impoverished children in his country and accepted donations.</p>

<p>These are just a handful of real people with real ideas who are  frustrated by the current tools.</p>

<p><h3>The problem</h3></p>

<p><p class="lead">The fact is, people want to do millions of different things  with their websites, but the only two options are to use a tool that limits  your creative potential or to program your site from scratch. Neither option  is ideal.</p></p>

<p><h3>The solution</h3></p>
<p>Which is why we're building a third option. We are building an open source,  general purpose IDE for building websites.</p>

<p>Here's a short video demonstrating how it works:</p>


<p><iframe width="100%" height="315" src="https://www.youtube.com/embed/yh_EdtGpBak"  frameborder="0" allowfullscreen></iframe></p>

<p>NudgePad is in early beta, but is powering a number of live websites  like these:</p>


<p><img src="samples.gif"></p>

<p>Although we have a lot more to do to get to a stable version 2.0, we  thought the time was right to start opening up NudgePad to more people and  recruiting more help for the project. We also want to get feedback on the  core ideas in</p>
<p>NudgePad.</p>

<p>To get involved, give NudgePad a try or <a href="http://github.com/nudgepad">check out the source code on GitHub.</a></p>

<p>We truly believe this new way to build websites--an IDE in your browser-- is a faster way to build websites and the way it will be done in the future.  By this time next year, using NudgePad, it could be 100x faster and</p>
<p>easier to build websites than it is today.</p>


<p><p>Published September 23rd 2013, 9:46:59 am</p></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//nudgepad-an-ide-in-your-browser.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="software-should-save-people-time"><a href="#software-should-save-people-time">Software Should Save People Time</a></h1>
<div class="scrollArticleDate">April 2, 2013 — </div>

<p>For me, the primary motivation for creating software is to save myself and other people time.</p>

<p>I want to spend less time doing monotonous tasks. Less time doing bureaucratic things. Less time dealing with unnecessary complexity. Less time doing chores.</p>

<p>I want to spend more time engaged with life.</p>

<p>Saving people time is perhaps the only universal good. Everyone wants to have more options with their time. Everyone benefits when a person has more time. They can enjoy that extra time and/or invest some of it to make the world better for everyone else.</p>

<p>Nature loves to promote inequality, but a fascinating feature of time is that it is so equally distributed. Nature took the same amount of time to evolve all of us alive today. All of our evolutionary paths are equally long. We also have equal amounts of time to enjoy life, despite the fact that other things may be very unequally distributed.</p>

<p>The very first program I made was meant to save me and my family time. Back in 1996, to start our computer, connect to the Internet and launch Netscape took about 20 minutes, and you had to do each step sequentially. My first BAT script automated that to allow you to turn the computer on and go play outside for 20 minutes while it connected to the web. Many years later, my ultimate motivation to save people time has remained constant.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//software-should-save-people-time.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="time"><a href="#time">Time</a></h1>
<div class="scrollArticleDate">April 1, 2013 — </div>

<div class="scrollArticleCode">
<code> Two people in the same forest,</code>
<code> have the same amount of water and food,</code>
<code> Are near each other, but may be out of sight,</code>
<code> The paths behind each are equally long.</code>
<code> The paths ahead, may vary.</code>
<code> One's path is easy and clear.</code>
<code> The other's is overgrown and treacherous.</code>
<code> Their paths through the forest,</code>
<code> in the past, in the present, and ahead</code>
<code> are equal.</code>
<code> Their journeys can be very different.</code>
</div>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//time.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="why-10000-hours"><a href="#why-10000-hours">Why 10,000 hours?</a></h1>
<div class="scrollArticleDate">March 30, 2013 — </div>

<p>Why does it take 10,000 hours to become a master of something, and not 1,000 hours or 100,000 hours?</p>

<p>The answer is simple. Once you've spent 10,000 hours practicing something, no one can crush you like a bug.</p>

<p>Let me explain. First, the most important thing to keep in mind is that nature loves inequality. For example, humans and bugs are not even close to equal in size. Humans are 1,000x bigger than bugs. It is very easy for a human to squash a bug.</p>

<p>Now, when you are starting to learn something and have spent say, 100 hours practicing that thing, you, my friend, are the bug. There are many people out there who have been practicing that thing for 10,000 hours, and can easily crush you like a bug, if they are mean spirited like that.</p>

<p>Once you've got 1,000 hours of practice under your belt, it becomes very hard for someone to crush you.</p>

<p>You reach 10,000 hours of practice, and you are now at a level where no one can possibly crush you like a bug. It is near impossible for a human to practice something for 100,000 hours. That would be 40 hours of practice per week for fifty years! Life is too chaotic, and our bodies are too fragile, to hit that level of practice. Thus, when you hit 10,000 hours, you're safe. You no longer have to wonder if there's someone out there who knows 10x more than you. You are now a master.</p>

<p><i>Do you hear them talking of genius, Degna? There is no such thing. Genius, if you like to call it that, is the gift of work continously applied. That's all it is, as I have proved for myself.</p>
<p>- Guglielmo Marconi</i></p>

<p><img src="bug.png" width="100%"></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//why-10000-hours.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="money-is-meant-to-circulate"><a href="#money-is-meant-to-circulate">Money is Meant to Circulate</a></h1>
<div class="scrollArticleDate">March 30, 2013 — </div>

<p><i></p>
<p>"The crux of the matter, is that people don't understand the true nature of money. It is meant to circulate, not be wrapped up in a stocking"</p>
<p>- Guglielmo Marconi</p>
<p></i></p>

<p>I love Marconi's simple and clear view of money. Money came in and he put it to good use. Quickly. He poured money into the development of new wireless technology which had an unequal impact on the world.</p>

<p>This quote, by the way, is from "My Father, Marconi", a biography of the famous inventor and entrepreneur written by his daughter, Degna. Marconi's story is absolutely fascinating. If you like technology and entrepreneurship, I highly recommend the book.</p>

<p>P.S. This quote also applies well to most man made things. Cars,  houses, bikes, et cetera, are more valuable circulating than idling. It seemed briefly we were on a trajectory toward overabundance, but the sharing economy is bringing circulation back.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//money-is-meant-to-circulate.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="minor-epiphanies"><a href="#minor-epiphanies">Minor Epiphanies</a></h1>
<div class="scrollArticleDate">March 16, 2013 — </div>

<p>A kid says <i>Mommy</i> or <i>Daddy</i> or <i>Jack</i> or <i>Jill</i> hundreds of times before grasping the concept of a <i>name</i>.</p>

<p>Likewise, a programmer types <i>name = Breck</i> or <i>age=15</i> hundreds of times before grasping the concept of a <i>variable</i>.</p>

<p>What do you call it when someone finally sees the <i>concept</i>?</p>

<p>John Calcote, a programmer with decades of experience, calls it a <b>minor epiphany</b>.</p>

<p>Minor epiphanies. Anyone who's programmed for a while can appreciate that term.</p>

<p>When you start programming you do pure trial and error. <i>What will happen when I type this or click that?</i> You rely on memorization of action and reaction. Nothing makes sense. Every single term--variable, object, register, boolean, int, string, array, and so on--is completely and utterly foreign.</p>

<p>But you start to encounter these moments. These minor epiphanies, where suddenly you see the connection between a class of things. Suddenly something makes sense. Suddenly one term is not so foreign anymore. You have a new tool at your disposable. You have removed another obstacle that used to trip you.</p>

<p>In programming the well of minor epiphanies never runs dry. Even after you've learned thousands of things the epiphanies keep flowing at the same rate. Maybe the epiphanies are no longer about <i>what</i> the concept is, or <i>how</i> you can use it, but now are more about <i>where</i> did this concept come from, <i>when</i> was it created, <i>who</i> created it, and most fascinating of all, <i>why did they create it</i>?</p>

<p>Minor epiphanies give you a rush, save you time, help you make better products, and help you earn more.</p>

<p>As someone who loves to learn, my favorite thing about them is the rush you get from having something suddenly click. They make this programming thing really, really fun. Day in and day out.</p>

<p>*Stumbled upon the term in John Calcote's book "Autotools".</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//minor-epiphanies.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-booster-design-pattern"><a href="#the-booster-design-pattern">The Booster Design Pattern</a></h1>
<div class="scrollArticleDate">March 8, 2013 — </div>

<p>If your software project is going to have a long life, it may benefit from Boosters. A Booster is something you design with two constraints: 1) it must help in the current environment 2) it must be easy to jettison in the next environment.</p>

<p><img src="booster.jpg"></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-booster-design-pattern.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="startups-and-planes"><a href="#startups-and-planes">Startups and Planes</a></h1>
<div class="scrollArticleDate">February 24, 2013 — </div>

<p>It is a popular misconception that most startups need to fail. We expect 0% of planes to crash. Yet we switch subjects from planes to startups and then suddenly a 100% success rate is out of the question.</p>

<p>This is silly. Maybe as the decision makers switch from gambling financeers to engineers we will see the success rate of starting a company shoot closer to 100%.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//startups-and-planes.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="save-your-money-for-great-values"><a href="#save-your-money-for-great-values">Save Your Money for Great Values</a></h1>
<div class="scrollArticleDate">February 16, 2013 — </div>

<p>Some purchasing decisions are drastically better than others. You might spend $20 on a ticket to a conference where you meet your next employer and earn 1,000x "return" on your purchase. Or you might spend $20 on a fancy meal and have a nice night out.</p>

<p>Purchasing decisions have little direct downside. You most often get your money's worth.</p>

<p>The problem is the opportunity cost of purchases. That opportunity cost can cost you a fortune.</p>

<p>Since some purchases can change your life, delivering 100x or greater return on your investment, spending your money on things that only give you a 10% return can be a massive mistake, because you'll miss out on those great deals.</p>

<p>It's best to say "no" to a lot of deals. Say "yes" to the types of deals that you know deliver massive return.</p>

<p>[0] For me, this is: books, meeting people, coffee (which I use as "fuel" for creating code which generates a strong return).</p>

<p>[1] I'm not advocating being a penny pincher. I'm advocating being aware of the orders of magnitude difference in return from purchases.</p>

<p>[2] I wonder if someday we'll have credit cards that help you be aware of the order of magnitude variance in expected value of purchases. It seems like one great benefit, would be to charge a higher interest rate on purchases that have low expected value, and a very low interest rate on purchases with high expected value (like books).</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//save-your-money-for-great-values.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="infinite-futures"><a href="#infinite-futures">Infinite Futures</a></h1>
<div class="scrollArticleDate">February 12, 2013 — </div>

<p>You shouldn't plan for <i>the</i> future. You should plan for <b>one of many</b> futures.</p>

<p>The world goes down many paths. We only get to observe one, but they all happen.</p>

<p>In the movie "Back to the Future II", the main character Marty, after traveling decades into the future, buys a sports alamanac so he can go back in time and make easy money betting on games. Marty's mistake was thought he had the guide to <i>the</i> future. He thought there was only one version of the future. In fact, there are many versions of the future. He only had the guide to <i>one version</i>.</p>

<p>Marty was like the kid who stole the answer key to an SAT but still failed. There are many versions of the test.</p>

<p>There are infinite futures. Prepare for them all!</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//infinite-futures.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="prove-it"><a href="#prove-it">Prove It</a></h1>
<div class="scrollArticleDate">December 29, 2012 — </div>

<p>I love that phrase.</p>

<p>I want to learn how to program. Prove it.</p>

<p>I value honesty. Prove it.</p>

<p>I want to start my own company. Prove it.</p>

<p>It works with "we" too.</p>

<p>We're the best team in the league. Prove it.</p>

<p>We love open source. Prove it.</p>

<p>We're going to improve the transportation industry. Prove it.</p>

<p>Words don't prove anything about you. How you spend your time proves everything.</p>

<p>The only way to accurately describe yourself or your group is to look at how you've spent your time in the past. Anytime someone says something about what they will do or be like in the future, your response should be simple: prove it.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//prove-it.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-great-bank-robbery"><a href="#the-great-bank-robbery">The Great Bank Robbery</a></h1>
<div class="scrollArticleDate">December 23, 2012 — </div>


<p>If you are poor, your money could be safer under the mattress than in the bank:</p>

<p><img src="the_great_bank_robbery.png"></p>

<p>The Great Bank Robbery dwarfs all normal burglaries by almost 10x. In the Great Bank Robbery, the banks are slowly, silently, automatically taking from the poor.</p>

<p>One simple law could change this:</p>

<p><i>What if it were illegal for banks to automatically deduct money from someone's account?</i></p>

<p>If a bank wants to charge someone a fee, that's fine, just require they send that someone a bill first.</p>

<p>What would happen to the statistic above, if instead of silently and automatically taking money from people's accounts, banks had to work for it?</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-great-bank-robbery.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="responsibility"><a href="#responsibility">Responsibility</a></h1>
<div class="scrollArticleDate">December 22, 2012 — </div>

<p>Entrepreneurship is taking responsibility for a problem you did not create.</p>

<p>It was not Google's fault that the web was a massive set of unorganized pages that were hard to search, but they claimed responsibility for the problem and solved it with their engine.</p>

<p>It was not Dropbox's fault that data loss was common and sharing files was a pain, but they claimed </p>
<p>responsibility for the problem and solved it with their software.</p>

<p>It is not Tesla's fault that hundreds of millions of cars are burning gasoline and polluting our atmosphere, but they have claimed responsibility for the problem and are attempting to solve it with their electric cars.</p>

<p>In a free market, like in America or online, you can attempt to take responsibility for any problem you want. That's pretty neat. You can decide to take responsibility for making sure your neighborhood has easy access to great Mexican food. Or you can decide to take responsibility for making sure the whole Internet has easy access to reliable version control. If you do a good job, you will be rewarded based on how big the problem is and how well you solve it.</p>

<p>How big an entrepreneur's company gets is strongly correlated with how much responsibility the entrepreneur wants. The entrepreneur gets to constantly make choices about whether they want their company to take on more and more responsibility. Companies only get huge because their founders say "yes" to more and more responsibility. Oftentimes they can say "yes" to less responsibility, and sell their company or fold it.</p>

<p>Walmart started out as a discount store in the Midwest, but Sam Walton (and his successors) constantly said "yes" to more and more responsibility and Walmart has since grown to take on responibility for discounting across the world.</p>

<p>Google started out with just search, but look at all the other things they've decided to take responsibility for: email, mobile operating systems, web browsers, social networking, document creation, calendars, and so on. Their founders have said "yes" to more and more responsibility.</p>

<p>Smart entrepreneurship is all about choosing problems you can and want to own. You need to say "no" to most problems. If you say "yes" to everything, you'll stretch yourself too thin. You need to increase your responsibility in a realistic way. You need to focus hard on the problems you can solve with your current resources, and leave the other problems for another company or another time.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//responsibility.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="deliver"><a href="#deliver">Deliver</a></h1>
<div class="scrollArticleDate">December 19, 2012 — </div>

<div class="scrollArticleCode">
<code> There's a man in the world who is never turned down, wherever he chances to stray;</code>
<code> he gets the glad hand in the populous town, or out where the farmers make hay;</code>
<code> he's greeted with pleasure on deserts of sand, and deep in the aisles of the woods;</code>
<code> wherever he goes there's the welcoming hand--he's The Man Who Delivers the Goods.</code>
<code> </code>
<code> The failures of life sit around and complain; the gods haven't treated them white;</code>
<code> they've lost their umbrellas whenever there's rain, and they haven't their lanterns at night;</code>
<code> men tire of the failures who fill with their sighs the air of their own neighborhoods;</code>
<code> there's one who is greeted with love-lighted eyes--he's The Man Who Delivers the Goods.</code>
<code> </code>
<code> One fellow is lazy, and watches the clock, and waits for the whistle to blow;</code>
<code> and one has a hammer, with which he will knock, and one tells a story of woe;</code>
<code> and one, if requested to travel a mile, will measure the perches and roods;</code>
<code> but one does his stunt with a whistle or smile--he's The Man Who Delivers the Goods.</code>
<code> </code>
<code> One man is afraid that he'll labor too hard--the world isn't yearning for such;</code>
<code> and one man is always alert, on his guard, lest he put in a minute too much;</code>
<code> and one has a grouch or a temper that's bad, and one is a creature of moods;</code>
<code> so it's hey for the joyous and rollicking lad--for the One Who Delivers the Goods!</code>
</div>

<p><a href="http://books.google.com/books/about/Walt_Mason_his_book.html?id=kPo_AAAAYAAJ">Walt Mason, his book</a></p>


<p>For a long time I've believed that underpromising and overdelivering is a trait of successful businesses and people. So the past year I've been trying to overdeliver.</p>

<p>But lately I realized that you cannot try to overdeliver. All an individual can do is deliver, deliver, deliver. Delivering is a habit that you get into. Delivering is something you can do.</p>

<p>Overdelivering is only something a team can do. The only way to overdeliver, is for a team of people to constantly deliver things to each other, and then the group constantly delivers something to other people that that person could never imagine doing alone.</p>

<p>But in your role on a team, the key isn't to worry about overdelivering, just get in the habit of delivering.</p>

<p>Be the Man who delivers the goods!</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//deliver.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="black-swans-and-technology"><a href="#black-swans-and-technology">Black Swans and Technology</a></h1>
<div class="scrollArticleDate">December 19, 2012 — </div>


<p>For the past year I've been raving about Node.js, so I cracked a huge smile when I saw this question on Quora:</p>

<p>For months I had been repeating the same answer to friends: "Node.js hands down. If you want to build great web apps, you don't have a choice, you have to master Javascript. Why then master two languages when you don't need to?"</p>

<p>Javascript+Node.js is to Python and Ruby what the iPhone is to MP3 players--it has made them redundant. You don't need them anymore.</p>

<p>So I started writing this out and expanding upon it. As I'm doing this, a little voice in my head was telling me something wasn't right. And then I realized: despite reading Taleb's books every year, I was making the exact mistake he warns about. I was predicting the future without remembering that the future is dominated not by the predictable, but by the unpredictable, the Black Swans.</p>

<p>And sure enough, as soon as I started to imagine some Black Swans, I grew less confident in my prediction. I realized all it would take would be for one or two browser vendors to start supporting Python or Ruby or language X in the browser to potentially disrupt Node.js' major advantage. I don't think that's likely, but it's the type of low probability event that could have a huge impact.</p>

<p>When I started to think about it, I realized it was quite easy to imagine Black Swans. Imagine visiting hackernews in 2013 and seeing any one of these headlines:</p>

<p><b>Microsoft Open Sources Windows.</b></p>

<p><b>Researchers Crack SSL. Render it useless.</b></p>

<p><b>Google Perfects Voice Recognition.</b></p>

<p><b>Facebook Covers the World in Free Wifi</b></p>

<p><b>Amazon Launches Distributed Data Centers in your Home</b></p>

<p>It took only a few minutes to imagine a few of these things. Clearly there are hundreds of thousands of low probability events that could come from established companies or startups that could shift the whole industry.</p>

<p>The future is impossible to predict accurately.</p>


<p><i>All that being said, Node.js kicks ass <b>today</b>(the Javascript thing, the community, the speed, the packages, the fact I don't need a separate web server anymore...it is awesome), and I would not be surprised if Javascript becomes 10-100x bigger in the years ahead, while I can't say the same about other languages. And if Javascript doesn't become that big, worst case is it's still a very powerful language and you'll benefit a lot from focusing on it.</i></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//black-swans-and-technology.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="probability-makes-planes-fly"><a href="#probability-makes-planes-fly">Probability Makes Planes Fly</a></h1>
<div class="scrollArticleDate">December 18, 2012 — </div>

<p>My whole life I've been trying to understand how the world works. How do planes fly? How do computers compute? How does the economy coordinate?</p>

<p>Over time I realized that these questions are all different ways of asking the same thing: how do complex systems work?</p>

<p>The past few years I've had the opportunity to spend thousands of hours practicing programming and studying computers. I now understand, in depth, one complex system. I feel I can finally answer the general question about complex systems with a very simple answer.</p>

<p><b>Compounded Probability Makes Complex Systems Work</b></p>

<p>There is no certainty in life or in systems, but there is probability, and probability compounds.</p>

<p>We can combine the high probability that wheels roll, with the high probability that wood supports loads, to build a wooden chariot that has a high probability of carrying things from point A to point B, which has a high probability of giving us more time to innovate, and so on and so forth...</p>

<p>Everything is built off of probability. You are reading this because of countless compounded probabilities like:</p>

<ul>
 <li>There is a high probability that your Internet connection works</li>
 <li>There is a high probability that my web server is responding to connections</li>
 <li>There is a high probability that my web server's disk works</li>
 <li>There is a high probability that my web software works and will handle this post</li>
 <li>There is a high probability that my Internet connection works</li>
 <li>There is a high probability that my text editor won't fail as I write this</li>
 <li>There is a high probability that my laptop works</li>
 <li>There is a high probability that the CPU in my laptop consistently adds numbers in the registers correctly</li>
</ul>

<p>Complex systems consist of many, many simple components with understood probabilities stitched together.</p>

<p>How does a plane fly? The most concise and accurate answer isn't about aerodynamics or lift, it's about probabilities. A plane is simply a huge system of compounded probabilities.</p>

<p>How does a bridge stay up? The answer is not about physics, it's about compounded probabilities.</p>

<p>How do computers work? Compounded probability.</p>

<p>How do cars work? Compounded probability.</p>

<p>The economy? Compounded probability.</p>

<p>Medicine? Compounded probability.</p>

<p>It's probability all the way down.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//probability-makes-planes-fly.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="cant-lose.-could-win-big."><a href="#cant-lose.-could-win-big.">Can't Lose. Could Win Big.</a></h1>
<div class="scrollArticleDate">December 18, 2012 — </div>

<p>One of Nassim Taleb's big recommendations for how to live in an uncertain world is to follow a barbell strategy: be extremely conservative about most decisions, but make some decisions that open you up to uncapped upside.</p>

<p>In other words, put 90% of your time into safe, conservative things but take some risks with the other 10%.</p>

<p>I personally try to follow this advice, particularly with our startup. I think it is good advice. I think it would be swell if our company became a big, profitable, innovation machine someday. But that's not what keeps me up at night.</p>

<p>I'm more concerned about creating the best worst case scenario. I spend most of my time trying to improve the worst case outcomes. Specifically, here's how I think you do this:</p>

<p><b>Tackle a big problem</b>. Worst case scenario is you don't completely solve it, but you learn a lot in that domain and get aquired/acquihired by a bigger company in the space. That's a great outcome.</p>

<p><b>Build stuff you want</b>. Worst case scenario is no one uses your product but you. If you aren't a fan of what you build, then you have nothing. If you love your product, that's a great outcome.</p>

<p><b>Focus on your customers</b>. Make sure your customers are happy and getting what they want. Worst case scenario, you made a couple people of people happy. That's a great outcome.</p>

<p><b>Practice your skills</b>. Worst case scenario is the company doesn't work out, but you are now much better at what you do. That's a great outcome.</p>

<p><b>Deliver</b>. Worst case scenario is you deliver something that isn't quite perfect but is good and helps people. That's a great outcome.</p>

<p><b>Avoid debt</b>. If you take on debt or raise money, worst case scenario is you run out of time and you lose control of your destiny. If you keep money coming in, worst case scenario is things take a little longer or if you move on you are not in a hole. That's a great outcome.</p>

<p><b>Enjoy life</b>. Make sure you take time to enjoy life. Worst case scenario is you spend a few years with no great outcome at work but you have many great memories from life. That's a great outcome.</p>

<p>Then, if you want to make yourself open to positive black swans, you can put 10% of your efforts into things that make you more open to those like: recruiting world class talent, pitching and raising money, tackling bigger markets. But make sure you focus on the conservative things. Risk, in moderation, is a good thing. Risk, in significant amounts, is for the foolish.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//cant-lose-could-win-big.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="simple-is..."><a href="#simple-is...">Simple is...</a></h1>
<div class="scrollArticleDate">December 16, 2012 — </div>

<p><b>Concise but not cryptic</b>. e = mc2 is precise and not too cryptic. Shell commands, such as chmod -R 755 some_dir are concise but very cryptic.</p>

<p><b>Understandable but not misleading</b>. "Computing all boils down to ones and zeros" is understandable and not misleading. "Milk: it does a body good", is understandable but misleading.</p>

<p><b>Minimal but not incomplete</b>. A knife, spoon and fork is minimal. Just a knife is incomplete.</p>

<p><b>Broad but selective</b>. A knife, spoon, and fork is broad and selective. A knife, spoon, fork and turkey baster is just as broad but not selective.</p>

<p><b>Flat but not too flat</b>. 1,000 soliders is flat but too flat. At least a few officers would be better.</p>

<p><b>Anthropocentric not presentcentric</b>. Shoes are relevant to people at any time. An iPhone 1 case is only useful for a few years.</p>

<p><b>Cohesive but flexible</b>. You want the set to match. But you want each item to be independently improveable.</p>

<p><b>Simple is balanced</b>. It is nuanced, not black and white.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//simple-is.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="narratives-misrepresent-complex-systems"><a href="#narratives-misrepresent-complex-systems">Narratives Misrepresent Complex Systems</a></h1>
<div class="scrollArticleDate">December 16, 2012 — </div>

<p><script src="jquery.min.js"></script></p>
<p>When I was a kid I loved reading the Family Circus. My favorite strips were the "dotted lines" ones, which showed Billy's movements over time:</p>

<p><img src="family_circus/0.png" style="width: 100%;"></p>

<p>These strips gave a clear narrative of Billy's day. In the strip above, Billy, a fun loving kid, was given a task by his mother to put some letters in the mailbox before the mailman arrives. Billy took the letters, ran into the kitchen, then dashed into the living room, jumped on the couch, sprinted to the dining room, crawled under the dining room table, skipped into the TV room, jumped into the crib, twirled into the foyer, stumbled outside, swung around the light post, then ran to the mailbox.</p>

<p>We know the end result: Billy failed to get to the mailbox in time.</p>

<p>With this picture in mind, let's do a thought experiment.</p>

<p>Let's imagine that right now, once again, Billy and his mom are standing in the laundry room and she's about to give him the mail. What are the odds that Billy gets to the mailbox in time?</p>

<p>Pick a range, and then <a onclick="$('#answer').show()">click here to see the answer.</a></p>


<p><div style="display: none;" id="answer">If you answered: "somewhere between 0 and 100%" you were correct! If your answer was any more precise than that, you were wrong. Given only the single narrative above, you would have no basis for being more confident than a random guess between 0 and 1.</p>

<p>But, if you're like me, it would be hard to resist making a more precise guess based upon the story we saw. Humans, at least many of us, are quick to build narratives around events and then rely on those narratives to make predictions.</p>

<p>We know what happened before, so we try to predict the future off of that. This wouldn't be a problem if we truly knew what happened before. The problem is: we don't actually know what happened before. We only know what we witnessed before. <i>A lot happened that we didn't witness</i>.</p>

<p>The problem is we only get to witness one universe, one path, but nature in fact, is constantly generating many, many paths. What we witnessed is not the whole story. What we witnessed is just a slice of the story.</p>

<p>Words might not be the best way to explain this. Let's draw it out.</p>

<p>I'm going to redraw the strip above to show you more of the story. More of what actually happened. Because I suck at drawing, my first step will be to simplify the strip a bit. Here is my simplified Family Circus house:</p>

<p><img src="family_circus/1.png" style="width: 100%;"></p>

<p>And here is the path in the actual comic redrawn in my version:</p>

<p><img src="family_circus/2.png" style="width: 100%;"></p>

<p>Now, my assumption, based on the hunch that the multiverse theory of the world is correct, is that the universe is constantly branching, and so, somewhere out there, Billy took a direct path to the mailbox:</p>

<p><img src="family_circus/3.png" style="width: 100%;"></p>

<p>There's proably also a universe where he took a direct route but also took a minute to watch some TV:</p>

<p><img src="family_circus/4.png" style="width: 100%;"></p>

<p>And there's a universe where he took the same winding route as in the original, except without the trip to the dining room:</p>

<p><img src="family_circus/5.png" style="width: 100%;"></p>

<p>A universe where he took an even longer route than the original:</p>

<p><img src="family_circus/6.png" style="width: 100%;"></p>

<p>And maybe a universe where he snuck out the back door and took a real quick route:</p>

<p><img src="family_circus/7.png" style="width: 100%;"></p>

<p>Finally, perhaps there was a universe where he refused his mother's order and didn't go to the mailbox at all:</p>

<p><img src="family_circus/8.png" style="width: 100%;"></p>

<p>Now, although this is still just a sliver of what actually happened, it is a lot more realistic picture of what happened than just having the original, which does not tell us what happened, but just what we witnessed.</p>

<p>It is easy to build a narrative off of what we witnessed. But that is the problem.</p>

<p>Predicting what is going to happen in the future requires us understanding what happened in the past.</p>

<p>We can combine all of the paths above to get a more realistic look at what happened in the past:</p>

<p><img src="family_circus/9.png" style="width: 100%;"></p>

<p>You cannot build much of a narrative out of that. When you look honestly at nature, you cannot create a narrative. As Taleb would say, nature is what it is, it does not need a narrative.</p>

<p>The bottom line is, beware of narratives. Don't make predictions based off narratives.</p>

<p>Experiments, where we get to witness thousands or millions of universes are good for instruction, for prediction. But narratives are for entertainment.</p>

<p>(Influenced a lot by Taleb's new book, Antifragile.)</p>

<p></div></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//narratives-misrepresent-complex-systems.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="introducing-note"><a href="#introducing-note">Introducing Note</a></h1>
<div class="scrollArticleDate">December 14, 2012 — </div>

<p>Note is a structured, human readable, concise language for encoding data.</p>

<h3>XML to JSON to Note</h3>

<p>In 1998, a large group of developers were working on technologies to make the web simpler, more collaborative, and more powerful. Their vision and hard work led to XML and SOAP.</p>

<p>XML was intended to be a markup language that was <a href="http://en.wikipedia.org/wiki/XML">"both human-readable and machine-readable"</a>. As Dave Winer described it, <a href="http://scripting.com/davenet/1998/06/04/xmlParsers.html">"XML is structure, simplicity, discoverability and new power thru compatibility."</a></p>

<p>SOAP, which was built on top of XML, was intended to be a "Simple Object Access Protocol". Dave said <a href="http://scripting.com/davenet/1998/06/14/infoWorldOnSoap.html">"the technology is potentially far-reaching and precedent-setting."</a></p>

<p>These technologies allowed developers across the world to build websites that could work together with other websites in interesting ways. Nowadays, most web companies have APIs, but that wasn't always the case.</p>

<p>Although XML and SOAP were a big leap forward, in practice they are difficult to use. It's arguable whether they are truly "human-readable" or "simple".</p>

<p>Luckily, in 2001 Douglas Crockford specified a simpler, more concise language called <a href="http://www.json.org/">JSON</a>. Today JSON has become the de facto language for web services.</p>

<h3>Could JSON be improved?</h3>

<p>Early last year, one idea that struck me was that subtle improvements to underlying technologies can have exponential impact. Fix a bug in subversion and save someone hours of effort, but <a href="http://en.wikipedia.org/wiki/Git_(software)">replace subversion</a> and save someone weeks.</p>

<p>The switch from XML to JSON had made my life so much easier, I wondered if you could extract an even simpler alternative to JSON. JSON, while simple, still takes a while to learn, particularly if you are new to coding. Although more concise than XML, JSON has at present six types and eight syntax characters, all of which can easily derail developers of all skill levels. Because whitespace is insignificant in JSON, it quickly becomes messy. These are all relatively small details, but I think perhaps getting the details right in a new encoding could make a big difference in developers' lives.</p>

<h3>Introducing Note</h3>

<p>After almost two years of tinkering, and with a lot of inspiration from JSON, XML, HAML, Python, YAML, and other languages, we have a new simple encoding that I hope might make it easier for people to create and use web services.</p>

<p>We dubbed the encoding Note, and have put an early version with Javascript support up on <a href="https://github.com/breck7/note">Github</a>. We've also put out a quick demonstration site that allows you to interact with some popular APIs using Note.</p>

<p>Note is a text based encoding that uses whitespace to give your data structure. Note is simple: there are only two syntax characters (newline and space). It is concise--not a single keystroke is wasted (we use a single space for indentation--why use 2 when one is sufficient?). Note is neat: the meaningful whitespace forces adherance to a clean style. These features make Note very easy to read and to write.</p>

<p>Despite all this minimalism, Note is very powerful. Each note is a hash consisting of name/value pairs. Note is also recursive, so each note can be a tree containing other notes.</p>

<p>Note has only two types: strings and notes. Every entity in note is either a string or another Note. But Note is infinitely extendable. You can create domain specific languages on top of Note that support additional types as long as you respect the whitespace syntax of Note.</p>

<p>This is a very brief overview of the thinking behind Note and some of its features. I look forward to the months ahead as we start to implement Note on sites across the web and demonstrate some of the neat features and capabilities of the encoding.</p>

<p>Please feel free to email me with any questions or feedback you may have, as well as if you'd be interested in contributing.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//introducing-note.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="planets-and-pebbles"><a href="#planets-and-pebbles">Planets and Pebbles</a></h1>
<div class="scrollArticleDate">November 26, 2012 — </div>

<p>For todo lists, I created a system I call planets and pebbles.</p>

<p><div><img src="planets_and_pebbles.png" /></div></p>

<p>I label each task as a planet or a pebble. Planets are super important things. It could be helping a customer complete their project, meeting a new person, finishing an important new feature, closing a new sale, or helping a friend in need. I may have 20 pebbles that I fail to do, but completing one planet makes up for all that and more.</p>

<p>I let the pebbles build up, and I chip away at them in the off hours. But the bulk of my day I try to focus on the planets--the small number of things that can have exponential impact. I don't sweat the small stuff.</p>

<p>I highly recommend this system. We live in a power law world, and it's important to practice the skill of predicting what things will prove hugely important, and what things will turn out to be pebbles.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//planets-and-pebbles.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="publishing-more"><a href="#publishing-more">Publishing More</a></h1>
<div class="scrollArticleDate">November 25, 2012 — </div>

<p>I published 55 essays here the first year. The second and third years combined, that number nosedived to 5.</p>

<p>What caused me to stop publishing?</p>

<p>It hasn't been a lack of ideas. All my essays start with a note to self. I have just as many notes to self nowadays as I did back then.</p>

<p>It hasn't been a lack of time. I have been working more but blogging doesn't take much time.</p>

<p>It's partly to do with standards. I've been trying to make higher quality things. I used to just write for an hour or two and hit publish. Now I'm more picky.</p>

<p>I've also become somewhat disappointed with the essay form. I am very interested in understanding systems, and I feel words alone don't explain systems well. So I've been practicing my visual and design skills. But I'm basically a beginner and output is slow.</p>

<p>The bottom line is I want to publish more. It forces me to think hard about my opinions, and it opens me up to advice from other people. I think this blog has helped me be less wrong about a lot of things. So here's to another fifty posts.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//publishing-more.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="setplicity"><a href="#setplicity">Setplicity</a></h1>
<div class="scrollArticleDate">November 20, 2012 — </div>

<p>"Is simplicity ever bad?" If you had asked me this a year ago, I probably would have called you a fucking moron for asking such a dumb question. "Never!", I would have shouted. Now, I think it's a fair question. Simplicity has it's limits. Simplicity is not enough, and if you pursue simplicity at all costs, that can be a bad thing. There's something more than simplicity that you need to be aware of. I'll get to that in a second, but first, I want to backtrack a bit and state clearly that I do strongly, strongly believe and strive for simplicity. Let me talk about why for a second.</p>

<h3>Why I love simplicity</h3>

<p>Simple products are pleasant to use. When I use a product, and it is easy to use, and it's quick to use, I love that. I fucking hate things that are not as simple as possible and waste people's time or mental energy as a result. For example, to file my taxes with the IRS, I cannot go to the IRS' website. It's much more complex than that. I hate that. It is painful. Complex things are painful to use. Simple things are pleasant to use. They make life better. This is, of course, well known to all good designers and engineers.</p>

<p>Simple things are also more democratic. When I can understand something, I feel smart. I feel empowered. When I cannot understand something, I feel stupid. I feel inferior. Complex things are hard to understand. The response shouldn't be to spend a long time learning the complex thing, it should be to figure out how to make the complex thing simpler. When you do that, you create a lot of value. If I can understand something, I can do something. When we make things simpler, we empower people. Often times I wonder if being a doctor would only take 2 years if Medicine abandoned Latin terms for a simpler vocabulary.</p>

<h3>Reaching the Limits of Simplicity</h3>

<p>This whole year, and well before that, I've been working with people trying to make the web simpler. The web is really complex. You need to know about HTML, CSS, Javascript, DNS, HTTP, DOM, Command Line, Linux, Web Servers, Databases, and so on. It's a fucking mess. It's fragmented to all hell as well. Everyone is using different languages, tools, and platforms. It can be a pain.</p>

<p>Anyway, we've been trying to make a simple product. And we've been trying to balance simplicity with features. And that's been difficult. Way more difficult than I would have predicted.</p>

<p>The thing is, simpler is not always better. A fork is simpler than a fork, knife, and spoon, but which would you rather have? The set is better. Great things are built by combining distinct, simple things together. If you took away the spoon, you'd make the set simpler, but not better. Which reminds me of that Einstein quote:</p>

<h3>"Make things as simple as possible, but not simpler."</h3>

<p>I had always been focused on the first part of that quote. Make things as simple as possible. Lately I've thought more about the second part. Sometimes by trying to make things too simple you make something a lot worse. Often, less is more, but less can definitely be less.</p>

<p>People rave about the simplicity of the iPhone. And it is simple, in a sense. But it is also very complex. It has a large screen, 2 cameras, a wifi antenna, a GPS, an accelerometer, a gyroscope, a cell antenna, a gpu, cpus, memory, a power unit, 2 volume buttons, a power button, a home button, a SIM card slot, a mode switch, and a whole lot more. Then the software inside is another massive layer of complexity. You could try to make the iPhone simpler by, for example, removing the volume buttons or the cameras, but that, while increasing the simplicity, would decrease the "setplicity". It would remove a very helpful part of the set which would make the whole product worse.</p>

<p>Think about what the world would be like if we only used half of the periodic table of elements--it would be less beautiful, less enjoyable, and more painful.</p>

<p>Simplicity is a great thing to strive for. But sometimes cutting things out to make something simpler can make it worse. Simplicity is not the only thing to maximize. Make sure to balance simplicity with setplicity. Don't worry if you haven't reduced things to a singularity. Happiness in life is found by balancing amongst a set of things, not by cutting everything out.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//setplicity.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="naming-things"><a href="#naming-things">Naming Things</a></h1>
<div class="scrollArticleDate">October 20, 2012 — </div>

<p>I love to name things.</p>

<p>I spend a lot of time naming ideas in my work. At work I write my code using a program called TextMate. TextMate is a great little program with a pleasant purple theme. I spend a lot of time using TextMate. For the past year I've been using TextMate to write a program that now consists of a few hundred files. There are thousands of words in this program. There are hundreds of objects and concepts and functions that each have a name. The names are super simple like "Pen" for an object that draws on the screen, and "delete" for a method that deletes something. Some of the things in our program are more important than others and those really important ones I've renamed dozens of times searching for the right fit.</p>

<p>There's a feature in TextMate that lets me find and replace a word across all 400+ files in the project. If I am unhappy with my word choice for a variable or concept, I'll think about it for weeks if not months. I'll use Thesaurus.com, I'll read about similar concepts, I'll run a subconscious search for the simplest, best word. When I find it, I'll hit Command+Shift+F in TextMate and excitedly and carefully execute a find and replace across the whole project. Those are some of my favorite programming days--when I find a better name for an important part of the program.</p>

<p>Naming a thing is like creating life from inorganic material in a lab. You observe some pattern, combine a bunch of letters to form a name, and then see what happens. Sometimes your name doesn't fit and sits lifeless. But sometimes the name is just right. You use it in conversation or in code and people instantly get it. It catches on. It leaves the lab. Your name takes a life of its own and spreads.</p>

<p>Words are very contagious. The better the word, the more contagious it can be. Like viruses, small differences in the quality of a word can have exponential differences on it's spread.  So I like to spend time searching for the right words.</p>

<p>Great names are short. Short names are less effort to communicate. The quality of a name drops exponentially with each syllable you add. Coke is better than Coca-Cola. Human is better than homo sapiens.</p>

<p>Great names are visual. A good test of whether a name is accurate is whether you can draw a picture of the name that makes sense. Net is better than cyberspace. If you drew a picture of the physical components of the Internet, it would look a lot like a fishing net. Net is a great name.</p>

<p>Great names are used for great ideas. You should match the quality of a name to the quality of the idea compared to the other ideas in the space. This is particularly applicable in the digital world. If you are working on an important idea that will be used by a lot of people in a broad area, use a short, high quality name. If you are working on a smaller idea in that same area, don't hog a better name than your idea deserves. Linux is filled with great programs with bad names and bad programs with great names. I've been very happy so far with my experience with NPM, where it seems programmers who are using the best names are making their programs live up to them.</p>

<p>I think the exercise of naming things can be very helpful in improving things. Designing things from first principles is a proven way to arrive at novel, sometimes better ideas. Attempting to rename something is a great way to rethink the thing from the ground up.</p>

<p>For example, lately I've been trying to come up with a way to explain the fundamentals of computing. A strategy I recently employed was to change the names we use for the 2 boolean states from True and False to Absent or Present. It seems like it gets closer to the truth of how computers work. I mean, it doesn't make sense to ask a bit whether it is True or False. The only question an electronic bit can answer is whether a charge is present or absent. When we compare variable A to variable B, the CPU sets a flag in the comparison bit and we are really asking that bit whether a charge is present.</p>

<p>What I like about the idea of using the names Present and Absent is that it makes the fundamentals of computing align with the fundamentals of the world. The most fundamental questions in the world about being--of existence. Do we exist? Why do we exist? Will we exist tomorrow? Likewise, the most fundamental questions in computing is not whether or not there are ones and zeroes, it's whether or not a charge exists. Does a charge exist? Why does that charge exist? Will that charge exist in the next iteration? Computing is not about manipulating ones and zeroes. It's about using the concept of being, of existence, to solve problems. Computing is about using the concept of the presence or absence of charge to do many wonderful things. </p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//naming-things.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="an-unpopular-phrase"><a href="#an-unpopular-phrase">An Unpopular Phrase</a></h1>
<div class="scrollArticleDate">February 21, 2012 — </div>

<p>One of the most unpopular phrases I've spoken, so unpopular that it has won me many negative karma points online and in person causes some people to turn and walk away, is the phrase "Intellectual Slavery Laws".</p>

<p>I think perhaps the best term for copyright and patent laws is "Intellectual Monopoly Laws". When called by that name, it is self-evident that there should be careful scrutiny of these kinds of laws.</p>

<p>However, so many people insist on using the false term "Intellectual Property Laws." Instead of wasting my breath trying to pull them away from that analogy, lately I've decided to go the other way and complete the analogy for them. So let me explain "Intellectual Slavery Laws".</p>

<p>As far as I can figure, you cannot have Property Rights and "Intellectual Property" rights. Having both is logically inconsistent. My computer is my property. However, by law there are billions of peaceful things I cannot do on my computer. Therefore, my computer is not my property.</p>

<p>Unless of course, the argument is that my computer is my property, but some copyright and patent holders have property rights over <em>me</em>, so their property rights allow them to restrict my freedom. I still get rights over my property. But other people get rights over me. Property Rights and Intellectual Slavery Laws can logically co-exist! Logical inconsistency solved!</p>

<p>We can have a logical debate about whether we should have an Intellectual Slavery System, Intellectual Slavery Laws, Intellectual Slavery Law Schools, Intellectual Slavery Lawyers, etc. But we cannot have a logical debate about Intellectual Property Laws. Because the term itself is not logical.</p>

<p>I know, having now said this term aloud to a number of people, that this is a not a popular thing to say. But I think someone needs to say it. Do we really think we are going to be an interplanetary species and solve the world's biggest challenges if we keep 99+% of the population in intellectual chains?</p>

<h3>Errata</h3>

<ul>
 <li>"They are stealing my IP." What would your "IP" be if you weren't "stealing" inventions like words, the alphabet, numbers, rules of physics, etc, that were developed and passed down over thousands of years?</li>
 <li>"But shouldn't creators be paid for their work?" Yes. Pay them upon delivery. No need for monopolies. Does a janitor, after cleaning a room, get to charge everyone who enters a royalty for 100 years?</li>
 <li>"Not a big deal—rights expire after a certain time." The fact that Copyrights and Patents expire on an arbitrary date is more proof that these should not be called property rights.</li>
 <li>"This is not an urgent problem." I think Intellectual Slavery Laws have deep, direct connections to major problems of our time including healthcare, education, and inequality problems.</li>
 <li>"This is anti-capitalist." This is pro-property rights.</li>
 <li>"What about trademarks?" Centralized naming registries like Trademarks are fine, as long as anyone can start a registry. Posing as someone else isn't an IP violation, it is fraud. Already consequences for that. </li>
 <li>"If you think the U.S. is bad, go visit China." I acknowledge that we have tremendous intellectual freedoms in the U.S., especially compared to other countries. I don't take freedom of speech and freedom of press for granted. However, I believe we are capping ourselves greatly by not legalizing full intellectual freedom.</li>
 <li>"This is offensive to people suffering from physical slavery or its lingering effects." The people who would benefit the most from abolishing Intellectual Slavery laws are the same people who have suffered the most from physical slavery systems.</li>
 <li>"I am an Intellectual Property lawyer and this offends me." The phrase "Intellectual Property" offends me.</li>
 <li>"What about Trade Secrets?" Trade secrets and private information are fine. No one should be forced to publish anything. But once you publish something, let it thrive.</li>
 <li>"Can't we just copyleft our way to the promised land?" Perhaps, but why lie about the system in the meanwhile?</li>
 <li>One difference between Physical Slavery and Intellectual Slavery is in the latter it is slavery from a million masters.</li>
 <li><a href="https://en.wikipedia.org/wiki/Alexandra_Elbakyan">This woman is amazing</a>.</li>
</ul>

<p>Published 2/21/2020</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//an-unpopular-phrase.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="what-can-a-programmer-learn-from-rock-climbing"><a href="#what-can-a-programmer-learn-from-rock-climbing">What can a Programmer learn from Rock Climbing?</a></h1>
<div class="scrollArticleDate">March 30, 2011 — </div>

<p>Railay is a tiny little beach town in Southern Thailand famous for its rock climbing. I've been in Railay for two weeks. When the weather is good, I'm outside rock climbing. When the weather is bad, I'm inside programming. So naturally I've found myself comparing the two. Specifically I've been thinking about what I can take away from my rock climbing experience and apply to my programming education.</p>

<p>Here's what I've come up with.</p>

<p>1. <b>You should always be pushing yourself.</b> Each day spent climbing I've made it to a slightly higher level than the previous day. The lazy part of me has then wanted to just spend one day enjoying this new level without pushing myself further. Luckily I've had a great climbing partner who's refused that and has forced me to reach for the next level each day. In both rock climbing and programming you should always be reaching for that new level. It's not easy, you have to risk a fall to reach a new height, but it's necessary if you want to become good. In programming, just like in climbing, you should be tagging along with the climbers at levels above you. That's how you get great. Of course, don't forget to enjoy the moment too.</p>

<p>2. <b><em>Really</em> push yourself.</b> In rock climbing you sometimes have these points where you're scared--no, where you're <em>fucking petrified</em>--that you're going to fall and get hurt or die and you're hanging on to the rock for dear life, pouring sweat, and you've got to overcome it. In programming you should <em>seek out moments like these</em>. It will never be that extreme of course, but you should find those spots where you are afraid of falling and push yourself to conquer them. It might be a project whose scope is way beyond anything you've attempted before, or a task that requires advanced math, or a language that scares the crap out of you. My climbing instructor here was this Thai guy named Nu. He's the second best speed climber in Thailand and has been climbing for fifteen years. The other day I was walking by a climbing area and saw Nu banging his chest and yelling at the top of his lungs. I asked a bystander what was going on and he told me that Nu was struggling with the crux of a route and was psyching himself up to overcome it. That's why he's a master climber. Because he's been climbing for over fifteen years and he's <em>still seeking out those challenges that scare him</em>. </p>

<p>3. <b>There's always a next level.</b> In rock climbing you have clearly defined levels of difficulty that you progress through such as 5 to 8+ or top rope to lead+. In programming the levels are less defined and span a much wider range but surely exist. You progress from writing "hello world" to writing compilers and from using notepad to using vim or textmate or powerful IDEs. You might start out writing a playlist generator and ten years later you may be writing a program that can generate actual symphonies, but there still will be levels to climb.</p>

<p>4. <b>Climbing or programming without teachers is very inefficient.</b> There are plenty of books on rock climbing. But there's no substitute for great teachers. You can copy what you see in books and oftentimes you'll get many parts right, but a teacher is great for pointing out what you're doing wrong. Oftentimes you just can't tell what the key concepts and techniques to focus on are. You might not focus on something that's really important such as using mostly legs in climbing or not repeating yourself in programming. A good teacher can instantly see your mistakes and provide helpful feedback. Always seek out great teachers and mentors whether they be friends, coworkers, or professional educators.</p>

<p>5. <b>You learn by doing; practice is key.</b> Although you need teachers and books to tell you what to do, the only way to learn is to do it yourself, over and over. It takes a ton of time to master rock climbing or programming and although receiving instruction plays an important part, the vast majority of the time it takes to learn will be spent practicing.</p>

<p>6. <b>Breadth, not only depth, is important</b>. Sometimes to get to the next level in rock climbing you need to get outside of rock climbing. You may need to take up yoga to gain flexibility or weightlifting to gain strength. Likewise in programming sometimes you need to go sideways to go up. If you want to master Rails, you'll probably want to spend time outside of it and work on your command line and version control skills. Programming has a huge amount of silos. To go very deep in any one you have to gain competance in many.</p>

<p>7. <b>People push the boundaries.</b> Both rock climbing and programming were discovered by people and people are continually pushing the boundaries of both. In rock climbing advanced climbers are discovering new areas, bolting new routes, inventing new equipment, perfecting new techniques, and passing down new knowledge. Programming is the most cumulative of all human endeavors. It builds on the work of tens of millions of people and new "risk takers" are always constantly pushing the frontiers (today in areas like distributed computing, data mining, machine learning, parallel processing and mobile amongst others).</p>

<p>8. <b>Embrace collaboration.</b> The rock climbing culture is very collaborative much like the open source culture. Rock climbing is an inherently open source activity. Everything a climber does and uses is visible in the open. This leads to faster knowledge transfer and a safer activity. Likewise, IMO open source software leads to a better outcome for all.</p>

<p>9. <b>Take pride in your work.</b> In rock climbing when you're the first to ascend a route your name gets forever attached to that route. In programming you should be proud of your work and add your name to it. Sometimes I get embarrassed when I look at some old code of mine and realize how bad it is. But then I shrug it off because although it may be bad by my current standards, it represents my best honest effort at the time and so there's nothing to be ashamed of. I'm sure the world's greatest rock climbers have struggled with some easy routes in their day.</p>

<p>10. <b>Natural gifts play a part.</b> Some people who practiced for 5,000 hours will be worse than some people who practiced for only 2,000 hours due to genetics and other factors. It would be great if how good you were at something was determined totally by how many hours you've invested. But it's not. However, at the extremes, the number of hours of practice makes a huge difference. The absolute best climbers spend an enormous amount of time practicing. In the middle of the pack, a lot of the difference is just due to luck. I've worked with a wide range of programmers in my (short so far) career. I've worked with really smart ones and some average ones. Some work hard and others aren't so dedicated. The best by far though, possess both the intelligence and the dedication. And I'd probably rather work with the dedicated and average smarts over the brilliant but lazy.</p>

<p><b>Sidenotes</b></p>

<p>Rock climbing and programming are great complements because rock climbing seems to erase any bad effects on your hands that typing all day can cause.</p>

<p>I'm a terrible rock climber and only a decent programmer. Take all my advice with a grain of salt.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//what-can-a-programmer-learn-from-rock-climbing.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="look-for-a-line"><a href="#look-for-a-line">Look for a Line</a></h1>
<div class="scrollArticleDate">March 5, 2011 — </div>

<p>A good friend passed along some business advice to me a few months ago. "Look for a line," he said. Basically, if you see a line out the door at McDonald's, start Burger King. Lines are everywhere and are dead giveaways for good business ideas and good businesses.</p>

<p>Let's use Groupon as a case study for the importance of lines. Groupon scoured Yelp for the best businesses in its cities--the businesses that had virtual lines of people writing positive reviews--and created huge lines for these businesses with their discounts. Other entrepreneurs saw the number of people lining up to purchase things from Groupon and created a huge line of clones. Investors saw other investors lining up to buy Groupon stock and hopped in line as well. Business is all about lines.</p>

<p>In every country we travel to I look around for lines. It's a dead giveaway for finding good places to eat, fun things to do, amazing sites to see. If you want to start a business, look for lines and either create a clone or create an innovation that can steal customers from that line. If you see tons of people lining up to take taxis, start a taxi company. Better yet, start a bus.</p>

<h2>Creating Lines</h2>

<p>Succeeding in business is all about creating lines. Apple creates lines of reporters looking to write about their next big product. Customers line up outside their doors to buy their next big product. Investors line up to pump money into AAPL. Designers and engineers line up to work there.</p>

<p>If you are the CEO of a company, your job is simply to create lines. You want customers lining up for your product, investors lining up to invest, recruits lining up to apply for jobs. It's very easy to measure how you're doing. If you look around and don't see any lines, you gotta pick it up.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//look-for-a-line.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="backpack-the-world-with-zero-planning"><a href="#backpack-the-world-with-zero-planning">Backpack the World with Zero Planning</a></h1>
<div class="scrollArticleDate">March 4, 2011 — </div>

<p><em>i haven't written in a long while because i'm currently on a long trip around the world. at the moment, we're in indonesia. one thing that really surprised me was that despite our best efforts to do as little planning as possible, we were in fact almost overprepared. i've realized you can do an around the world trip with literally zero planning and be perfectly fine. you can literally hop on a plane with nothing more than a passport, license, credit card, and the clothes on your back and worry about the rest later. i think a lot of people don't make a journey like this because they're intimidated not by the trip itself, but by the planning for the trip. i'm here to say you don't need to plan at all to travel the world (alas, would be a lot harder if you were not born in a first world country, unfortunately). here's my guide for anyone that might want to attempt to do so. every step is highlighted in bold. adjust accordingly for your specific needs and desires.</em></p>

<h3>the plan (see below for bullet points)</h3>

<p><b>set a savings goal.</b> you'll need money to travel around the world, and the more money you have, the easier, longer, and more fun your journey will be.</p>

<p><b>save, save, save</b>. make sure you save enough so that when your trip ends you won't come home broke. $12,000 would be a large enough amount to travel for a long time and still come back with money to get you resettled easily.</p>

<p>once you've saved half of your goal, <b>buy your first one way plane ticket to a cheap, tourist friendly country</b>. bali, indonesia or bangkok, thailand would be terrific first stops, amongst others. next, <b>get a paypal account with a paypal debit card</b>. this card gives you 1.5% cash back on all purchases, only charges a $1 atm fee, and charges no foreign transaction fees at all. the 1.5% cash back more than offsets the 1% fee Mastercard charges for interchange fees. if you don't have them already, <b>get a drivers license and a passport with at least 1 year left before expiration</b>. <b>get a free google voice number so people can still SMS and leave you voicemails without paying a monthly cell phone bill</b>. if you need glasses, contacts, prescription medication, or other custom things, stock up on those.</p>

<p><b>settle your affairs at home--housing, job, etc</b>. now, your planning is DONE! you have everything you need to embark on a trip around the world.</p>

<p><b>get on the plane with your passport, license, paypal debit card, and $100 US Cash</b>. you don't need anything else--not even a backpack! you'll pick up all that later.</p>

<p>once you've arrived in bali (or another similar locale), <b>go to a large, cheap shopping district</b>(kuta square in bali for example). if you arrived late, find a cheap place to crash first and hit the market first thing in the morning. look for backpackers at the airport or ask someone who works there for cheap accommodation recommendations.</p>

<p>once you're at the market, you've got a lot to buy. <b>visit an ATM</b> to take money out of your PayPal account in the local currency. if you want, space out your purchases over a few days. you'll want to <b>buy a lonely planet/rough guides for your current country, a solid backpack (get a good one), bug spray with deet, sun tan lotion,  a toothbrush, toothpaste, deodorant, nail clippers, tweezers, a swiss army knife, pepto bismol, tylenol, band aids, neosporin, bathing suit, some clothes for the current weather, shoes/flip flops, a cheap cell phone and SIM card, a netbook, a power adapter, and a camera and memory card</b>. you now have pretty much everything you need for your trip and you probably spent less than half of what you would have had to spend in the states. you may want some other things like a sleeping bag, tent, portable stove, goggles, etc., depending on what you want to do on your trip.</p>

<p>now, <b>talk to locals and other travelers for travel recommendations</b>. that plus your lonely planet and maybe some google searching and you'll have all the tools you need to plan where to go, what to do and what to eat.</p>

<p><b>hit up an internet cafe to email and print a copy of your drivers license, passport, and credit card</b>. it will be dirt cheap. <b>get some passport photos made for countries that require a photo for visas</b>. then <b>sign up for skype and facebook</b> (if you're the one person in the world who hasn't done this yet) to make cheap phone calls and keep in touch with family and friends.</p>

<p><b>plan your trip one country at a time</b>. every few days, <b>check flight prices for the next few legs of your trip</b>. you can sometimes get amazingly cheap deals if you check prices frequently and are flexible about when and where you fly. use sites like kayak, adioso, hotels.com, airbnb, and hostelworld to find cheap flights and places to stay, especially in expensive countries. in cheap countries, lonely planet and simply asking around often works great for finding great value hotels. also in expensive cities, <b>find the local groupon clones and check them often for great excursion and meal deals</b>. finally, you might want to get travel insurance from a site like world nomads.</p>

<p>that's it. enjoy your trip! </p>

<h3>bullet point format</h3>

<ul>
 <li>set a savings goal.</li>
 <li>save, save, save.</li>
 <li>buy your first one way plane ticket to a cheap, tourist friendly country.</li>
 <li>get a paypal account with a paypal debit card.</li>
 <li>get a drivers license and a passport with at least 1 year left before expiration.</li>
 <li>get a free google voice number.</li>
 <li>settle your affairs at home--housing, job, etc. </li>
 <li>get on the plane with your passport, license, paypal debit card, and $100 US Cash.</li>
 <li>go to a large, cheap shopping district.</li>
 <li>visit an ATM.</li>
 <li>buy a lonely planet for your current country, a solid backpack (get a good one), bug spray with deet, sun tan lotion, a toothbrush, toothpaste, deodorant, nail clippers, tweezers, a swiss army knife, pepto bismol, tylenol, band aids, neosporin, bathing suit, some clothes for the current weather, shoes/flip flops, a cheap cell phone and SIM card, a netbook, a power adapter, and a camera and memory card.</li>
 <li>talk to locals and other travelers for travel recommendations.</li>
 <li>hit up an internet cafe to email and print a copy of your drivers license, passport, and credit card.</li>
 <li>get some passport photos made for countries that require a photo for visas.</li>
 <li>sign up for skype and facebook.</li>
 <li>plan your trip one country at a time.</li>
 <li>check flight prices for the next few legs of your trip.</li>
 <li>find the local groupon clones and check them often for great excursion and meal deals.</li>
</ul>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//backpack-the-world-with-zero-planning.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-economy-explained"><a href="#the-economy-explained">The Economy Explained</a></h1>
<div class="scrollArticleDate">September 18, 2010 — </div>

<p>I was an Economics major in college but in hindsight I don't like the way it was taught. I came away with an academic, unrealistic view of the economy. If I had to teach economics I would try to explain it in a more realistic, practical manner.</p>

<p>I think there are two big concepts that if you understand, you'll have a better grasp of the economy than most people. </p>

<p>The first idea is that the economy has a pulse and its been beating for thousands of years. The second is that the economy is like a brain and if you visualize it in that way you can make better decisions depending on your goals.</p>

<p><h2>In Media Res</h2></p>

<p>Thousands of years ago people were trading goods and service, knitting clothes, and growing crops. The economy slowly came to life probably around 20 or 15 thousand years ago and it's never stopped. Although countless kingdoms, countries, industries, companies, families, workers, owners, have come and gone, this giant invisible thing called the economy has kept on trucking.</p>

<p>And not much has changed.</p>

<p>Certainly in 2,000 B.C. there was a lot more bartering and a lot less Visa, but most of the concepts that describe today's economy are the same as back then. You had industries and specialization, rich and poor, goods and services, marketplaces and trade routes, taxes and government spending, debts and investments. </p>

<p>Today, the economy is more connected. It covers more of the globe. But it's still the same economy that came to life thousands of years ago. It's just grown up a bit.</p>

<p>What are the implications of this? I think the main thing to take away from this idea is that we live in a pretty cool time where the economy has matured for thousands of years. It has a lot to offer if we understand what it is and how to use it. Which brings me to my next point.</p>

<p><h2>The economy is like a brain.</h2></p>

<p>The second big idea I try to keep in mind about the economy is that it's like a neural network. It's really hard to form a model of what the economy really looks like, but I think a great analogy is the human brain. </p>

<p>At a microscopic level, the brain is composed of around 100 billion neurons. The economy is currently composed of around 8 billion humans. </p>

<p>The average neuron is directly connected to 1,000 other neurons via synapses. Some neurons have more connections, some have less. The average human is directly connected to 200 other humans in their daily economic dealings. Some more, some less.</p>

<p>Neurons and synapes are not distributed evenly in the brain. Some are in relatively central connections, some are on the periphery. Likewise, some humans operate in critical parts of the economy(London or Japan for example), while many live in the periphery(Driggs, Idaho or Afghanistan, for example).</p>

<p>If we run with this analogy that the economy is like the human brain, what can we take home from that?</p>

<p><h3>For people that want a high paying job</h3></p>

<p>If you want a high paying job then you should think carefully about where you plug yourself into the network/economy. You want to plug yourself in where there's a lot of action. You want to plug yourself into a "nerve center". These nerve centers can be certain geographies, certain industries, certain companies, etc. For instance, plugging yourself into an investment banking job on Wall Street will bring you more money than teaching surfing in Maui. Now, if you're born in the periphery, like a third world nation, you might be SOL. It's tremendously easier to plug yourself into a nerve center if you're born in the right place at the right time.</p>

<p><h3>If you don't care much for money there are plenty of peripheries</h3></p>

<p>Now if you don't want a high paying job there are more choices available to you. Most of the economy is not a nerve center. It's also a lot easier to move from a high paying spot in the economic brain to a place in a lower paying spot.</p>

<p><h3>Starting a business you've got to inject yourself into it.</h3></p>

<p>When you start a business, you're basically a neuron with no synapses living outside the brain. You've got to inject yourself into the brain and build as many synapses as possible. When you start a business, the brain("the economy"), doesn't give a $hit about you. You've got to plug yourself in and make yourself needed. You've got to get other neurons(people/companies/governments) to depend on you. You can do this through a combination of hard work, great products/services, great sales, etc.</p>

<p>Now one thing I find interesting is that a lot of people say entrepreneurs are rebels. This is sort of true, however, for a business to be successful the business has to conform a lot for the economy to build connections to it. If you want to be a nerve center, you've got to make it easy for other parts of the economy to connect to you. You can't be so different that you are incompatible with the rest of the economy. If you want to be a complete rebel, you can do that on the periphery, but you won't become a big company/nerve center.</p>

<p><h3>If you're an existing business, it's hard to get dislodged.</h3></p>

<p>Once you are "injected" into the economy, it's hard to get dislodged. If a lot of neurons have a lot of synapses connected to you, those will only die slowly. For a long time business will flow through you. This explains why a company like AOL can still make a fortune.</p>

<p><h2>In conclusion</h2></p>

<p>In conclusion, the economy is a tremendous creature that can provide you with a lot if you plug yourself in. It's been growing for thousands of years and has a lot to offer. You can also to choose to stay largely unplugged from it, and that's okay too.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-economy-explained.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="you-cant-predict-the-future"><a href="#you-cant-predict-the-future">You Can't Predict the Future</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>


<p>I've been very surprised to discover how unpredictable the future is. As you try to predict farther out, your error margins grow exponentionally bigger until you're "predicting" nothing specific at all.</p>

<p>Apparently this is because many things in our world are "chaotic". Small errors in your predictions get compounded over time. 10 day weather forecasts are notoriously inaccurate despite the fact that teams of the highest IQ'd people on earth have been working on them for years. I don't understand the math behind chaos but I believe in the basic ideas. </p>

<h3>A Simple Example</h3>

<p>I can correctly predict whether or not I'll work out tomorrow with about 85% accuracy. All I need to do is look at whether I worked out today and whether I worked out yesterday. If I worked out those 2 days, odds are about 90% I will work out tomorrow. If I worked out yesterday but didn't work out today, odds are about 40% I will work out tomorrow. If I worked out neither of those two days, odds are about 20% I'll work out tomorrow.</p>

<p>However, I can't predict with much accuracy whether or not I'll work out 30 days from now. That's because the biggest two factors depend on whether I work out 29 days from now and 28 days from now. And whether I work out 29 days from now depends on the previous 2 days the most. If I'm wrong in my predictions about tomorrow, that error will compound and throw me off. It's hard to make an accurate prediction about something so simple. Imagine how hard it is to make a prediction about a non-binary quantity.</p>

<h3>Things You Can't Predict</h3>

<p>Weather, the stock market, individual stock prices, the next popular website, startup success, box office hits, etc. Basically dynamic, complex systems are completely resistant to predictions. </p>

<h3>On Model verse Off Model</h3>

<p>When making predictions you generally build a model--consciously or unconsciously. For instance, in predicting my future workouts I can make a spreadsheet (or just a "mental spreadsheet") where I come up with some inputs that are used to predict the future workout. My inputs might be whether I worked out today and whether it will rain. These are the "on model" factors. But all models leave things out that may or may not affect the outcome. For example, it could be sunny tomorrow and I could have worked out today, so my model would predict a workout tomorrow. But then I might get injured on my way to the gym--an "off model" risk that I hadn't taken into account.</p>

<h3>Avoid Making Predictions & Run From People Pushing Predictions</h3>

<p>The world is complex and impossible to predict accurately. But people don't get this. They think the world is easier to explain and predict than it really is. And so they demand predictions. And so people provide them, even though these explanations and predictions are bogus. Feel free to make or listen to long term predictions for entertainment, but don't believe any long term predictions you hear. We're a long way(possibility an infinitely long way) from making accurate predictions about the long run.</p>

<h3>Inside Information</h3>

<p>What if you have inside information? Should you then be able to make better predictions than others? Let's imagine for a moment that you were alive in 1945 and you were trying to predict when WWII would end. If you were like 99.99999+% of the population, you would have absolutely no idea that a new type of bomb was just invented and about to be put to use. But if you were one of the few who knew about the bomb, you might have been a lot more confident that the war was close to an end. Inside information gives you a big advantage in predicting the future. If you have information and can legally "bet on that", go for it. However, even the most connected people only have the inside scoop on a handful of topics, and even if you know something other people don't it's very hard to predict the scale (or direction) of an event's effect. </p>

<h3>Be Conservative</h3>

<p>My general advice is to be ultra conservative about the future and ultra bullish on the present. Plan and prepare for the worst of days--but without a pessimistic attitude. Enjoy today and make safe investments for tomorrow.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//you-cant-predict-the-future.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="ruby"><a href="#ruby">Ruby</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>Ruby is an awesome language. I've come to the conclusion that I enjoy it more than Python for the simple reason that whitespace doesn't matter.</p>

<p>Python is a great language too, and I have more experience with it, and the whitespace thing is a silly gripe. But I've reached a peak with PHP and am looking to master something new. Ruby it is.</p>

<p>Posted 08/25/2010</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//ruby.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="recommendations-are-far-from-good"><a href="#recommendations-are-far-from-good">Recommendations Are Far From Good</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>Doctors used to recommend leeches to cure a whole variety of illnesses. That seems laughable today. But I think our recommendations today will be laughable to people in the future.</p>

<p>Recommendations work terrible for everyone but decently on average. </p>

<p>We are a long, long way from making good individual recommendations. You won't get good individual recommendations until your individual genome is taken into account. And even then it will take a while. We may never get to the point where we can make good individual recommendations.</p>

<p>So many cures and medicines work for a certain percentage of people, but for some people they can have detrimental or even fatal effects. People rave about certain foods, exercises, and so forth, without considering how differences in <a href="https://breckyunits.com/nature-verse-nurture.html">genetics</a> can have a huge role.</p>

<p>People are quite similar, but they are also quite different and react to different things in different ways. I think we are a long way away from seeing breakthroughs in recommendations.</p>

<p>Recommendations are great business, but I think we're 2 or 3 orders of magnitude away from where they could be, and it could take decades(or never) to reach those levels.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//recommendations-are-far-from-good.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="nature-verse-nurture"><a href="#nature-verse-nurture">Nature Verse Nurture</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>


<p>Genetics, aka nature, plays the dominant role in predicting most aspects of your life, in my estimation.</p>

<p>Across every dimension in life your genes are both a glass ceiling--preventing you from reaching certain heights--and a cement foundation--making it unlikely you'll hit certain lows. How tall/short you will be, how smart/dumb you will be, how mean/nice you will be, how popular/lonely you will be, how athletic/clumsy, how fat/skinny, how talkative/quiet, how long/short you'll live, and so forth.</p>

<p>By the time you are born, your genes, place of birth, year of birth, parents--they're all set in stone, and the constraints on your life are largely in place. That's an interesting thought.</p>

<p>Nurture of course, plays a huge role in making you of course. Being born with great genes is irrelevant if you are malnourished, don't get early education, etc. But nurture cannot overcome nature. Our DNA is not at all maleable and no one knows if it ever will be. Nonetheless, it makes no sense to complain about nature. It is up to you to make the most of your starting hand. On the other hand, let us not be quick to judge others. I make that mistake a lot.</p>

<p>I think the bio/genome field will be the most interesting industry come 2025 or so.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//nature-verse-nurture.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="kids-are-neat"><a href="#kids-are-neat">Kids are Neat</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>Maybe I'm getting old, but I'm starting to think the best way to "change the world" isn't to bust your ass building companies, inventing new machines, running for office, promoting ideas, etc., but to simply raise good kids. Even if you are a genius and can invent amazing things, by raising a few good kids their output combined can easily top yours. Nerdy version: you are a single core cpu and can't match the output of a multicore machine. </p>

<p>I'm not saying I want to have kids anytime soon. I'm just realizing after spending time with my family over on Cape Cod, that even my dad, who is a harder worker than anyone I've ever met and has made a profound impact with his work, can't compete with the output of 4 people (and their potential offspring), even if they each work only 1/3 as hard, which is probably around what we each do. It's simple math.</p>

<p>So the trick to making a difference is to sometimes slow down, spend time raising good kids, and delegate some of the world saving to them.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//kids-are-neat.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="how-is-intelligence-distributed"><a href="#how-is-intelligence-distributed">How is Intelligence Distributed?</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>I've been working on a fun side project of categorizing things into Mediocristan or Extremistan(inspired by NNT's book The Black Swan).</p>

<p>I'm trying to figure out where intelligence belongs. Bill Gates is a million times richer than many people; was Einstein a million times smarter than a lot of people? It seems highly unlikely. But how much smarter was he? Was he 1,000x smarter than the average joe? 100x smarter?</p>

<p>I'm not sure. The brain is a complex thing and I haven't figure out how to think about intelligence yet.</p>

<p>Would love to hear what other people think. Shoot me an email!</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//how-is-intelligence-distributed.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="critical-thinking"><a href="#critical-thinking">Critical Thinking</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>I have a feeling critical thinking gets the least amount of brain's resources. The trick is to critically think about things, come to conclusions, and turn those conclusions into habits. The subconcious, habitual mind is much more powerful than the tiny little conscious, critically thinking mind.</p>

<p>If you're constantly using the critical thinking part of your mind, you're not using the bulk of your mind. You're probably accomplishing a lot less than you could be.</p>

<p>Come to conclusions and build good habits. Let your auto pilot take over. Then occasionally come back and revisit your conclusions.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//critical-thinking.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="circle-of-competence"><a href="#circle-of-competence">Circle of Competence</a></h1>
<div class="scrollArticleDate">August 25, 2010 — </div>

<p>Warren Buffet claims to follow an investment strategy of staying within his "circle of competence". That's why he doesn't invest in high tech--it's outside his circle.</p>

<p>I think this is good advice. The tricky part is to figure out where to draw the circle.</p>

<p>Here are my initial thoughts:</p>

<p>1. Start with a small circle. Be conservative about where you draw the circle.</p>
<p>2. Do what you're good at as opposed to what you want to do. Our economy rewards specialization. You want to work on interesting problems, but it pays better to work on things you've done before. Use that money to explore the things you want to do.</p>
<p>3. Be a big fish in a small circle.</p>
<p>4. Spend time outside your circle, but expand it slowly. Definitely work hard to improve your skill set but don't overreach. It's better to have a solid core and build momentum from that than to be marginal in a lot of areas.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//circle-of-competence.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="what-percentage-of-the-brain-does-what"><a href="#what-percentage-of-the-brain-does-what">What Percentage of the Brain Does What</a></h1>
<div class="scrollArticleDate">August 23, 2010 — </div>

<p><em>Note: Sometimes I'll write a post about something I don't understand at all. I am not a neuroscientist and have only the faintess understanding of the brain so this is one of those times. Reading this post could make you dumber. But  occasionally writing from ignorance leads to good things--like the time I wrote about <a href="https://breckyunits.com/whats-linear-algebra.html">Linear Algebra</a> and got a number of helpful emails better explaining the subject to me.</em></p>

<p>My question is: <b>how are the brain's resources allocated for its different tasks?</b></p>

<p>In a restaurant the majority of the workers are involved with serving, then a smaller number of employees are involved with cooking, and still a smaller number of people are involved with managing.</p>

<p>The brain has a number of functions: vision, auditory, speech, mathematics, locomotion, and so forth. Which function uses the most resources? Which function uses the least?</p>

<p>I have no idea, but my guess is below. </p>

<p>1. Vision. My guess is vision uses more than 50% of the brain.</p>
<p>2. Memory. Perhaps 50% or more of the brain is involved with storing memories of sights, sounds, smells, etc.</p>
<p>3. Locomotion. Movement probably touches between 20-60% of the brain.</p>
<p>4. Auditory/Speech. I guess that between 20-40% of the brain is involved with this.</p>
<p>5. Taste/touch/smell. My guess is between 10-20%.</p>
<p>6. Emotion. My guess is 10-15% is involved with setting/controlling emotion.</p>
<p>7. Long term planning/mathematics. I think the ability to do complex thinking is given the least resources.</p>

<p>I'm probably quite far off, but I thought it was an interesting question to think about. Now I'll go see if I can dig up some truer numbers.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//what-percentage-of-the-brain-does-what.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-recency-effect"><a href="#the-recency-effect">The Recency Effect</a></h1>
<div class="scrollArticleDate">August 23, 2010 — </div>

<p>Your most recent experiences effect you the most. Reading this essay will effect you the most today but a week from now the effect will have largely worn off. </p>

<p>Experiences have a half-life. The effect decays over time. You might watch Almost Famous, run out to buy a drumset, start a band, and then a month later those drums could be gathering dust in your basement. You might read Shakespeare and start talking more lyrically for a week.</p>

<p>Newer experiences drown out old ones. You might be a seasoned Rubyist and then read an essay espousing Python and suddenly you become a Pythonista. </p>

<p>All genres of experiences exhibit the recency effect. Reading books, watching movies, listening to music, talking with friends, sitting in a lecture--all of these events can momentarily inspire us, influence our opinions and understanding of the world, and alter our behaviors.</p>

<p><b>Taking Advantage of the Recency Effect</b></p>

<p>If you believe in the recency effect you can see the potential benefit of superstitious behavior. For instance, I watched "The Greatest Game Ever Played", a movie about golf, and honest to god my game improved by 5 strokes the next day. A year later when I was a bit rusty, I watched it again and the effect was similar(though not as profound). When I want to write solid code, I'll read some quality code first for the recency effect.</p>

<p>If you want to do great work, set up an inspiring experience before you begin. It's like taking a vitamin for the mind.</p>

<p><b>Some More Examples</b></p>

<p>- Settlers of Cataan can make you an astute businessman after a few games. You'll find yourself negotiating everything and saving/making money left and right. </p>
<p>- Influence by Cialdini will give you a momentary force field against the tricks of pushy salespeople and also temporarily boost your own ability to get people to do what you want.</p>
<p>- Watching Jersey Shore will temporarily make you feel much better about your life while at the same time altering your vocabulary with phrases like "You do you" and "GTL".</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-recency-effect.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-ovarian-lottery--other-side-projects"><a href="#the-ovarian-lottery--other-side-projects">The Ovarian Lottery & Other Side Projects</a></h1>
<div class="scrollArticleDate">August 11, 2010 — </div>

<p>I've had some free time the past two weeks to work on a few random ideas I've had. </p>

<p>They all largely involve probability/statistics and have no practical or monetary purpose. If I was a painter and not a programmer you might call them "art projects".</p>

<p>One project deals with categorizing data into "Extremistan" and "Mediocristan". <a href="http://www.fooledbyrandomness.com/">Taleb's</a> books, the Black Swan and Fooled by Randomness, list a number of different examples for each, and I thought it would be interesting to extend that categorization further.</p>

<p>The second project I'll expand on a bit more here.</p>

<p><b>TheOvarianLottery.com</b></p>

<p>Warren Buffett coined the idea of the "ovarian lottery"--his basic idea is that the most important factor in determining how you end up in life is your birth. You either are born "lucky"--in a rich country, with no major diseases, to an affluent member of society, etc.--or you aren't. Other factors like hard work, education, smart decision making and so forth have a role, but play a relatively tiny role in determining what your life will be like.</p>

<p>I thought this was a very interesting idea and so I started a program that lets you be "born again" and see how things turn out. When you click "Play", theOvarianLottery will show you:</p>

<p>- What year you were born in(or you can choose this yourself)</p>
<p>- What continent/country you were born in</p>
<p>- What your gender is</p>
<p>- How old you will be when you die</p>
<p>- Your Religion</p>
<p>- Silly things like whether you will ever be a Facebook user (with 500 million users potentially 1 in every 200 people that has ever lived has used Facebook!)</p>

<p><b>Two Surprises</b></p>

<p>I've encountered two major surprises with the theOvarianLottery.</p>

<p>First, I thought theOvarianLottery would take me an hour or two. I was wrong. It turns out the coding isn't hard at all--the tricky part is finding the statistics. Not a whole lot of countries provide detailed statistics on their current populations. Once you start looking up stats for human population before 1950, the search gets an order of magnitude harder. (I've listed a few good sources and resources at the bottom of this post if anyone's interested)</p>

<p>Second, I've found so many fascinating diversions while working on this. I've encountered cool stats like:</p>

<p>- Estimates on the total number of births that have happened so far range from 40 - 150 billion. This doesn't include species prior to homo sapiens.</p>
<p>- Around 1 in 5 births today happens in China. Odds of being born in the U.S. are around 4%.</p>
<p>- Potentially around 40% of all babies that have ever been born have died before the age of 1. Nowadays the infant mortality rate is around 2% (and less in many countries).</p>

<p>But cooler than interesting descriptive statistics are the philosophical questions that this idea of the Ovarian Lottery raises. If I was a philosopher I might ponder these questions at depth and write more about each one, but I don't think that's a great use of time and so I'll just list them. Philosophy is most often a fruitless excercise.</p>

<p><b>How does the real Ovarian Lottery work?</b></p>

<p>My site is just a computer program. It's interesting to think about how the real ovarian lottery works. Is there a place where everyone is hanging out, and then you spin a wheel and your "soul" is magically transported to a newborn somewhere in the world?</p>

<p><b>What if the multiverse theory is correct?</b></p>

<p>If the <a href="http://en.wikipedia.org/wiki/Multiverse">multiverse</a> theory is correct, then my odds are almost certainly off. In other words, theOvarianLottery assumes there's only 1 universe and extrapolates the odds from that. If there are dozens or infinite universes, who knows what the real odds are.</p>

<p><b>What role has chaos played in the development of humanity?</b></p>

<p>If you go back to around 10,000 B.C., somewhere around 2-10 million people roamed the planet. Go back earlier and the number is even smaller. It's interesting to think of how small differences in events back then would have created radically different outcomes today. I've dabbled a bit into chaos theory and find it quite humbling.</p>

<p><b>What does the fact that we are alive today tell us about the future?</b></p>

<p>Depending on the estimate, between 4-20% of all humans that have ever lived are alive today. In other words, the odds of you being alive right now (according to my model) are higher than they've ever been. The odds of you being alive in 10,000 BC are over 1,000 times less. If humans indeed go on to live for another ten thousand years and the population grows another 1,000 times the odds of you being born today would be vastly smaller. In other words, if my model represented reality than we could conclude that odds are high that the human population does not continue growing like it has.</p>

<p><b>What's the future shape of the population curve?</b></p>

<p><img src="world-Population-1800-2100.png"></p>

<p>The growth of human population has followed an exponential curve. How long will it last? Will earth become overpopulated? Will we invent technology to leave earth? Will human population decline? Human population growth is hard to predict over any long term time period.</p>

<p><b>Complete Uselessness of This Model</b></p>

<p>I don't believe you can take the concept of the Ovarian Lottery any more seriously than you can take religion. It provides food for thought, but it doesn't provide any real answers to much. The stats though could certainly be used in debates.</p>

<p><em>Oh well. Ars gratia artis</em></p>


<p>Notes:</p>
<p>I hope to finish up theOvarianLottery and slap a frontend on it sometime in the future.</p>

<p>Helpful Links for Population Statistics(beyond wikipedia):</p>
<p><a href="http://www.census.gov/ipc/www/worldhis.html">US Census Bureau Historical Stats</a></p>
<p>Human Population by year: <a href="/population.html">rough approximation</a></p>
<p><a href="http://nationmaster.com">NationMaster.com</a></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-ovarian-lottery--other-side-projects.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="what-i-want"><a href="#what-i-want">What I Want</a></h1>
<div class="scrollArticleDate">August 6, 2010 — </div>

<p>Figuring out what you want in life is very hard. No one tells you exactly what you want. You have to figure it out on your own.</p>

<p>When you're young, it doesn't really matter what you want because your parents choose what you do. This is a good thing, otherwise kids would grow up uneducated and malnourished from ice cream breakfasts. But when you grow up, you get to call the shots.</p>

<h3>You Need Data to Figure Out What You Want</h3>

<p>The big problem with calling the shots is that what your conscious, narrative mind thinks you want and what your subconscious mind really wants often differ quite a lot. For instance, growing up I said I wanted to be in politics, but in reality I always found myself tinkering with computers. Eventually you have the "aha" moment, and drop things you thought you wanted and focus on the things that you really want, the things you keep coming back to.</p>

<p>If you pay attention to what you keep drifting back to, you'll figure out what you want. You just have to pay attention. </p>

<p>Collect data on what makes you happy as you go. Run experiments with your life.</p>

<p>You don't have to log what you do each day and run statistics on your life. But you do have to get out there and create the data. Try different things. Try different jobs, try different activities, try living in different places. Then you'll have experiences--data--which you can use to figure out exactly what the hell it is you really want.</p>

<h3>You Want More Than You Think</h3>

<p>People like to simplify things as much as possible. It would be nice if you only wanted a few things, such as a good family, a good job, and food on the table. I think though that in reality we each want somewhere around 10 to 20 different things. On my list of things I want, I've got 15 or 16 different things. Family, money, and food are on there. But also some more specific things, like living in the San Francisco Bay area, and studying computer science and statistics.</p>

<h3>Being Happy is About Balancing All of These Things</h3>

<p>You don't get unlimited hours in the day so you've got to budget your time amongst all of these things that you want. If I were to spend all of my time programming, I'd have no time for friends and family, which are two things really important to me. So I've got to split my energies between these things. You'll always find yourself neglecting at least one area. Life is a juggling act. The important thing is to juggle with the right balls. It's fine to drop a ball for a bit, just pick it back up and keep going.</p>

<h3>Limit the Bad Stuff</h3>

<p>As you grow up you'll learn that there are things you want that aren't so good for you. Don't pretend you don't want that, just try to minimize it. For instance, part of me wants to eat ice cream almost everyday. But part of me wants to have healthy teeth, and part of me wants to not be obese. You've got to strike a balance.</p>

<h3>Your Wants Change</h3>

<p>First, you've got to figure out all the different things you want. Then, you've got to juggle these things as best as possible. Finally, when you think you've got it figured out, you'll realize that your wants have changed slightly. You might want one thing a bit less (say, partying), while wanting something else more (a career, a family, learning to sail, who knows). That's totally normal. Just add or drop the new discovery to your list and keep going.</p>

<h3>Make a Mindmap</h3>

<p>Almost 2 years ago I made a dead simple mindmap of what I wanted. I think a mindmap is better than a list in this case because A) it looks cooler and B) there's not really a particular ranking with what I want. My list has changed by just one or two things in 2 year's time. </p>

<p>I like to be mysterious and have something to talk about at parties, so I've gone ahead and erased most of the items, but you can get the idea:</p>

<p><img src="wiwmin.png" width="450"></p>

<p>If you don't know what it is you want, try making a mindmap.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//what-i-want.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="orbits"><a href="#orbits">Orbits</a></h1>
<div class="scrollArticleDate">August 6, 2010 — </div>

<p><em>In February I celebrated my 26th Orbit. I am 26 orbits old. How many orbits are you?</em></p>

<p>I think we should use the word "orbit" instead of year. It's less abstract. The earth's 584 million mile journey around the sun is an amazing phenomena, and calling it merely "another year" doesn't do it justice. </p>

<p>Calling years orbits also makes life sound more like a carnival ride--you get a certain number of orbits and then you get off. </p>

<p>Enjoy the ride!</p>

<p><b>Notes</b></p>

<p>1. Neat fact: The sun completes a revolution around the center of the Milky Way galaxy once every 250 million years. </p>
<p><em><a href="http://www.quora.com/The-Moon-orbits-the-Earth-and-the-Earth-orbits-the-Sun-What-does-the-Sun-orbit">It is estimated to have completed 25 orbits during the lifetime of our Sun, and less than one orbit since the origin of humans.</a></em></p>

<p>2. My roommate Andrew suggests the reason why we don't refer to a year as an orbit is perhaps because when we started calling things years, we didn't yet know that the earth revolved around the sun. Bad habits die hard.</p>

<p>3. I think the orbit around the sun has more impact on our world than we even realize. In other words, seasonality's affects are underestimated. Perhaps when you give something a name it seems less threatening. We call the change from August to December "fall", and thus we underestimate the volatility and massive change that occurs all around us.</p>

<p>4. We should also call days "revs". Okay I'm done.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//orbits.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="happiness-is-in-mediocristan"><a href="#happiness-is-in-mediocristan">Happiness is in Mediocristan</a></h1>
<div class="scrollArticleDate">August 6, 2010 — </div>

<p>Three unexpected things have happened to me during my two years of entrepreneurial pursuits in California.</p>

<p>First, I have not gotten rich.</p>

<p>Second, I have met many people who have gotten rich. I've even had the pleasure to witness some of my friends get rich.</p>

<p>Third, I've yet to meet someone much happier than me.</p>

<p>I've met a large amount of people who are 6, 7, even 8 <em>orders of magnitude richer than me</em> and yet not a single one of them was even close to an <em>order of magnitude happier than me</em>.</p>

<p>The explanation, I finally realized, is simple.</p>

<p><b>Happiness is a physical quantity, like Height or Weight</b></p>

<p>Happiness, as <a href="http://www.fooledbyrandomness.com/">NNT</a> would say, resides in <a href="http://emergic.org/2007/06/07/tech-talk-black-swan-mediocristan-and-extremistan/">Mediocristan</a>. Happiness is a physical condition and just as it is impossible to find someone 60 feet tall, it is impossible to find someone ten times happier than everyone else. I could sit next to you and drink 3 cups of coffee, and sure, I might be 20% happier than you for about 20 minutes, but 1,000% happier? Not even close. </p>

<p>Our happiness is a result of some physical processes going on in our brains. While we don't understand yet the details of what's happening, from observation you can see that people only differ in happiness about as much as they differ in weight.</p>

<p><b>Millionaire Entrepreneurs Do Not Leap Out of Bed Every Morning</b></p>

<p>This idea of happiness being distributed rather equally might not be surprising to people with common sense. There are a million adages that say the same thing. Thinking about it mathematically took me by surprise, however.</p>

<p>I was rereading the Black Swan at the same time I was reading Zappos founder Tony Hsieh's "Delivering Happiness". In his autobiography, Tony talks about how he wasn't much happier after selling his first company for a 9 figure sum. I thought about this for a bit and realized I wasn't suprised. I've read the same thing and even witnessed it happen over and over again amongst startup founders who strike it rich. The change in happiness doesn't reflect the change in the bank account. <em>Not at all!</em> The bank account undergoes a multi-order of magnitude shift, while the happiness level fluctuates a few percentage points at best. It dawned on me that happiness is in Mediocristan. Of course!</p>

<p><b>Don't, Don't Stress Over Getting Rich</b></p>

<p>I'm not warning you that you might not become an order of magnitude happier if you become rich, I'm telling you <b>IT'S PHYSICALLY IMPOSSIBLE</b>!!! There's no chance of it happening. You can be nearly as happy today as you will be the week after you make $1 billion. (In rare cases, you might even be less happy after you strike it rich.) Money is great, and having a ton of it would be pretty fun. By all means, try to make a lot of it. You will most likely be at least a few percentage points happier. Just remember to keep it in a realistic perspective. Aim to be 5 or 10% happier, not 500% happier.</p>

<p>It's funny, although our society doles out vastly different rewards, at the end of the day, in what matters the most, mother nature has created a pretty equal playing field.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//happiness-is-in-mediocristan.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-do-you-know-game-and-why-we-need-celebrities"><a href="#the-do-you-know-game-and-why-we-need-celebrities">The Do You Know Game and Why We Need Celebrities</a></h1>
<div class="scrollArticleDate">August 3, 2010 — </div>

<p>Last night over dinner we had an interesting conversation about why we care about celebrities. Here's my thinking on the matter.</p>

<h3>Celebrities are not that special</h3>

<p>If you look at some stats about the attributes of celebrities, you'll realize something interesting: they're not that special. By any physical measure--height, weight, facial symmetry, body shape, voice quality, personality, intelligence--celebrities are not much different from the people around you. Conan O'Brien might be a bit funnier than your funniest friend, but he wouldn't make you laugh 10x more; it'd be more like 5% more. Angelina Jolie might be 10% more attractive than your most attractive friend, but for some groups she could even be less attractive.</p>

<p>If these people aren't so special, why do they interest us so much? One explanation is that we see these people over and over again on television and as a result we are conditioned to care about them.</p>

<p>I concede this may be part of it, but I actually don't think celebrities are forced upon us. Instead, I think we <em>need</em> celebrities. We need them to function in a global society. </p>

<p>It's all because of the Do You Know Game.</p>

<h3>The Do You Know Game</h3>

<p>The Do You Know Game is a popular party game. People often play it every time they meet a stranger. It goes something like this:</p>

<p>Person 1: "Where are you from?"</p>

<p>Person 2: "Brockton, Massachusetts"</p>

<p>Person 1: "Oh, do you know Greg Buckley?"</p>

<p>Person 2: "Yes, I know Greg Buckley."</p>

<p>Person 1: "Cool! That's so funny! Small world!!!"</p>

<p>That's the basic premise. You ask me where I am from. You think of everyone you know from that place and ask me one by one if I know that person. Then we switch roles and play again.</p>

<p>People play this game at work, at parties, at networking events, at college--especially at college. This game has a benefit.</p>

<h3>The Do You Know Games Lets Strangers Build Trust</h3>

<p>People play this game for many reasons, but certainly one incentive to play is that if two strangers can identify a mutual friend, they can instantly trust each other a bit more. If we have a mutual friend, I'm more likely to do you a favor, and less likely to screw you over, because word gets around. Back in the day when people carried swords, this was even more important.</p>

<p>A mutual friend also gives two strangers a shared interest. It's something that they can continually talk about. </p>

<p>And having a mutual friend can reveal a lot about a person:</p>

<p><blockquote>Person A: "Do you know Breck Yunits?"</p>
<p>Person B: "Yes, I think he's an idiot."</p>
<p>Person A: [Note to self: Person B is a liar and a thief]</blockquote></p>

<p>As you can see, having mutual friends serves many purposes.</p>

<h3>The Do You Know Game has gotten harder as the world has globalized</h3>

<p>Throughout the 20th century, the proportion of people that have traveled far from their hometowns for school or career has steadily increased. The further you travel from your home, the less likely you are to have a successful round of "do you know" with a stranger. You might share common interests or values with the new people you meet, but you'll know none of the same people and thus it will be harder to build and grow relationships. This is a big problem for a globalized society that depends on strong ties between people from different places to keep the economy running smoothly.</p>

<h3>Celebrities to the Rescue</h3>

<p>Celebrities have naturally arisen to fill a need for strangers in a globalized world to have mutual friends. We all interact with strangers more frequently nowadays, and if we didn't have celebrities, there would be a gaping hole in our arsenal of shortcuts to establishing trust with new people. There are a thousand ways to build repoire with a stranger, but the technique of talking about a shared acquaintance is one of the easiest and most effective. We travel farther than we ever have, but thanks to celebrities, we still have dozens of "mutual friends" wherever we go.</p>

<p>Of course, just because two people know who Tom Hanks is doesn't mean they should trust each other more. Tom Hanks doesn't know them and so none of the "word gets around" stuff I mentioned earlier applies. I'm not arguing that celebrities are an equal substitute for a mutual friend by any means. A mutual friend is a much more powerful bond than knowing about the same celebrity.</p>

<p>But celebrities are better than nothing.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-do-you-know-game-and-why-we-need-celebrities.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="design-matters-a-lot-"><a href="#design-matters-a-lot-">Design Matters, a lot </a></h1>
<div class="scrollArticleDate">July 2, 2010 — </div>

<p>A year ago I wrote a post titled "The Truth about Web Design" where I briefly argued that "design doesn't matter a whole lot."</p>

<p>My argument was: "you go to a website for the utility of it. Design is far secondary. There are plenty of prettier things to look at in the real world."</p>

<p>I do think the real world is a pretty place, but about design, I was completely wrong. I now think design is incredibly important, and on par with engineering. I used to think a poorly designed product was a matter of a company setting the right priorities, now I think it reflects ignorance, laziness or mediocrity. If a company engineers a great product but fails to put forward a great design, it says:</p>

<p>1. The company doesn't feel that design is important.</p>
<p>2. The company was too lazy to put much effort into design.</p>
<p>3. The company's engineering team is incapable of working effectively with the design team.</p>

<p>##Why Design is Important, In Princple</p>

<p>For nearly a decade I've always dreamed of my ideal computer as no computer at all. I wanted a computer smaller than the smallest smartphone, that would always be ready to take commands but would also be out of site. In other words, I've always thought of computers purely as problem solving tools--as a means to an end. </p>

<p>I want the computer to solve the problem and get out of my way. Computers are ugly. The world is beautiful. I like to look at other people, the sky, the ocean and not a menu or a screen. I didn't care about the style in which the computer solved my problem, because no matter how "great" it looked it couldn't compare to the natural beauty of the world. </p>

<p>I was wrong.</p>

<p>A computer, program, or product should always embody a good design, because the means to the end is nearly important as the end itself.  True, when riding in a car I care about the end--getting to my destination. But why shouldn't we care about the style in which we ride? Why shouldn't we care about the means? After all, isn't living all about appreciating the means? We all know what the end of life is, the important thing is to live the means with style. I've realized that I want style--and I'm a little late to the party, most people want style.</p>

<p>##Why Design is Important, In Practice</p>

<p>If that argument didn't make sense, there are a number of practical reasons why a great design is important.</p>

<p><b>A great design can unlock more value for the user.</b> Dropbox overcomes herculean engineering challenges to work, but if it weren't for its simple, easy to use design it wouldn't be nearly as useful. </p>

<p><b>A great design can be the competitive edge in a competive market.</b> Mint.com had a great design, and it bested a few other startups in that emerging market.</p>

<p><b>A great design can be the differentiator in a crowded market.</b> Bing's design is better than Google's. The design of Bing differentiates the two search engines in my mind, and makes Bing more memorable to me. The results of Microsoft's search engine have always been decent, but it was the design of Bing that finally gave them a memorable place in consumers' minds.</p>

<p><b>A great design is easy to get people behind.</b> People like to support sites and products that are designed well. People love to show off their Apple products. Airbnb's beautiful design had a large role in making it easy for people to support the fledgling site.</p>

<p>#What to do if you aren't good at design</p>

<p>Personally, I'm a terrible designer. Like many hackers, I can program but I can't paint. What should we do? </p>

<p>First, learn to appreciate the importance of design. </p>

<p>Second, learn to work well with designers. Don't treat design as secondary to engineering. Instead, think of how you can be a better engineer to execute the vision of your design team. </p>

<p>Great engineering can't compensate for poor design just as great design can't compensate for poor engineering. To create great products, you need both. Don't be lazy when it comes to design. It could be the make or break difference between your product's success or failure.</p>


<p>Notes</p>

<p>1. Are Google, craigslist, and eBay exceptions to the rule that you need a great design to succeed? Yes. If you're the first mover in a market, you can get by with an ugly design. At least in the case of Google, they continually refine it.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//design-matters-a-lot-.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="competition-and-specialization"><a href="#competition-and-specialization">Competition and Specialization</a></h1>
<div class="scrollArticleDate">June 28, 2010 — </div>

<p>Competition and specialization are generally positive economics forces. What's interesting is that they are contradictory.</p>

<p><b>Competition</b>. Company 1 and Company 2 both try to solve problem A. The competition will lead to a better outcome for the consumer.</p>

<p><b>Specialization</b>. Company 1 focuses on problem A; Company 2 focuses on problem B. The specialization will lead to a better outcome for all because of phenomena like economies of scale and comparative advantage.</p>

<p>So which is better? Is it better to have everyone compete to solve a small number of problems or to have everyone specialize on a unique problem?</p>

<p>Well, you want both. If you have no competition, it's either because you've been able to create a nice monopolostic arrangement for yourself or it's because you're working on a problem no one cares about. </p>

<p>If you have tons of competition, you're probably working on a problem that people care about but that is hard to make a profit in.</p>

<p><b>Update 8/6/2010</b>: Overspecialization can be bad as well when things don't go according to plan, as NNT points out, <a href="http://www.fooledbyrandomness.com/robustness.pdf">Mother Nature does not like overspecialization, as it limits</p>
<p>evolution and weakens the animals.</a> If Intel fell into a sinkhole, we'd be screwed if it weren't for having a backup in AMD.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//competition-and-specialization.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="simple-but-not-easy"><a href="#simple-but-not-easy">Simple, but not easy</a></h1>
<div class="scrollArticleDate">June 17, 2010 — </div>

<p>Doing a startup is surprisingly simple. You have to start by creating a product that people must have, then you scale it from there.</p>

<p>What percent of your customers or "users" would be disappointed if your product disappeared tomorrow? If it's less than 40%, you haven't built a must have yet.</p>

<p>As simple as this sounds, I've found it to be quite hard. It's not easy to build a must have.</p>

<p><b>Some Reasons Why Startups Fail to Build a Must Have</b></p>

<p>1. <b>Lack of ability</b>. If you want to build a plane that people can't wait to fly on, you probably need to be an aerospace engineer. If you want to draw a comic that people can't wait to read, you probably need to be a talented artist and comedian to boot. You might have a great idea for a search engine, but if you don't have a PhD level understanding of math and computer science, your search engine is quite unlikely to become a must have when people have Google. You need a talented team in the product area to build a must have.</p>

<p>2. <b>Release too late</b>. A lot of people take too long to release and get feedback. The odds of your first iteration being a must have are quite slim. People aren't going to get it like you get it. You'll need to iterate. If you burn up all your money and energy before releasing, you might not leave yourself with enough time to tweak your product until it's a must have. Give yourself ample time, release early.</p>

<p>3. <b>Lack of vision</b>. It seems like successful entrepreneurs have a clear vision about what people will want ahead of time. There are endless directions in which you can take your product. Sometimes a product will get started in the right direction, but then will be tweaked into a dead end. I think you need a simple, clear, medium to long term vision for the product.</p>

<p>4. <b>Preoccupation with Unimportant Things</b>. A lot of founders get bogged down with minor details like business plans or equity discussions or fundraising processes. If you don't put your focus almost entirely on creating a must have product, none of this stuff will matter. Your company needs a reason to exist, without a must have product, there isn't one. (Unless of course, you are trying to create a lifestyle business, in which your first priority is a good lifestyle, then by all means do things in which ever way you want).</p>

<p>5. <b>Too broad a focus</b>. Every successful business starts with a small niche. You need to create a must have product for a few people before you can create one for a lot of people. If your business is a two sided marketplace, pick a very small market to start in, and grow it from there.</p>

<p>6. <b>Get tired of the space</b>. This is a mistake I've made a lot. I've come up with a simple idea that I think is cool, I launch it, then when the going gets tough, I realize I'm not too interested in the space. No matter what the idea or space, there are going to be low moments when you don't have a growing, must have product, and if your passion isn't in that industry, you might not want to keep going. Pick a space that you think is cool; build a product that you want.</p>

<p>7. <b> Stubbornness </b>. Sometimes people are too stubborn to realize that their product isn't something people want. If people don't care if it disappeared tomorrow, you need to improve it! Don't be stubborn. Listen to the numbers. Listen to feedback.</p>

<p>What are some other reasons people fail to build a must have product?</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//simple-but-not-easy.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="flip-flopping"><a href="#flip-flopping">Flip Flopping</a></h1>
<div class="scrollArticleDate">June 16, 2010 — </div>

<p>Every Sunday night in college my fraternity would gather in the commons room for a "brother meeting". (Yes, I was in a fraternity, and yes I do regret that <a href="http://brosicingbros.com">icing</a> hadn't been invented yet). These meetings weren't really "productive", but we at least made a few decisions each week. The debates leading up to these decisions were quite fascinating. The questions would be retarded, like whether or not our next party should be "Pirate" themed or "Prisoner" themed(our fraternity was called Pike, so naturally(?) we were limited to themes that started with the letter P so we could call the party "Pike's of the Caribean" or something). No matter what the issue, we would always have members make really passionate arguments for both sides. The awesome thing was that these were very smart, persuasive guys. I'd change my mind a dozen times during these meetings. Without fail, whichever side spoke last would have convinced me that not only should we have a Pirate themed party, but that it was quite possibly one of the most important decisions we would ever make. </p>

<p>The thing I realized in these meetings is that flip flopping is quite easy to do. It can be really hard, if not impossible, to make the "right" decision. There are always at least two sides to every situation, and choosing a side is a lot more about the skills of the argumentors, the mood you happen to be in, and the position of the moon(what I'm trying to say is there's a lot of variables at work). </p>

<p>I think humans are capable of believing almost anything. I think our convictions are largely arbitray.</p>

<p>Try an experiment. </p>

<p>1) Take an issue, a political issue--the war in Afghanistan, Global Warming, marijuana legalization--or a minor everyday issue--what to have for dinner tonight, whether it's better to drink coffee or not, whether Facebook is a good thing or bad thing. </p>

<p>2) Take a stand on that issue. Think of all the reasons why your stand is right. Be prepared to support your stance in a debate.</p>

<p>3) Completely change your position. Take the other side. Think of every reason why this new side is correct. Be prepared to support this side without feeling like you are lying.</p>

<p>4) Keep flipping if you want.</p>

<p>I think it's fascinating to see how now matter what the issue, you can create a convincing case for any side. And it's hard not to hear an argument for the opposing side and not want to change your position. Our brains can be easily overloaded. The most recently presented information pushes out the old arguments.</p>

<p>But at some points, survival necessitates we take a side. The ability to become stubborn and closedminded is definitely a beneficial trait. Survival causes us to become stubborn on issues and survival requires closedmindeness to get anything done.</p>

<p>Three men set out to find a buried treasure. The first guy believes the treause is to the north so heads in that direction. The second guy heads south. The third guy keeps changing his mind and zig zags between north and south. I don't know who finds the treasure first, but I do know it's certainly not the third guy.</p>

<p>Oftentimes the expected value of being stubborn is higher than the expected value of being thoughtful.</p>

<p>Is flip flopping a good thing? Is being open minded harder than being stubborn? Does it depend on the person? Does success require being certain?</p>

<p>I have no idea.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//flip-flopping.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-churn-rate-of-data"><a href="#the-churn-rate-of-data">The Churn Rate of Data</a></h1>
<div class="scrollArticleDate">June 15, 2010 — </div>

<p>I think it's interesting to ponder the value of information over it's lifetime.</p>

<p>Different types of data become outdated at different rates. A street map is probably mostly relevant 10 years later, while a 10 year old weather forecast is much less valuable.</p>

<p>Phone numbers probably last about 5 years nowadays. Email addresses could end up lasting decades. News is often largely irrelevant after a day. For a coupon site I worked on, the average life of a coupon seemed to be about 2 weeks. </p>

<p>If your data has a long half life, then you have time to build it up. Wikipedia articles are still valuable years later.</p>

<p>What information holds value the longest? What are the "twinkies" of the data world?</p>

<p>Books, it seems. We don't regularly read old weather forecasts, census rolls, or newspapers, but we definitely still read great books, from Aristotle to Shakespeare to Mill.</p>

<p>Facts and numbers have a high churn rate, but stories and knowledge last a lot longer.</p>

<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-churn-rate-of-data.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="culture-and-complexity-"><a href="#culture-and-complexity-">Culture and Complexity </a></h1>
<div class="scrollArticleDate">June 14, 2010 — </div>

<p>Have you heard of the Emperor Penguins? It's a species of penguins that journeys 30-75 miles across the frigid Antarctic to breed. Each year these penguins endure 8 months of brutally cold winters far from food. If you aren't familiar with them, check out either of the documentaries March of the Penguins or Planet Earth.</p>

<p>I think the culture of the emperor penguins is fascinating and clearly reveals some general traits from all cultures:</p>

<p>- Culture is a set of habits that living things repeat because that's what they experienced in the past, and the past was favorable to them. Cultures have a mutually dependent relationship with their adherents.</p>

<p>The Emperor Penguins are born into this Culture. The Culture survives because the offspring keep repeating the process. The Emperor Penguins survive because the process seems to keep them safe from predators and close to mates. The culture and the species depend on each other.</p>

<p>- Cultures are borne out of randomness.</p>

<p>At any moment, people or animals are doing things that may blossom into a new culture. Some of these penguins could branch off to Hawaii and start a new set of habits, which 500 years from now might be the dominant culture of the Emperor Penguins.</p>

<p>But predicting what will develop into a culture and what won't is impossible--there's too many variables, too much randomness involved. Would anyone have predicted that these crazy penguins who went to breed in the -40 degree weather for 8 months would survive this long? Probably not. Would anyone have predicted that people would still pray to this Jesus guy 2,000 years later? Probably not.</p>

<p>- Cultures seem crazy to outsiders and are almost impossible to explain.</p>

<p>One widespread human culture is to always give an explanation for an event even when the true reason is just too complex or random to understand. The cultural habits are always easier to repeat and pass down then they are to explain.</p>

<p>I don't have any profound insights on culture, I just think it's fascinating and something not to read too much into---it helps us survive, but there's no greater meaning to it.</p>

<p>1. Interesting factet: there are apparently 38 colonies of Emperor Penguins in Antarctica.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//culture-and-complexity-.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-invention-of-free-will"><a href="#the-invention-of-free-will">The Invention of Free Will</a></h1>
<div class="scrollArticleDate">March 24, 2010 — </div>

<p><h3><em>Or..We Think we have Free Will because we only Observe One Path.</em></h3></p>

<p>"Dad, I finished my homework. Why?"</p>

<p>The father thinks for a moment. He realizes the answer involves explaining the state of the world prior to the child doing the homework. It involves explaining the complex probabilities that combined would calculate the odds the child was going to do the homework. And it likely involved explaining quantum mechanics.</p>

<p>The father shrugs and says "Because you have free will, and chose to do it."</p>

<p><b>Free Will was Born</b></p>

<p>Thus was born the notion of free will, a concept to explain why we have gone down certain paths when alternatives seemed perfectly plausible. We attribute the past to free will, and we attribute the unpredictability of the future to free will as well (i.e. "we haven't decided yet").</p>

<p><b>One little problem</b></p>

<p>The problem is, this is wrong. You never choose just one path to go down. In fact, you go down all the paths. The catch is you only get to observe one.</p>

<p>In one world the child did their homework. In another world, they didn't.</p>

<p>The child who did their homework will never encounter the child who didn't, but they both exist, albeit in different universes or dimensions. Both of them are left wondering why they "chose" the way they did. The reality is that they chose nothing. They're both just along for the ride.</p>

<p>Even the smug boy who says free will doesn't exist, is just one branch of the smug boy.</p>


<p>Notes</p>

<p>1. This all assumes, of course, that there are <a href="https://breckyunits.com/the-many-worlds-law.html">many worlds</a> and not just one.</p>
<p>2. Perhaps it is the case that many worlds and free will coexist, in that although we have no absolute control of the future, we can somehow affect the distribution of different paths?</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-invention-of-free-will.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="why-is-it-best-to-do-one-thing-really-really-well"><a href="#why-is-it-best-to-do-one-thing-really-really-well">Why is it best to do one thing really, really well?</a></h1>
<div class="scrollArticleDate">March 22, 2010 — </div>

<p>Google has a list of <a href="http://www.google.com/intl/en/corporate/tenthings.html">10 principles</a> that guide its actions. Number 2 on this list is:</p>

<p>> It's best to do one thing really, really well.</p>

<p>This advice is so often repeated that I thought it would be worthwhile to think hard about why this might be the case.</p>

<h3>Why is it best to do one thing really, really well?</h3>

<p>For two reasons: economies of scale and network effects.</p>

<p><b>Economies of scale</b>. The more you do something, the better you get at it. You can automate and innovate. You'll be able to solve the problem better than it's been solved in the past and please more people with your solutions. You'll discover tricks you'd never imagine that help you create and deliver a better "thing".</p>

<p><b>Network effects</b>. If you work on a hard problem for a long time, you'll put a great deal of distance between yourself and the average competitor, and in our economy it doesn't take too big a lead to dominate a market. If your product and marketing is 90% as good as the competitor's, it will capture much less than 47% of the market. The press likes to write about the #1 company in an industry. The gold medalist doesn't get 1/3 of the glory, they get 95% of the glory. The network effects in our economy are very strong. If you only do something really well, the company that does it really, really well will eat your lunch.</p>

<p>A simpler analogy: You can make Italian food and Chinese food in the same restaurant, but the Italian restaurant down the street will probably have better Italian food and the Chinese restaurant will probably have better Chinese food, and you'll be out of business soon.</p>

<h3>Why the <em>"really, really"</em>?</h3>

<p>My English teacher would have told me that at least one of the "really"'s was unneccessary. But if you think about the statement in terms of math having the two "really"'s makes sense. </p>

<p>Let's define doing one thing well as being in the top 10% of companies that do that thing.<br></p>
<p>Doing one thing really well means being in the top 1% of companies that do that thing.<br></p>
<p>Doing one thing really, really well means being in the top 0.1% of companies that do that thing.</p>

<p>Thus, what Google is striving for is to be the #1 company that does search. They don't want to just be in the top 10% or even top 1% of search companies, they want to do it so well that they are at the very top. If you think about it like that, the 2 "really's" make perfect sense.</p>

<h3>What's the most common mistake companies make when following this advice?</h3>

<p>My guess is they don't choose the correct "thing" for their given team. They pick the wrong thing to focus on. For instance, if Ben and I started a jellyfish business, and decided to do <a href="http://jellyfishart.com">jellyfish tanks</a> really, really well, we would be making a huge mistake because we just don't have the right team for that business. It makes more sense when <a href="http://www.jellyfishart.com/aboutus.asp">Al</a>, a marine biology major and highly skilled builder, decides to do jellyfish tanks really, really well.</p>

<p>It makes perfect sense for the Google founders to start Google since they were getting their PhD's in search.</p>

<p>You need good team/market fit. The biggest mistake people make when following the "do one thing really, really well" advice is choosing the wrong product or market for their team.</p>

<h3>What's the second most common mistake companies make when following this advice?</h3>

<p>Picking a "thing" that's too easy. You should go after a problem that's hard with a big market. Instead of writing custom software for ten of your neighbors that helps them do their taxes, generalize the problem and write internet software that can help anyone do their taxes. It's good to start small of course, but be in a market with a lot of room to grow.</p>

<h3>Can you change the one thing you do?</h3>

<p>Yes. It's good to be flexible until you stumble upon the one thing your team can do really, really well that can address a large market. Don't be stubborn. If at first you thought it was going to be social gaming, and then you learn that you can actually do photo sharing really, really well and people really want that, do photo sharing.</p>

<h3>How do you explain the fact that successful companies actually do a lot of different things?</h3>

<p>Microsoft Windows brings in something like $15 billion per year. Google Adwords brings in something like $15 billion per year. When you make that kind of money, you can drop $100 million selling ice cream and it won't hurt you too much. But to get there, you've first got to do one hard thing really, really well, whether it be operating systems or search.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//why-is-it-best-to-do-one-thing-really-really-well.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-hidden-benefits-of-automation"><a href="#the-hidden-benefits-of-automation">The Hidden Benefits of Automation</a></h1>
<div class="scrollArticleDate">March 17, 2010 — </div>

<p>If you automate a process which you repeat <em>Y</em> times, that takes <em>X</em> minutes, what would your payoff be?</p>

<p>Payoff = <em>XY</em> minutes saved, right?</p>

<p>Surprisingly I've found that is almost never the case. Instead, the benefits are almost always greater than <em>XY</em>. In some cases, much greater. The benefits of automating a process are greater than the sum of the process' parts.</p>

<p>Actual Payoff = <em>XY minutes saved + E</em></p>

<p>What is E? It's the extra something you get from not having to waste time and energy on XY.</p>

<p><h3>An Example</h3></p>

<p>Last year I did a fair amount of consulting work I found via craigslist. I used to check the Computer Gigs page for a few different cities, multiple times per day. I would check about 5 cities, spending about 2 minutes on each page, about 3 times per day. Thus, I'd spend 30 minutes a day just checking and evaluating potential leads.</p>

<p>I then wrote a script that aggregated all of these listings onto one page(including the contents so I didn't have to click to a new page to read a listing). It also highlighted a gig if it met a certain criteria that I had found to be promising. The script even automated a lot of the email response I would write to each potential client.</p>

<p>It cut my "searching time" down to about 10 minutes per day. But then something happened: I suddenly had more time and energy to focus on the <em>next aspect</em> of the problem: getting hired. It wasn't long before I was landing more than half the gigs I applied to, even as I raised my rates.</p>

<p>I think this is where the unexpected benefits come from. The E is the extra energy you'll have to focus on other problems once you don't have to spend so much time doing rote work.</p>

<p><h3>Automate. Automate. Automate</h3></p>

<p>Try to automate as much as possible. The great thing about automation is that once you automate one task you'll have more time to automate the next task. Automation is a great investment with compounding effects. Try to get a process down to as few steps or keystrokes as possible(your ideal goal is zero keystrokes). Every step you eliminate will pay off more than you think.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-hidden-benefits-of-automation.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="metrics-for-programmers"><a href="#metrics-for-programmers">Metrics for Programmers</a></h1>
<div class="scrollArticleDate">March 16, 2010 — </div>

<p>I wrote a simple php program called <a href="http://github.com/breck7/phpcodestat">phpcodestat</a> that computes some simple statistics for any given directory.</p>

<p>I think brevity in source code is almost always a good thing. I think as a rule your code base should grow logarithmically with your user base. It should not grow linearly and certainly not exponentially.</p>

<p>If your code base is growing faster than your user base, you're in trouble. You might be attacking the wrong problem. You might be letting feature creep get the past of you.</p>

<p>I thought it would be neat to compute some stats for popular open source PHP applications.</p>

<p>My results are below. I don't have any particular profound insights at the moment, but I thought I'd share my work as I'm doing it in the hopes that maybe someone else would find it useful.</p>

<p>
 <table><tr style="font-weight:bold;"><td>Name</td><td>Directories</td><td>Files</td><td>PHP Files</td><td>PHP LOC</td><td>PHP Classes</td><td>PHP Functions</td></tr>

 
 <tr>

 
 <td>../cake-1.2.6</td>

 
 <td>296</td>

 
 

 
 <td>677</td>

 
 <td>428</td>

 
 <td>165183</td>

 
 <td>746</td>

 
 <td>3675</td>

 
 </tr><tr>

 
 

 
 <td>../wordpress-2.9.2</td>

 
 <td>82</td>

 
 <td>753</td>

 
 <td>279</td>

 
 <td>143907</td>

 
 <td>149</td>

 
 

 
 <td>3827</td>

 
 </tr><tr>

 
 <td>../phpMyAdmin-3.3.1-english</td>

 
 <td>63</td>

 
 <td>810</td>

 
 <td>398</td>

 
 

 
 <td>175867</td>

 
 <td>44</td>

 
 <td>3635</td>

 
 </tr><tr>

 
 <td>../CodeIgniter_1.7.2</td>

 
 <td>44</td>

 
 

 
 <td>321</td>

 
 <td>136</td>

 
 <td>43157</td>

 
 <td>74</td>

 
 <td>1211</td>

 
 </tr><tr>

 
 

 
 <td>../Zend-1.10</td>

 
 <td>360</td>

 
 <td>2145</td>

 
 <td>1692</td>

 
 <td>336419</td>

 
 <td>42</td>

 
 

 
 <td>11123</td>

 
 </tr><tr>

 
 <td>../symfony-1.4.3</td>

 
 <td>770</td>

 
 <td>2905</td>

 
 <td>2091</td>

 
 

 
 <td>298700</td>

 
 <td>362</td>

 
 <td>12198</td>

 
 </tr></table>

 
</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//metrics-for-programmers.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="hackernews-data-visits-as-a-function-of-karma"><a href="#hackernews-data-visits-as-a-function-of-karma">HackerNews Data: Visits as a Function of Karma</a></h1>
<div class="scrollArticleDate">March 8, 2010 — </div>

<p>If a post on HackerNews gets more points, it gets more visits.</p>

<p>But how much more? That's what <a href="http://news.ycombinator.com/item?id=1175277">Murkin</a> wanted to know.</p>

<p>I've submitted over 10 articles from this site to HackerNews and I pulled the data from my top 5 posts (in terms of visits referred by HackerNews) from Google Analytics.</p>

<p>Here's how it looks if you plot visits by karma score:</p>

<p><img src="visits_by_karma.png"></p>

<p>The Pearson Correlation is high: 0.894.</p>

<p>Here's the raw data:</p>

<div class="scrollArticleCode">
<code> karma,visits,page</code>
<code> 53,3389,<a href="twelve-tips-to-master-programming-faster.html">/twelve_tips_to_master_programming_faster</a></code>
<code> 54,2075,<a href="/code/use_rsync_to_deploy_your_website">/code/use_rsync_to_deploy_your_website</a></code>
<code> 54,1688,<a href="unfeatures.html">/unfeatures</a></code>
<code> 34,1588,<a href="flee-the-bubble.html">/flee_the_bubble</a></code>
<code> 25,1462,<a href="make-something-40-of-your-customers-must-have.html">/make_something_40_of_your_customers_must_have</a></code>
<code> 14,1056,<a href="when-forced-to-wait-wait.html">/when_forced_to_wait_wait</a></code>
<code> 4,214,<a href="diversification-in-startups.html">/diversification_in_startups</a></code>
<code> 1,146,<a href="seo-made-easy-lumps.html">/seo_made_easy_lumps</a></code>
<code> 1,36,<a href="dont-flip-the-bozo-bit.html">/dont_flip_the_bozo_bit</a></code>
</div>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//hackernews-data-visits-as-a-function-of-karma.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="dont-talk-about-what-you-will-do-talk-about-what-you-have-done"><a href="#dont-talk-about-what-you-will-do-talk-about-what-you-have-done">Don't talk about what you will do, talk about what you have done</a></h1>
<div class="scrollArticleDate">February 19, 2010 — </div>

<p>All the time I overhear people saying things like "I will start excercising everyday" or "We will ship this software by the end of the month" or "I will read that book" or "I will win this race." I'm guilty of talking like this too.</p>

<p>The problem is that often, you say you will do something and you don't end up doing it. Saying "I will do", might even be a synonym for "I won't do".</p>

<p>Why does this happen? I don't think it's because people are lazy. I think it's because we overestimate our ability to predict the future. We like to make specific predictions as opposed to predicting ranges.</p>

<p>I'll explain why we are bad at making predictions in a minute, but first, if you find yourself making predictions about what you will do that turn out to be wrong, you should fix that. You can either tone down your predictions, giving ranges instead. For instance, instead of saying "I think I will win the race", say "I think I will finish the race in the top 10". Or, even easier: stop talking about things you <em>will do</em> entirely, and only talk about things you <em>have done</em>. So, in the race example, you might say something like "I ran 3 miles today to train for the race." (If you do win the race, don't talk about it a lot. No one likes a braggert).</p>

<h4>Why we are bad at making predictions.</h4>

<p>Pretend you are walking down a path:</p>

<p><img src="path1.png"></p>

<p>Someone asks you whether you've been walking on grass or dirt. You can look down and see what it is:</p>

<p><img src="path2.png"></p>

<p>Now, they ask you what you will be walking on. You can look ahead see what it is:</p>

<p><img src="path3.png"></p>

<p>Easy right? But this is not a realistic model of time. Let's add some fog:</p>

<p><img src="path4.png"></p>

<p>Again, someone asks you whether you've been walking on grass or dirt. Even with the fog, you can look down and see what it is:</p>

<p><img src="path5.png"></p>

<p>Now, they ask you what you will be walking on. You look ahead, but now with the fog you can't see what it is:</p>

<p><img src="path6.png"></p>

<p>What do you do? Do you say:</p>

<p>1. Dirt</p>
<p>2. Grass</p>
<p>3. I don't know. It could be either dirt or grass, or maybe something else entirely.</p>
<p>4. I don't know. I've been walking on grass. Not sure what I'll be walking on in the future.</p>

<p>In my opinion you should say something like C or D.</p>

<p>This second example models real life better. <em>The future is always foggy</em>.</p>

<h4>Why is the future foggy?</h4>

<p>I don't know. Maybe a physicist could answer that question, but I don't know the answer. And I don't think I ever will.</p>

<p>Notes</p>

<p>1. In other words, don't overpromise and underdeliver.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//dont-talk-about-what-you-will-do-talk-about-what-you-have-done.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="why-its-worth-it-to-buy-the-book"><a href="#why-its-worth-it-to-buy-the-book">Why it's worth it to buy the book</a></h1>
<div class="scrollArticleDate">February 17, 2010 — </div>

<p>If a book is worth reading, it's worth buying too.</p>

<p>If you're reading a book primarily to gain value from it(as opposed to reading it for pleasure) you should always buy it unless it's a bad book. </p>

<p>The amount of value you can get from a book varies wildly. Most books are worthless. Some can change your life. For simplicity, let's say the value you can derive from any one book varies from 1 cent to $100,000(there are many, many more worthless books than there are of the really valuable kind). </p>

<p>The <em>cost</em> however, does not vary as much. Books rarely cost more than $100, and generally average to about $15.</p>

<p>You shouldn't read a book that you think will offer you less than $100 in value. Time could be better spent reading more important books.</p>

<p>So let's assume you never read a book that gives you less than $100 in value. Thus, the cost of a physical copy of the book is at most 15% (using the $15 average price) of the value gained.</p>

<p>Would owning that book help you extract 15% more from it? It nearly always will. When you own a book, you can take it anywhere. You can mark it up. You can flip quickly through the pages. You can bookmark it. You can easily share it with a friend and then dicuss it. If these things don't help you get 15% more out of that book, I'd be very surprised.</p>

<p>Where it gets even more certain, is when you read a really valuable book--say a book offering $1,000 of value. Now you'd only need to get 1.5% more out of that book.</p>

<p>The investment in that case is a no brainer.</p>

<p><a href="/bookcost.png"><img src="bookcost.png" width="600" border="0"></a></p>

<p>Notes</p>

<p>1. Even if a book is more expensive, say $50, the numbers don't change too much.</p>
<p>2. Pardon my scribbling. Got a new toy.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//why-its-worth-it-to-buy-the-book.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-least-you-can-do"><a href="#the-least-you-can-do">The Least You Can Do</a></h1>
<div class="scrollArticleDate">February 2, 2010 — </div>

<p>My room was always messy. Usually because clothes were strewn everywhere On the floor, on the couch, anywhere there was a surface there was a pile of clothes. Dirty, clean, or mostly-clean scattered about. </p>

<p>I tried a dresser. I tried making a system where I had spaces for each type of clothing: shirts, pants, etc. Nothing worked.</p>

<p>Then a friend saw my room and quipped, "Duh. You have too many clothes. Let's get rid of most of them."</p>

<p>So we did. About 75% of my clothes were packed up in garbage bags and sent off to the Salvation Army that day.</p>

<p>Ever since, my room has been at least 5x cleaner on average.</p>

<p><blockquote></p>
<p>Almost always, there is one simple change you can make that will have <em>drastic</em> effects.</p>
<p>This change is called <strong>the least you can do</strong>.</blockquote></p>

<p>I had a website that was struggling to earn money even with a lot of visitors. I added AdSense and almost nothing happened. Then I moved the AdSense to a different part of the page and it suddenly made 5x more money. A week later I changed the colors of the ad and it suddenly made 2x as much money. Now the site makes 10x as much money and I barely did anything.</p>

<p>These are trivial examples, but the technique works on real problems as well.</p>

<p>The key is to figure out what the "least you can do" is.</p>

<p>You can discover it by working harder or smarter:</p>

<p>- <strong>The hard way.</strong> You can try a ton of things, go through a to-do list dozens of items long, and hope you hit upon it.</p>
<p>- <strong>The smart way.</strong> You can invest time learning instead of doing. Reading books, learning new math or programming techniques, talking to other people, thinking critically, etc. You'll then have a much better hunch at what the "least you can do is".</p>

<p>In reality you need to do things both ways. But try to put extra effort into doing things the smart way, and see where it takes you.</p>


<p>Notes</p>

<p>1. Thanks to <a href="http://massbeacon.com">Conor</a> for providing feedback.</p>
<p>2. I never shop for clothes. Once a year, maybe twice. The reason I had so many was because I never got rid of any clothes.</p>
<p>3. This AdSense site doesn't make a ton of money, but it now makes enough to pay all my server bills, which is nice.</p>
<p>4. Finding the least you can do is kind of like <a href="http://en.wikipedia.org/wiki/Diff">diff</a>. You are trying to find the smallest change you can make to turn the status quo into an improved version. </p>
<p>5. Another relevant computer science topics is the <a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem">The longest common subsequence problem</a>.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-least-you-can-do.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="four-tips-to-improve-communication"><a href="#four-tips-to-improve-communication">Four Tips to Improve Communication</a></h1>
<div class="scrollArticleDate">January 29, 2010 — </div>

<p>Good communication is overcommunication. Very few people overcommmunicate. Undercommunication is much more common. Undercommunication is also the cause of countless problems in business. </p>

<p>Instead of striving for some subjective "good communication", simply strive to overcommunicate. It's very unlikely you'll hit a point where people say "he communicates too much". It's much more likely you'll come up a bit short, in which case you'll be left with good communication.</p>

<p>Here are 4 tips that will bring you closer to overcommunicating:</p>

<p>1. <strong>Say the hard things</strong>. Often the hardest things to talk about are the most important things to talk about. If something is stressing you out, <em>just say it</em>. Getting it out there, even if not in the most eloquent way, is much better than not talking about it at all. A good strategy when approaching a hard subject is to bounce your approach off a neutral 3rd party to see if your angle is smart. Many times it's the other person who has something they're stressed about but isn't talking about. It's your job to be perceptive and ask them questions to get it out on the table.</p>
<p>2. <strong>Repeat yourself</strong>. People have bad memories and even worse attention spans. <a href="/with-computers-dont-repeat-yourself.-with-people-do-repeat-yourself.html">Repeat yourself</a>. If something is very important, repeat yourself multiple times. If someone hasn't gotten the message, it's more likely your fault for not repeating yourself enough than it is their fault for not getting it.</p>
<p>3. <strong>Use tools</strong>. Email, Facebook, Google Wave, Basecamp, Skype, Gchat, Dropbox, Github, Sifter...these are just a sample of the modern tools you can use to communicate. Embrace them. Try different ones. Try pen and paper and whiteboards. Ideally you'll find two or three tools that cover all the bases, but don't be afraid to use multiple tools even if you have to repeat yourself across them a bit.</p>
<p>4. <strong>Set a regular schedule</strong>. Set aside a recurring time for communication. It could be once a week or once a day. Even if there's nothing new to talk about, it will help to just go over the important topics again as you can rarely repeat yourself too much.</p>

<p>That's it. Good luck!</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//four-tips-to-improve-communication.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="network-effects"><a href="#network-effects">Network Effects</a></h1>
<div class="scrollArticleDate">January 22, 2010 — </div>

<p>Network effects are to entrepreneurs what compounding effects are to investors: a key to getting rich.</p>

<p>Sometimes a product becomes more valuable simply as more people use it. This means the product has a "network effect".</p>

<p>You're probably familiar with two famous examples of network effects:</p>

<p>- Windows. People started using Microsoft Windows. Therefore, developers started building more software for Windows. This made Windows more valuable, and more people started to use it.</p>
<p>- Facebook. People joined Facebook and invited their friends. Their friends joined which made the site more valuable to everyone. People invited more friends.</p>

<p>All businesses have network effects to some degree. Every time you buy a slice of pizza, you are giving that business some feedback and some revenue which they can use to improve their business.</p>

<p>Giant businesses took advantage of giant network effects. When you bought that pizza, you caused a very tiny network effect. But when you joined Facebook, you immediately made it a more valuable product for many other users(who could now share info with you), and you may even have invited a dozen more users. When a developer joins Facebook, they might make an application that improves the service for thousands or even millions of users, and brings in a similar number of new users.</p>

<p>The biggest businesses enabled user-to-user network effects. Only the pizza store can improve its own offering. But Facebook, Craiglist, Twitter, and Windows have enabled their customers and developers to all improve the product with extremely little involvement from the company.</p>

<p>Notes</p>

<p>1. This is probably easier said than done.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//network-effects.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="if-you-can-explain-something-logically-you-can-explain-it-simply"><a href="#if-you-can-explain-something-logically-you-can-explain-it-simply">If you can explain something logically, you can explain it simply</a></h1>
<div class="scrollArticleDate">January 18, 2010 — </div>

<p><em>1. Is there any subject which cannot be explained simply?</em></p>

<p>No.</p>

<p><em>2. What about quantum mechanics, organic chemistry, or rocket science? Surely these cannot be explained simply.</em></p>

<p>Any and every subject that can be explained logically, can also be explained simply.</p>

<p><em>3. So you are saying that even I can become an expert at quantum mechanics?</em></p>

<p>No. I am saying that every logical thing there is to learn in quantum mechanics can be explained simply. This holds for all subjects.</p>

<p>However, that does not mean that every person can master every subject. Only people that master the basic building blocks of human knowledge can master any subject.</p>

<p><em>4. What are the basic building blocks of human knowledge?</em></p>

<p>First, the ones you learn early on: reading, writing, and arithmetic. Then, a few you are not forced to learn: probability, statistics, evolution and psychology.</p>

<p><em>5. Why do I have to learn probability, statistics, evolution and psychology?</em></p>

<p>Because these subjects explain 99% of what you see in the world. You need to learn probability and statistics to understand subjects like chemistry, physics, and engineering. You need to understand evolution and psychology to understand subjects like history, economics, government and religion. You need to know probability and statistics to understand these latter subjects as well. Thus, probability and statistics is as core to learning as reading, writing, and arithmetic.</p>

<p><em>6. I took a prob/stat course in high school. Is that good enough?</em></p>

<p>Probably not. After you took your reading and writing classes in elementary school, did you stop reading and writing or did you start practicing these skills everyday? You continued to use and practice them, right? Did you continue to practice your prob/stat skills? You should.</p>

<p><em>7. You're wrong. I've mastered probability and statistics, evolution, and psychology, and there are still subjects I can't find simple explanations for.</em></p>

<p>I'm not wrong. You just need to look in the right places. You probably won't find simple explanations in school. Schools are in the business of making learning seem complex and expensive. Better places to search for simple explanations:</p>

<ul>
 <li>Online. Sites like <a href="http://www.khanacademy.org">Khan Academy</a>, <a href="http://www.ted.com/">Ted</a>, Wikipedia and Google.</li>
 <li>In books. Browse around Barnes & Noble or Borders.</li>
 <li>From a friend. Find someone that knows the subject well and ask them to teach you.</li>
</ul>

<p><em>8. Do I need to master the building blocks to be successful in life?</em></p>

<p>No. But you need to know them if you want to be able to learn any subject.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//if-you-can-explain-something-logically-you-can-explain-it-simply.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="with-computers-dont-repeat-yourself.-with-people-do-repeat-yourself"><a href="#with-computers-dont-repeat-yourself.-with-people-do-repeat-yourself">With Computers: Don't Repeat Yourself. With People: DO Repeat Yourself</a></h1>
<div class="scrollArticleDate">January 15, 2010 — </div>

<p>In computer programming, one of the most oft-repeated mottos is DRY: "Don't Repeat Yourself."</p>

<p>The downside of DRY's popularity is that programmers might start applying the principle to conversations with other humans. </p>

<p>This fails because computers and people are <em>polar opposites.</em> </p>

<p>With computers, you get zero benefit if you repeat yourself. With people, you get zero benefit if you <em>don't</em> repeat yourself!</p>


<h3>Four Ways Computers and People are Different</h3>
<p><ol></p>
<p><li><b>A computer's memory is perfect.</b> A computer forgets nothing. Tell it something once, and it will remember it forever. A human remembers almost nothing. I forget what I had for breakfast 2 days ago. I don't remember which people I talked to last week, nevermind what was said. If memory were cheese, a computer's would be cheddar and a human's would be swiss. You've got to repeat yourself when communicating with people because people forget.</li></p>
<p><li><b>A computer is always paying attention.</b> Computers are perfect listeners. They are always listening to your input and storing it in memory. You, the operator, are the only thing they care about. Computers don't have needs. They don't daydream or have cellphones(yet). People on the other hand, rarely if ever pay full attention. They zone in and out. It's hard to even tell if they're zoned in, as we've all learned it's better to nod our heads. People have their own needs and concerns and opinions. You've got to repeat yourself when communicating with people because people don't pay attention.</li></p>
<p><li><b>A computer understands your logic.</b> When you write a program, a computer never misunderstands. It will execute the program exactly as you typed it. People, however, do not communicate so flawlessly. Until I was 22 I used to think "hors d'oeuvres" meant dress nice. I did not understand the pronunciation. One time a friend emailed me about an event and said "Our place. Hors d'oeuvres. 7pm" and I responded "Awesome. Will there be food?" You've got to repeat yourself when communicating with people because people don't understand.</li></p>
<p><li><b>A computer doesn't need to know what's most important.</b> Computers don't make decisions on their own and so don't need to know what's most important. A computer will remember everything equally. Then it will sit awaiting your commands. It won't make decisions without you. A person, however, will make decisions without you and so needs to know the order of importance of things. For example, if you're not a fan of peanuts, you might tell the waiter once that you'd prefer the salad without nuts. But if you're deathly allergic to peanuts, you should probably repeat yourself a few times so the waiter knows there better not be any nuts on your salad. You've got to repeat yourself when communicating with people because people need to know what's most important.</li></ol></p>
<p><b>A Numeric Explanation</b></p>

<p>If you tell something to your computer once: </p>
<p><ul><li>The odds the computer remembers: 100%.</li></p>
<p><li>The odds the computer was paying attention: 100%.</li></p>
<p><li>The odds the computer understood you: 100%.</li></p>
<p><li>The odds the computer gets the importance right: 100%.</li></p>
<p></ul>If you tell something to a person once:</p>
<p><ul><li>The odds the person remembers: 30%?</li></p>
<p><li>The odds the person was paying attention: 40%?</li></p>
<p><li>The odds the person understood you: 50%?</li></p>
<p><li>The odds the person gets the importance right: 30%?</li></p>
<p></ul>In other words, the odds of communicating perfectly are very low: <b>1.8%</b>! You are highly likely to run into at least one of those four problems. </p>

<p>Now, if you repeat yourself 1 time, and we assume independence, here's how the probabilities change:</p>

<p><ul><li>The odds the person remembers: 51%</li></p>
<p><li>The odds the person was paying attention: 64%</li></p>
<p><li>The odds the person understood you: 75%</li></p>
<p><li>The odds the person gets the importance right: 51%</li></p>
<p></ul>By repeating yourself just once you've increased the chances of perfect communication from 1.8% to <b>12.5%</b>! Repeat yourself one more time and the probability of perfect communication increases to over 90%. Well, in this simplistic model anyway. But I hope you get the idea.</p>

<h3>Repeat yourself until you overcommunicate</h3>

<p>To communicate well you should try to <em>overcommunicate</em>.</p>

<p>Overcommunicating is hard to do. It's much easier and more common to undercommunicate.</p>

<p>If you're not repeating yourself a lot, you're not overcommunicating.</p>

<h3>An example of how I repeat myself</h3>

<p>On the various projects I'm involved with we use Gmail, Google Docs, Google Wave, Basecamp, Github, Sifter, gChat and Skype. Which one do I prefer?</p>

<p>None of them. I prefer pen, paper, whiteboards and face-to-face meetings. I write down my own todo list and schedule with pen and paper. Then I login to these sites and repeat what I've written down for the sake of repeating myself to other people. This isn't inefficieny, it's good communication. </p>

<p>Some people prefer Google Docs, some prefer Basecamp. I'll post things to both, to ensure everyone knows what I'm working on.</p>

<p>With every new project I repeat a lot of messages and questions to the team. "How many people love this product?", "How can we make this simpler?", "Which of the 7 deadly sins does this appeal to?". I think these are important questions and so I'll repeat them over and over and add them to the todo lists for every project, multiple times.</p>


<p>Notes</p>

<p>1. I've yet to be part of founding a big Internet company, so you don't have to agree with me that repeating yourself is critical to success.</p>

<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//with-computers-dont-repeat-yourself.-with-people-do-repeat-yourself.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="when-forced-to-wait-wait"><a href="#when-forced-to-wait-wait">When forced to wait, wait!</a></h1>
<div class="scrollArticleDate">January 14, 2010 — </div>

<p>When a problem you are working on forces you to wait, do you wait or switch tasks?</p>

<p>For example, if you are uploading a bunch of new web pages and it's taking a minute, do you almost instinctively open a new website or instant message?</p>

<p>I used to, and it made me less productive. I would try to squeeze more tasks into these short little idle periods, and as a result I would get less done.</p>

<h3>Multitasking during idle times <em>seems</em> smart</h3>

<p>Doing other things during idle times <em>seems</em> like it would increase productivity. After all, while you're waiting for something to load you're not getting anything done. So doing something else in the interim couldn't hurt, right? Wrong.</p>

<h3>Switching tasks during idle times is bad, very bad</h3>

<p>While you're solving one problem, you likely are "holding that problem in your head". It takes a while to load that problem in your head. You can only hold one important problem in your head at a time. If you switch tasks, even for a brief moment, you're going to need to spend X minutes "reloading" that problem for what is often only a 30 second vacation to Gmail, Facebook, Gchat, Hackernews, Digg, etc. It's clearly a bad deal.</p>

<h3>Don't multitask</h3>

<p>If you're doing something worth doing, give it all of your attention until it's done. Don't work on anything else, even if you're given idle time.</p>

<h3>Why you can't multitask well</h3>

<p>Human intelligence is overrated. Even the smartest people I know still occasionally misplace their keys or burn toast. We are good at following simple tasks when we focus, most of the time. But we are not built for multitasking.</p>

<p>Can you rub your head clockwise? Can you rub your belly counterclockwise? Can you say your ABC's backwards? </p>

<p>Dead simple, right? But can you do all three at once? If you can, by all means ignore my advice and go multitask.</p>

<h3>Wait out those idle times</h3>

<p>If what you are doing is easy or mundane, multitasking is permissible because loading a simple problem like "laundry" into your head does not take much time. But if what you are doing is <em>important and worth doing</em>, you are obligated to give it your full attention and to wait out those "idle times". </p>

<p>If you switch tasks during your idle times, you're implying that the time to reload the problem is less than the time gained doing something else. In other words, you are implying what you are doing is not worth doing. If that's the case, why work on it at all?</p>


<h3>Notes</h3>

<p>1. Influenced by Paul Graham's <a href="http://paulgraham.com/head.html">Holding a Program in One's Head</a></p>
<p>2. Of course, if you're given a very long idle time, then feel free to switch tasks. Don't spend 4 hours staring at your screen waiting for a coworker to get back to you.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//when-forced-to-wait-wait.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="how-to-buy-low-sell-high"><a href="#how-to-buy-low-sell-high">How to Buy Low, Sell High</a></h1>
<div class="scrollArticleDate">January 12, 2010 — </div>

<p>Whether you're an entrepreneur, a venture capitalist, a casual investor or just a shopper looking for a deal, you should know how to buy low and sell high. Buying low and selling high is not easy. It's not easy because it requires too things humans are notoriously bad at: long term planning and emotional control. But if done over a long period of time, buying low and selling high is a surefire way to get rich.</p>

<p>Warren Buffett is perhaps the king of buying low and selling high. These tips are largely regurgitated from his speeches and biographies which I've been reading over the past two years.</p>

<p><b>Let the market serve you, not instruct you.</b></p>

<p>Everything has both a price and a value. Price is what you pay for something, value is what you get. The two rarely match. Both can fluctuate wildly depending on a lot of things. For instance, the price of gas can double or triple in a year based on events in the Middle East, but the value of a gallon of gas to you largely remains constant. </p>

<p>Don't let the market ever tell you the value of something--don't let it instruct you. Your job is to start figuring out the intrinsic value of things. Then you can take advantage when the price is far out of whack with the true value of something--you can make the market serve you.</p>

<p>Google's price today is $187 Billion. But what's its value? <em>The average investor assumes the two are highly correlated</em>. Assume the correlation is closer to 0. Make a guess about the true value of something. You may be way off the mark in you value estimating abilities, but honing that skill is imperative.</p>

<p><b>Be frugal.</b></p>

<p>You've got to be in a position to take advantage of the market, and if you spend your cash on unnecessary things, you won't be. Buy food in bulk at Costco. Cut your cell phone bill or cancel it altogether. Trim the fat wherever you can. You'd be surprised how little you can live off of and be happy. Read <a href="http://www.gutenberg.org/etext/8581">P.T. Barnum's "The Art of Moneygetting"</a> for some good perspective on how being frugal has been a key to success for a long time.</p>

<p><b>Always be able to say "no".</b></p>

<p>The crazy market will constantly offer you "buy high, sell low" deals. You've got to be able to turn these down. If you don't have good cash flow or a cash cushion, it's very hard. That's why being frugal is so important.</p>

<p><b>Be Happy</b></p>

<p>If you're happy with what you have now it's easy to make good deals over the long run. Buying low and selling high requires long term emotional control. If you're unhappy or stressed, it's very hard to make clear headed decisions. Do what you have to do to get happy.</p>

<p><b>Make the Easy Deals</b></p>

<p>Out of the tens of thousands of potential deals you can make every month, which ones should you act on? The easy ones. Don't do deals in areas that you don't understand. Do deals where you know the area well. I wouldn't do a deal in commodities, but I'd certainly be willing to invest in early stage tech startups.</p>

<p><b>Margin of Safety</b></p>

<p>The easy deals have a wide margin of safety. An easy deal has a lot of upside. An easy deal with a wide margin of safety has little to no downside. Say a company has assets you determine are worth $1 Million and for some reason the company is selling for $950,000. Even if the company didn't grow, it has a good margin of safety because the price of its assets alone are worth more than the price you paid.</p>

<p><b>Read a lot</b></p>

<p>How do you find these easy deals? You've got to read a lot. You've got to keep your eyes open. Absorb and think mathematically about a lot of information you encounter in everyday life.</p>

<p><b>Buy a business</b></p>

<p>Businesses can be the ultimate thing to buy low and sell high because they have nearly unlimited upside. Real estate, gold, commodities, etc., can be good investments perhaps. But when's the last time you heard of someone's house going up 10,000%? Starting a business can be your best investment ever, as you are guaranteed to buy <em>extremely low</em>, and have the potential to sell <em>extremely high</em>.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//how-to-buy-low-sell-high.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="flee-the-bubble"><a href="#flee-the-bubble">Flee the Bubble</a></h1>
<div class="scrollArticleDate">January 5, 2010 — </div>

<p>Possibly the biggest mistake a web startup can make is to develop in a bubble. This is based on my own experience launching 13 different websites over the past 4 years.</p>

<p>The raw numbers:</p>
<p><style type="text/css">#fleebubble td{ border: 1px solid #d2d2d2;}</style><table id="fleebubble" cellspacing="0" cellpadding="5px"> <tr><td></td><td>Total #</td><td># of Successes</td><td>Average time to Beta Launch</td><td>Cumulative Gross Revenues</td><td>% of Total Traffic(to all my sites over this period)</td><td>Cumulative Profits</td><td>Emotional Toll</td></tr> <tr><td>Bubble</td><td>3</td><td>0</td><td>Months</td><td><$5,000</td><td><1%</td><td>-$10,000's</td><td>High</td></tr> <tr><td>Nonbubble</td><td>10</td><td>5-8</td><td>Days-2 weeks</td><td>$100,000's</td><td>>99%</td><td>Good</td><td>None-low</td></tr> </table></p>
<p><br><br></p>
<p><b>What is "the bubble"?</b></p>

<p>The bubble is the early, early product development stage. When new people aren't constantly using and falling in love with your product, you're in the bubble. You want to get out of here as fast as possible.</p>

<p>If you haven't launched, you're probably in the bubble. If you're in "stealth mode", you're probably in the bubble. If you're not "launching early and often", you're probably in the bubble. If you're not regularly talking to users/customers, you're probably in the bubble. If there's not a steady uptick in the number of users in love with your product, you're probably in the bubble.</p>

<p><b>Why you secretly want to stay in the bubble</b></p>

<p>A part of you always wants to stay in the bubble because leaving is <em>scary</em>. Launching a product and having it flop hurts. You hesitate for the same reason you hesitate before jumping into a pool in New England: sure, sometimes they're heated, but most of the time they're frickin freezing. If the reception to your product is cold, if no one falls in love with it, it's going to hurt.</p>

<p><b>The danger of the bubble</b></p>

<p>You can stand at the edge of the pool for as long as you want, but you're just wasting time. Life is too short to waste time.</p>

<p>In addition to wasting time, money and energy in the bubble (which can seem like a huge waste if your product flops), two things happen the longer you stay in the bubble:</p>

<p>- The marginal return of each additional unit of effort decreases.</p>
<p>- Expectations increase.</p>

<p>This is a very bad combination that can lead to paralysis. The more you pour into your bubble product, the less impact your additional efforts will have yet at the same time the more you will expect your product to succeed.</p>

<p>Don't wait any longer: jump in the water, flee the bubble!</p>

<p><b>How to Flee the Bubble</b></p>

<p>Here are four easy strategies for leaving the bubble: launch, launch & drop, pick one & launch, or drop.</p>

<p><b>Launch</b>. Post your product to your blog today. Email your mailing list. Submit it to Reddit or Hackernews or TechCrunch. Just get it out there and see what happens. Maybe it will be a success.</p>

<p><b>Launch & Drop</b>. Maybe you'll launch it and the feedback will be bad. Look for promising use cases and tweak your product to better fit those. If the feedback is still bad, drop the product and be thankful for the experience you've gained. Move on to the next one.</p>

<p><b>Pick One & Launch</b>. If you're product has been in the bubble too long, chances are it's bloated. Pick one simple feature and launch that. You might be able to code it from scratch in a day or two since you've spent so much time already working on the problem.</p>

<p><b>Drop</b>. Ideas are for dating not marrying. Don't ever feel bad for dropping an idea when new data suggests it's not best to keep pursuing it. It's a sign of intelligence.</p>

<p>That's all I've got. But don't take it from me, read the writings of web entrepreneurs who have achieved more success. (And please share what you find or your own experiences on HackerNews).</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//flee-the-bubble.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="checklist-for-new-products"><a href="#checklist-for-new-products">Checklist for New Products</a></h1>
<div class="scrollArticleDate">December 28, 2009 — </div>

<p>At <a href="http://bigorangehousestudios.com/">our startup</a>, we've practiced a <a href="https://breckyunits.com/diversification-in-startups.html">diversification strategy</a>.</p>

<p>We've basically run an idea lab, where we've built around 7 different products. Now we're getting ready to double down on one of these ideas.</p>

<p>The question is, which one?</p>

<p>Here's a 10 question form that you can fill out for each of your products.</p>

<p><h2>Product Checklist</h2></p>
<p>1. How many users/customers does the product have? <input value="#" size="6"></p>

<p>2. What percentage of these users/customers would be disappointed if this product disappeared tomorrow? <input value="%" size="6"> </p>

<p>3. Explain the product in one sentence: <input size="40"></p>

<p>4. Is the product good/honest? <input type="checkbox"> Yes</p>

<p>5. What is the predicted customer acquisition cost? $<input size="6"></p>

<p>6. What is the predicted average lifetime value per customer? $<input size="6"></p>

<p>7. Which of the 7 deadly sins does the product appeal to? <input type="checkbox"> Lust <input type="checkbox"> Greed <input type="checkbox"> Sloth <input type="checkbox"> Gluttony <input type="checkbox"> Pride <input type="checkbox"> Envy <input type="checkbox"> Wrath</p>

<p>8. What's the go to market strategy in one sentence? <input size="40"></p>

<p>9. What resources do you need to do this? <input size="40"></p>

<p>10. What's the total addressable market size? <input size="6"> people $<input size="6"></p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//checklist-for-new-products.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="diversification-in-startups"><a href="#diversification-in-startups">Diversification in Startups</a></h1>
<div class="scrollArticleDate">December 24, 2009 — </div>

<p>Over the past 6 months, our startup has taken two approaches to diversification. We initially tried no diversification and then we tried heavy diversification.</p>

<p>In brief, my advice is:</p>

<p><blockquote>Diversify heavily early. Then focus.</blockquote></p>

<p>In the early stages of your startup, put no more than 33% of your resources into any one idea. When you've hit upon an idea that you're excited about and that has product/market fit, then switch and put 80% or more of your resources into that idea.</p>

<h3>How Startups Diversify</h3>

<p>An investor diversifies when they put money into different investments. For example, an investor might put some money into stocks, some into bonds, and some into commodities. If one of these investments nosedives, you won't lose all your money. Also, you have better odds that you'll pick some investments that generate good returns. The downside is that although you reduce the odds of getting a terrible outcome, you also reduce the odds of getting a great outcome.</p>

<p>A startup diversifies when it puts resources into different products. For example, a web startup might develop a search engine and an email service at the same time and hope that one does very well. </p>

<h3>The 4 Benefits of Diversification for Startups</h3>

<p>There are 4 main benefits to diversify:</p>

<p>1. <b>Better odds</b>. Creating multiple products increases the odds of finding a great idea in a great market. The Internet provides very fast feedback about whether you've found one. After building your team, the next big thing to decide is what product to focus on. You should not choose one until you're built a product you're excited about and found product/market fit. You've found <a href="https://breckyunits.com/make-something-40-of-your-customers-must-have.html">product/market fit</a> when about 40% of your customers think your product is a must have. </p>

<p>2. <b>Builds individual skills</b>. Entrepreneurs need broad skillsets. Trying multiple products forces you to learn new skills. You may build a consumer video site and improve your technical scaling skills while at the same time be trying a B2B site and improving your sales skills.</p>

<p>3. <b>Builds team skills</b>. Doing multiple products gives you plenty of opportunities to interact with your team in varied situations. You'll learn faster what your teammates' strengths and weaknesses are. You'll also be forced to improve your team communication, coordination, delegation and product management skills.</p>

<p>4. <b>It's fun</b>. Let's be honest, the early stages of working on a new problem or idea are oftentimes the most stimulating and exciting. Instead of focusing on one product day in and day out that might or might not work, trying multiple ideas keeps your brain going and your enthusiasm high.</p>

<h3>When to Focus</h3>

<p>If diversifying has so many benefits, should you ever stop? Yes, you should.</p>

<p><blockquote>Focus when you are ready to make money.</blockquote></p>

<p>Coming up with new ideas and building new, simple products is the easy part of startups. Unfortunately, developing new solutions is <em>not</em> what creates a lot of value for other people. Bringing your solution to other people is when most value is created--and exchanged. </p>

<p>Imagine you're a telecom company and you build a fiber optic network on the streets of every city in America--but fail to connect people's homes to the new system. Although connecting each home can be hard and tedious, without this step no value is created and no money will come your way.</p>

<p>When you hear the phrase "execution is everything", this is what it refers to. If you want to make money, and you've got a great team and found product/market fit, you've then got to focus and execute. Drop your other products and hunker down. Fix all the bugs in your main product. Really get to know your customers. Identify your markets and the order in which you'll go after them. Hire great people that have skills you are going to need.</p>

<h3>Benefits of Focusing</h3>

<p>Let's recap the benefits of focusing.</p>

<p>1. <b>Money</b>. Creating new products in the early days is fun, but making money is fun too. Once you start focusing on growing one product, the money incentive will keep you motivated and spirits high.</p>

<p>2. <b>Rewarding</b>. Creating value for other people is perhaps the most rewarding feeling in life. Finding people with a problem, and getting your solution which solves their problem into their hands, is even better than the money you earn. You'll also create valuable jobs for your employees. </p>

<p>3. <b>Resources</b>. If you execute well, you'll end up with resources that you can use to put diversification back into the picture. For instance, after bringing better search to almost the whole world, Google can now diversify and create better email systems, web browsers, maps, etc.</p>

<h3>Benefits of the "Diversify Early, Then Focus" approach: A Roulette Analogy</h3>

<p>When you first begin your startup it's very similar to playing roulette. You plunk down some resources on an idea and then the wheel spins and you win more money or lose the money that you bet.</p>

<p>In roulette, you can bet it all on one number(focusing) or bet a smaller amount on multiple numbers(diversifying). If you bet it all on one number and win, you get paid a lot more money. But you're also more likely to lose it all.</p>

<p>The "game of startups" though, has two very important differences:</p>

<p>1. You get more information after the game starts "spinning".</p>
<p>2. You can always move your bets around.</p>

<p>You get way more information about the odds of an idea "hitting the jackpot" after you plunked some time and money into it. You may find customers don't really have as big a problem as you thought. Or that the market that has this problem is much smaller than you thought. You may find one idea you thought was silly actually solves a big problem for people and is wildly popular.</p>

<p>You can then adjust your bets. If your new info leads you to believe that this idea has a much higher chance of hitting the jackpot, grab your resources from the other ideas and plunk them all down on this one. Or vice versa.</p>

<h3>Don't Take My Word for It</h3>

<p>Sadly I bet there are paperboys who's businesses have done better than all mine to date, so take my advice with a grain of salt.</p>

<p>But if you want to learn more, I suggest reading the early histories of companies such as eBay, Twitter, and Facebook and see what their founders were up to before they founded those sites and in the following early period.</p>

<p>And check back here, I'll hopefully be sharing how this approached worked for us.</p>

<p>Notes</p>

<p>1. Fun tidbit: I wrote this on paper then typed it up and posted it all while flying on Virgin Air from SFO back to Boston. Thanks for the free wifi Google!</p>
<p>2. Thanks to <a href="http://www.benzulauf.com">Ben</a> for helping me form my ideas on this issue.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//diversification-in-startups.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="thoughts-on-setting-goals"><a href="#thoughts-on-setting-goals">Thoughts on Setting Goals</a></h1>
<div class="scrollArticleDate">December 23, 2009 — </div>

<p>It is better to set small, meaningful goals than to set wild, audacious goals.</p>

<p>Here's one way to set goals:</p>

<p><blockquote>Make them good. Make them small.</blockquote></p>

<p><b>Make them Good</b></p>

<p>Good goals create value. Some examples:</p>

<p>- Make a customer smile.</p>
<p>- Teach someone math.</p>
<p>- Learn how to cook.</p>
<p>- Organize weather information.</p>

<p><b>Make them Small</b></p>

<p>Start small. It is better to set one or two goals per time period than to set two dozen goals. Instead of a goal like "get 1,000,000 people to your website", start with a smaller goal like "get 10 people to your website."</p>

<p>If you exceed a goal and still think it's a good thing, raise the goal an order of magnitude. If you get those 10 visitors, aim for 100.</p>

<p><b>Why Small Goals Are Better</b></p>

<p>Setting smaller goals is better because:</p>

<p>- It feels good when you exceed a goal. Occasionally you'll wildly exceed a goal and that will feel great.</p>
<p>- It's better to do a few small good things, than to fail trying one audacious thing. </p>
<p>- It's easier to accomplish an audacious thing by going one step(order of magnitude) at a time.</p>
<p>- It's less stressful and makes you happier. Low expectations are good because in most cases you will exceed them and feel happy. High expectations, by definition, are bad because in most cases you will not meet them and feel bad. </p>
<p>- Goals are arbitrary anyway. All goals are simply arbitrary constraints that help you focus--often with a team--to get stuff done. So since they're arbitrary, and as long as they're good goals, might as well make them simpler and easier.</p>

<p><b>Setting Ranges</b></p>

<p>Another way to set goals is to use ranges. Set a low bar and a high bar. For example, your weekly goals might be:</p>

<p><table><tr><td>Low Bar</td><td>High Bar</td></tr><tr><td></p>
<p>- Get 2 new customers<br></p>
<p>- Implement 2 product improvements<br></p>
<p>- Write 1 blog post</td><td></p>
<p>- Get 7 new customers<br></p>
<p>- Implement 4 product improvements<br></p>
<p>- Write 3 blog posts</td></tr></table></p>

<p>If you exceed your low bar, you can be happy. If you exceed your high bar, you can be very happy. </p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//thoughts-on-setting-goals.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="problems-worth-solving"><a href="#problems-worth-solving">Problems Worth Solving</a></h1>
<div class="scrollArticleDate">December 20, 2009 — </div>

<p>Programming, ultimately, is about solving problems. Often I make the mistake of judging a programmer's work by the elegance of the code. Although the solution is important, what's even more important is the problem being solved.</p>

<p>Problems are not all created equal, so while programming you should occasionally ask yourself, "is this problem worth solving?"</p>

<p>Here's one rubric you can use to test whether a problem is worth solving:</p>

<p>1. <b>Simplicity.</b> Can you envision a simple solution to the problem? Can you create at least a partial, meaningful solution or prototype in a short period of time? Building a flying car would solve a lot of my transportation problems, but I don't see a simple path to getting there. Don't be too far ahead of your time. Focus on more immediate problems.</p>

<p>2. <b>Value.</b> Would solving this problem create value? Sometimes it's hard to predict in advance whether or not your solution would create value for people. The easiest way to tell if you've succeeded is if anyone would be disappointed if your solution were to disappear. If you can get a first prototype into people's hands early, you'll find out quickly whether or not you are building a solution to a problem that creates value.</p>

<p>3. <b>Reach.</b> Do a lot of people have this problem? Some problems, like searching for information, are shared by nearly everyone. Others, like online version control, are shared by a much smaller niche but still a significant amount of people. If a problem is shared by only a handful of people, it's probably not worth programming a solution.</p>

<h3>Great Programmers Solve Important Problems</h3>

<p>The best programmers aren't simply the ones that write the best solutions: they're the ones that solve the best problems. The best programmers write kernels that allow billions of people to run other software, write highly reliable code that puts astronauts into space, write crawlers and indexers that organize the world's information. They make the right choices not only about how to solve a problem, but what problem to solve.</p>

<h3>Life is Short</h3>

<p>Life is too short to solve unimportant problems. If you want to solve important problems, it's now or never. The greatest programmers only get to solve a relatively small amount of truly important problems. The sooner you get started working on those, the better.</p>

<h3>Ignore Speed Limits</h3>

<p>If you don't have the skills yet to solve important problems, reach out to those who do. To solve important problems, you need to develop a strong skill set. But you can do this much faster than you think. If you commit to solving important problems and then reach out to more committed programmers than you, I'm sure you'll find many of them willing to help speed you along your learning curve.</p>

<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//problems-worth-solving.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="make-something-40-of-your-customers-must-have"><a href="#make-something-40-of-your-customers-must-have">Make Something 40% of Your Customers Must Have</a></h1>
<div class="scrollArticleDate">December 16, 2009 — </div>

<p>If you combine Paul Graham's "make something people want" advice with Sean Ellis' <a href="http://venturehacks.com/articles/sean-ellis-interview">product-market fit advice</a> (you have product-market fit when you survey your users and at least 40% of them would be disappointed if your product disappeared tomorrow), you end up with a possibly even simpler, more specific piece of advice:</p>

<p><blockquote><em><span style="font-size: 1.4em;">Make something 40% of your users must have</span></em></blockquote></p>

<p>Your steps are then: </p>

<p>1. Make something people want. </p>
<p>2. Put it out there. </p>
<p>3. Survey your users. If less than 40% would be disappointed if your product disappeared, go back to step 1.</p>

<p>Only when you hit that 40% number(or something in that range) should you be comfortable that you've really made something people want.</p>

<p>Does this advice work? I think it would for 3 reasons.</p>

<h3>#1 The Sources</h3>

<p>PG and Sean Ellis know what they're talking about.</p>

<h3>#2 Companies that make my "Must Haves" are successful</b></h3>

<p>I made a list of my "must have" products and they are all largely successful. I suggest you try this too. It's a good exercise.</p>

<p>My List of Must Haves:</p>

<ul>
 <li>Google Search</li>
 <li>Facebook</li>
 <li>Gmail</li>
 <li>Dropbox</li>
 <li>craigslist</li>
 <li>Windows</li>
 <li>Excel</li>
 <li>Twitter Search</li>
 <li>Firefox</li>
 <li>Chrome</li>
 <li>Wikipedia</li>
 <li>Amazon</li>
</ul>

<ul>
 <li>(More Technical Products)</li>
 <li>Git + Github</li>
 <li>LAMP Stack</li>
 <li>Ruby</li>
 <li>Notepad++</li>
 <li>Vim</li>
 <li>jQuery</li>
 <li>Firebug</li>
 <li>Web Developers Extension</li>
 <li>StackOverflow</li>
 <li>TechCrunch</li>
 <li>HackerNews</li>
 <li>Navicat</li>
</ul>

<h3>#3 The Only "Must Have" Product I Built was the Biggest Success</h3>

<p>I've worked on a number of products over the past 3 years. </p>

<p>One of them I can tell you had a "I'd be disappointed if this disappeared" rate of over 40%. We sold that site.</p>

<p>All the others did not have that same "must-have" rate. We launched Jobpic this summer at Demo Day. People definitely wanted it. But we didn't get good product/market fit. If we had surveyed our users, I bet less than 10% of them would report being disappointed if Jobpic disappeared. Our options are to change the product to achieve better product/market fit, or go forward with an entirely new product that will be a must have. </p>

<h3>Concluding thoughts</h3>

<p>I don't know if this advice will work. But I'm going to try it.</p>

<p>Startup advice can be both exhilarating and demoralizing. </p>

<p>On the plus side, good advice can drastically help you. At the same time, if it's really good advice that means two things:</p>

<p>1. This is how you should be doing things.</p>
<p>2. You were not doing things this way.</p>

<p>That can frustrating. I've spent a few years now in the space and to realize you've been doing certain things wrong for a few <em>years</em> is...well...painful.</p>

<p>But you laugh it off and keep chugging along. </p>


<h3>Notes</h3>

<p>1. Thanks Nivi for the great Venture Hacks interview!</p>
<p>2. Users/Customers refer to people who use your site regularly or buy from you. This is not "visitors". Generally a much lower percentage than 40% of visitors become users or customers. The 40% refers to the people who have made it through your funnel and have become users or customers.</p>
<p>3. I used customers and users interchangeably. For non-tech businesses, you can just use "customer" each time.</p>
<p>4. Thanks to <a href="http://www.bigorangehousestudios.com">Ben</a>, <a href="http://www.jellyfishart.com">Alex Andon</a>, and <a href="http://andrewkitchell.blogspot.com/">Andrew Kitchell</a> for feedback.</p>

<p>Links</p>

<p>1. Another piece of startup advice that didn't "click" until recently: Roelof Botha's <a href="http://www.techcrunch.com/2009/11/18/good-question-the-eight-best-questions-we-got-while-raising-venture-capital/">7 deadly sins advice</a>.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//make-something-40-of-your-customers-must-have.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="seo-made-easy-lumps"><a href="#seo-made-easy-lumps">SEO Made Easy: LUMPS</a></h1>
<div class="scrollArticleDate">December 15, 2009 — </div>

<p>The best Search Engine Optimization(SEO) system I've come across comes from Dennis Goedegebuure, SEO manager at eBay. Dennis' system is called LUMPS. It makes SEO dead simple.</p>

<p>Just remember LUMPS:</p>

<p><b>L</b> inks<br></p>
<p><b>U</b> urls<br></p>
<p><b>M</b> etadata<br></p>
<p><b>P</b> age Content<br></p>
<p><b>S</b> itemaps<br></p>

<p>These are the things you need to focus on in order to improve your SEO. You should also, of course, first know what terms you want to rank highly for. </p>

<p>LUMPS is listed in order of importance to search engines. So links are most important, sitemaps are least important.</p>

<p>Let's break each one down a bit more.</p>

<p><b>Links.</b> </p>

<p>External links--links from domains other than your own--are most important. For external links, focus on 3 things, again listed in order of importance:</p>

<p>1. Quality. A link from CNN.com is worth <a href="/orders-of-magnitude.html">order(s) of magnitude</a> more than a link from my blog. A link from a related source, like from ESPN.com to a sports blog, would likely be better than from an unrelated source.</p>
<p>2. Quantity. Even though quality is most important, a lot of inbound links help.</p>
<p>3. Anchor Text. You want links with relevant anchor text. <a href="http://www.jellyfishart.com">Jellyfish tanks</a> is better than <a href="http://www.jellyfishart.com">click here</a>.</blockquote></p>

<p>Your internal link structure is also important. Make sure your site repeatedly links to the pages you are optimizing for.</p>

<p>External links are the most important thing you need for SEO. Internal links you can easily control, but it takes time to accumulate a lot of quality external links. Focus on creating quality content(or even better, build a User Generated Content site). People will link to interesting content.</p>

<p><b>URL Structure</b></p>

<p>The terms you are optimizing for should be in your urls. It's even better if they are in your domain. For instance, if I'm optimizing for "breck yunits", I've done a good job by having the domain name breckyunits.com. If I'm optimizing for the term "seo made easy", ideally I'd have that domain. But I don't, so having breckyunits.com/seo_made_easy is the next best thing. </p>

<p>Luckily, URL Structure is not just important, it's also relatively easy to do well and you can generally set up friendly URLs in an hour or so. I could explain how to do it with .htaccess and so forth, but there are plenty of articles out there with more details on that.</p>

<p><b>Metadata Content</b></p>

<p>Your TITLE tags and META DESCRIPTIONS tags are important for 2 reasons. First, search engines will use the content in them to rank your pages. Second, when a user sees a search results page, the title and description tags are what the user sees. You need good copy that will increase the Click Through Rate. Think of your title and description tags as the Link Text and Description in an AdWords ad. Just as you'd optimize the AdWords ad, you need to optimize this "seo ad". Make the copy compelling and clear.</p>

<p>Like URL structure, you can generally set up a system that generates good meta and description tags relatively easily.</p>

<p><b>Page Content</b></p>

<p>Content is king. If you've got the other 3 things taken care of and you have great content, you're golden. Not only will great content please your visitors, but it will likely be keyword rich which helps with SEO. Most importantly, it is much easier to get links to valuable, interesting content than to bad content. Figure out a way to get great content and the whole SEO process will work a lot better.</p>

<p><b>Sitemaps</b></p>

<p>Sitemaps are not the most crucial thing you can do, but they help and are an easy thing to check off your list. Use Google Webmaster tools and follow all recommendations and submit links to your sitemaps.</p>

<p><b>Summary</b></p>

<p>There you have it, SEO made easy! Just remember LUMPS.</p>


<p>Links</p>

<p>1. <a href="http://www.google.com/webmasters/tools/">Google Webmaster Tools</a>.</p>
<p>2. <a href="http://www.seobook.com/">SEO Book</a> - one of the best SEO sites out there.</p>
<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//seo-made-easy-lumps.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="dont-flip-the-bozo-bit"><a href="#dont-flip-the-bozo-bit">Don't Flip the Bozo Bit</a></h1>
<div class="scrollArticleDate">December 13, 2009 — </div>

<p>Do you "flip the bozo bit" on people? </p>

<p>If you don't know what that means, you probably do it unknowingly!</p>

<h3>What it means</h3>

<p>When you "flip the bozo bit" on someone you ignore everything they say or do. You flip the bozo bit on a person when they are wrong or make a mistake over and over again. Usually you flip the bozo bit unconsciously.</p>

<h3>An example</h3>

<p>You are writing a program with Bob. Bob constantly writes buggy code. You get frustrated by Bob's bugs and slowly start ignoring all the code he submits and start writing everything yourself. You've flipped the bozo bit!</p>

<p>This is bad for everyone. Now you are doing more work, and Bob is becoming resentful because you are ignoring his ideas and work.</p>

<h3>Alternatives to Flipping the Bozo Bit</h3>

<p>Instead of flipping the bozo bit, perhaps you could work with another person. If that's not possible, take a more constructive approach:</p>

<p>1. <b>Teach</b>. Talk to Bob and figure out why he is making repeated mistakes. We all have large gaps in our education. If you've never been exposed to a concept, there's no reason why you should understand it. Try and find what it is Bob hasn't been exposed to yet, and help him learn it. </p>
<p>2. <b>Change Roles</b>. Maybe Bob should be working in another area. Find an area where you're the bozo and Bob's the expert. Let him work in that area, while you work in your area. He can even explain a thing or two to you.</p>

<h3>Why We Flip the Bozo Bit</h3>

<p>It seems like a simple evolutionary trick to save time. If someone is right only 10% of the time, would it be faster to ignore every statement they made, or faster to analyze each statement carefully in case it's the 1 out of 10 statements that might be true? Seems like it would be faster to just ignore everything by flipping the bozo bit.</p>

<p>But this is a bad solution. The two presented above are better.</p>

<p>Notes</p>

<p>1. Thanks to Tom Price for telling me about this.</p>

<p>Links</p>

<p>1. <a href="http://en.wikipedia.org/wiki/Bozo_bit">Bozo bit</a> on Wikipedia.</p>
<p>2. <a href="http://www.amazon.com/gp/product/0735623198?ie=UTF8&tag=smartyounginv-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=07356231988">Origin of the term?</a></p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//dont-flip-the-bozo-bit.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="unfeatures"><a href="#unfeatures">(un)features</a></h1>
<div class="scrollArticleDate">December 11, 2009 — </div>

<p>Jason Fried from 37signals gave a great talk at startup school last month. At one point he said "software has no edges." He took a normal, everyday bottle of water and pointed out 3 features:</p>

<p>1. The bottle held the water.</p>
<p>2. The lightweight plastic made it easy to carry, and you can tell how full it was by picking it up.</p>
<p>3. The clear bottle let you see how much was left and what was in it.</p>

<p>If you added a funnel to help pour the water, that might be useful in 5% of cases, but it would look a little funny. Then imagine you attach a paper towel to each funnel for when you spill. Your simple water bottle is now a monstrosity. </p>

<p>The clear edges of physical products make it much harder for feature creep to happen. But in software feature creep happens, and happens a lot.</p>

<h3>A proposal to fight feature creep</h3>

<p>How do you fight feature creep in software? Here's an idea: do not put each new feature request or idea on a to-do list. Instead, put them on an (un)features list.</p>

<p>An (un)features list is a list of features you've consciously decided not to implement. It's a well maintained list of things that might seem cool, but would detract from the core product. You thought about implementing each one, but after careful consideration decided it should be an (un)feature and not a feature. Your (un)features list will also include features you built, but were only used by 1% of your customers. You can "deadpool" these features to the (un)features list. Your (un)features list should get as much thought, if not more, than your features list. It should almost certainly be bigger.</p>

<p>When you have an idea or receive a feature request, there's a physical, OCD-like urge to do something with it. Now, instead of building it or putting it on a todo list, you can simply write it down on your (un)features list, and be done with it. Then maybe your water bottles will look more like water bottles.</p>

<p>This blog is powered by software with an <a href="http://github.com/breck7/brecksblog">(un)features list</a>.</p>

<p>Notes</p>

<p>1. Feel free to move an (un)feature to your features list if you change your mind about it.</p>

<p>Links</p>

<p>- Some more <a href="http://gaborcselle.posterous.com/the-best-quotes-from-startup-school">great quotes</a> from this year's <a href="http://startupschool.org/">startup school</a>.</p>
<p>- <a href="http://37signals.com">37signals</a> and their great <a href="http://37signals.com/svn/">blog</a>.</p>


<p>Edit: 01/05/2010</p>
<p>Features are a great <a href="http://evhead.com/search?updated-max=2006-12-15T14:47:00-08:00&max-results=7">way to make money</a>.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//unfeatures.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="get-stuff-done-by-setting-arbitrary-constraints"><a href="#get-stuff-done-by-setting-arbitrary-constraints">Get Stuff Done By Setting Arbitrary Constraints</a></h1>
<div class="scrollArticleDate">December 10, 2009 — </div>

<p>Employees and students receive deadlines, due dates, goals, guidelines, instructions and milestones from their bosses and teachers. I call these "arbitrary constraints". </p>

<p>Does it really matter if you learn about the American Revolution by Friday? No. Is there a good reason why you must increase your sales this month by 10%, versus say 5% or 15%? No. Does it really matter if you get a 4.0 GPA? No.</p>

<p>But these constraints are valuable, despite the fact that they are arbitrary. <em>They help you get things done</em>. </p>

<h3>Constraints Help You Focus</h3>

<p>Constraints, whether meaningful or not, simplify things and help you focus. We are simple creatures. Even the smartest amongst us need simple directions: green means go, red means stop, yellow means step on it. Even if April 15th is an arbitrary day to have your tax return filed, it is a simple constraint that gets people acting.</p>

<h3>Successful People Constantly Set Constraints</h3>

<p>Successful people are good at getting things done. They focus well. Oftentimes they focus on relatively meaningless constraints. But they meet those constraints, however arbitrary. By meeting a lot of constraints, in the long run they hit enough of those non-arbitrary constraints to achieve success. Google is known for it's "OKR's"--objectives and key results--basically a set of arbitrary constraints that each employee sets and tries to hit.</p>

<h3>Entrepreneurs Must Set Their Own Constraints</h3>

<p>If you start a company, there are no teachers or bosses to set these constraints for you. This is a blessing and a curse. It's a blessing because you get to choose constraints that are more meaningful to you and your interests. It's a curse because if you don't set these constraints, you can get fuddled. Being unfocused, <em>at times</em>, can be very beneficial. Having unfocused time is a great way to learn new things and come up with new ideas. However, to get things done you need to be focused. And the first step to get focused is to set some arbitrary constraints.</p>

<h3>A Specific Example</h3>

<p>Here are some specific constraints I set in the past week:</p>

<p>1. Write 1 blog post per day.</p>
<p>2. Create blogging software in under 100 lines of code.</p>
<p>3. Have version 0.2 of blogging software done by 5pm yesterday.</p>

<p>All of these are mostly arbitrary. And I have not met all of them. But setting them has helped me focus.</p>

<h3>When You Don't Meet Your Constraints</h3>

<p>If you don't meet your constraints, it's no big deal. They're largely arbitrary anyway. Even by just trying to meet your constraints, you learn a lot more. You are forced to think critically about what you are doing. </p>

<p>When you don't meet some constraints, set new ones. Because you now have more experience, the new ones might be less arbitrary.</p>

<p>But the important thing is just having constraints in the first place.</p>


<p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//get-stuff-done-by-setting-arbitrary-constraints.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="why-you-shouldnt-save-blogging-for-old-age"><a href="#why-you-shouldnt-save-blogging-for-old-age">Why You Shouldn't Save Blogging for Old Age</a></h1>
<div class="scrollArticleDate">December 9, 2009 — </div>

<p>A lot of people have the idea that maybe one day they'll become rich and famous and then write a book about it. That's probably because it seems like the first thing people do after becoming rich and famous is write a book about it. </p>

<p>But you don't have to wait until you're rich and famous to write a book about your experiences and ideas.</p>

<p><blockquote>"A few months ago I was talking to another MBA student, a very talented man, about 30 years old from a great school with a great resume. I asked him what he wanted to do for his career, and he replied that he wanted to go into a particular field, but thought he should work for McKinsey for a few years first to add to his resume. <b>To me that's like saving sex for your old age</b>. It makes no sense." - Warren Buffet</p>
<p></blockquote></p>

<p>Likewise, saving blogging for your old age makes no sense. There are two selfless reasons why you should start blogging now:</p>

<p>1. You may enlighten someone.</p>
<p>2. Sharing your experiences adds another data point to our collective knowledge and makes us all better off.</p>

<p>It used to take a lot of work to publish something. Now it is simpler than brushing your teeth. So publish, write, blog!</p>

<p>If you need some selfish reasons, here are 5:</p>

<p>1. Writing is good excercise for the brain and gives you "writer's high".</p>
<p>2. Blogging makes you a better writer.</p>
<p>3. When your blog gets traffic, it stokes your ego.</p>
<p>4. You may spark interesting conversations with interesting people.</p>
<p>5. In rare circumstances, you may make money.</p>

<p>Blogging. Don't save it for your old age.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//why-you-shouldnt-save-blogging-for-old-age.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="6-specific-ways-to-find-programming-mentors"><a href="#6-specific-ways-to-find-programming-mentors">6 Specific Ways to Find Programming Mentors</a></h1>
<div class="scrollArticleDate">December 8, 2009 — </div>

<p>Finding experienced mentors and peers might be the most important thing you can do if you want to become a great programmer. They will tell you what books to read, explain the pros and cons of different languages, demystify anything that seems to you like "magic", help you when you get in a jam, work alongside you to produce great things people want, and challenge you to reach new heights.  </p>

<p>Great coders travel in packs, just like great authors.  </p>

<p>If you want to reach the skills of a Linus, Blake, Joe, Paul, David, etc., you have to build yourself a group of peers and mentors that will instruct, inspire, and challenge.  </p>

<p>Here are 6 specific tips to do that.  </p>

<p>1. <b>Get a programming job</b>. This is probably the best thing you can do. You'll get paid to "practice". You'll work on things that will challenge you and help you grow. And you'll have peers who will provide instruction and motivation constantly. There are tens of thousands of open programming jobs right now. Even if you feel you are not qualified for one, apply anyway, and stress how you are smart, passionate, and the experience will come with time. If you don't get a programming job today, you can reapply in 6 months or 1 year when you have better skills. Here are six job sites to check out: Craigslist (<a href="http://sfbay.craigslist.org/cpg/">Computer Gigs</a>, <a href="http://sfbay.craigslist.org/eng/">Internet Engineers</a>, <a href="http://sfbay.craigslist.org/sof/">Software</a>, <a href="http://sfbay.craigslist.org/sad/">Systems</a>, <a href="http://sfbay.craigslist.org/web/">Web Design</a>) <a href="http://jobs.stackoverflow.com/">StackOverflow</a>, <a href="http://www.crunchboard.com/jobs/">CrunchBoard</a>, <a href="http://news.ycombinator.com/jobs">HackerNews</a>, <a href="http://www.redditjobs.com/">Reddit</a>, <a href="http://startuply.com/">Startuply</a>.   </p>

<p>2. <b>Take a programming class</b>. My best tutors are my peers. People who I took a class or two with in college. We knew each other when computers were a big mystery to us, so we don't feel embarassed when we ask questions that may sound dumb. If you're currently in college, enroll in a programming class. Otherwise, look at local colleges' continuing education programs, community colleges, or professional classes. If you're in San Francisco, maybe look at <a href="http://www.academyx.com/">AcademyX</a>. Give <a href="http://unclasses.com"> unclasses.com</a> a try. If you think classes cost too much, don't use that as an excuse until you've tried to negogiate a deal. Often someone will give you a class for free or greatly reduced price simply by explaining your situation. Other times maybe you can offer a service in return.  </p>

<p>3. <b>Attend a Meetup</b>. I go to PHP and MySQL meetups frequently. <a href="http://www.meetup.com">Meetup.com</a> has thousands of programming meetups throughout the country. Go to one. Every month. You'll learn from the speaker, you'll meet other programmers, and you'll meet recruiters who will try to hire you if you still haven't gotten that job.  </p>

<p>4. <b>Join Github</b>. <a href="http://github.com">Github</a> is the first <em>user friendly</em> collaborative development site for programmers. Once you get comfortable with it, you could be working alongside other programmers on open source projects in no time. I'll write a better tutorial on how to get started soon, but for now, just join and explore around. It may take you a month or two to "get it", so don't feel overwhelmed if you don't understand what's going on at first. You will eventually. And you'll start to find some great programmers to talk to.  </p>

<p>5. <b>Email Someone Directly</b>. Email has been around for 35 years and it's still the favorite mode of communication for programmers. If you like someone's work, send them an email and ask for 1 or 2 tips. I've found when I email great programmers, their responses are usually short and to the point. That's not because they don't want to help, it's just that they're busy and use time effectively. Keep your emails brief and specific and they can be of great aid.  </p>

<p>6. <b>Enlist a Friend</b>. If you excercise with someone else, you burn 50% more calories on average. Likewise, if you learn programming with a friend, you'll learn 50% faster. That's a significant time savings. It's also more fun. You must have a friend who has a similar interest as you in programming. Why not suggest that you get serious about learning it together?   </p>

<p>Hopefully you'll find some of these tips useful. Feel free to email me if you need a first mentor (breck7 at google's email service). I'm not very good yet, but I may be able to help.   </p>

<p>Notes</p>

<p>1. That exercise percentage is a guess, but sounds right to me.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//6-specific-ways-to-find-programming-mentors.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="orders-of-magnitude"><a href="#orders-of-magnitude">Orders of Magnitude</a></h1>
<div class="scrollArticleDate">December 7, 2009 — </div>

<p>Do you think in Orders of Magnitude? You should.</p>

<p>If you think in orders of magnitude you can quickly visualize how big a number is and how much effort it would take to reach it.</p>

<p>Orders of magnitude is a way of grouping numbers. The numbers 5, 8 and 11 are all in the same order of magnitude. The numbers 95, 98 and 109 are in the same order of magnitude as well, but their order of magnitude is one order of magnitude greater than 5, 8, 11.</p>

<p>Basically, if you multiple a number by 10, you raise it one order of magnitude. If you've ever seen the scary looking notation 5x10^2, just take the number five and raise it 2 orders of magnitude (to 500).</p>

<p>Think of orders of magnitude as rough approximations. If you want the number 50 to be in the same order of magnitude as the number 10, you can say that "it's roughly in the same order of magnitude" or that "it's about half an order of magnitude bigger". Don't worry about being exact. </p>

<p>Orders of magnitude is a great system because generally there's a huge difference between 2 numbers in different orders of magnitude. Thus to cross from one order of magnitude to the next, a different type of effort is required than to simply increment a number. For example, if you run 2 miles each day and then decide to run one more, 3 total, it should be easy. But if you decided to run one more order of magnitude, 20 miles, it would take a totally new kind of effort. You'd have to train longer, eat differently, and so forth. To go from 2 to 3 requires a simple approach, just increase what you're doing a bit. To go from 2 to 20, to increase by an order of magnitude, requires a totally different kind of effort.</p>

<h3>A Business Example</h3>

<p>Let's do a business example. </p>

<p>Pretend you started a business delivering pizza. Today you have five customers, make 5 pizzas a week, and earn $50 revenue per week. </p>

<p>You can keep doing what you're doing and slowly raise that to 6 customers, then 7 and so on. Or you can ask yourself, "How can I increase my business an order of magnitude?" </p>

<p>Going from 5 to 50 will take a different type of effort than just going from 5 to 6. You may start advertising or you might create a "Refer a Customer, get a free pizza" promotion. You might have to hire a cook. Maybe lower your price by $2. </p>

<p>Imagine you do all those things and now have 50 customers. How do you get to 500? </p>

<p>Now you might need a few employees, television advertisements, etc. </p>

<p><em>Growing a business is the process of focusing like a laser on the steps needed to reach the next order of magnitude. </em></p>

<p>Here are some more examples of orders of magnitude if it's still not clear:</p>

<p>Bill Gates has approximately $50,000,000,000. Warren Buffett has $40,000,000,000. For Warren to match Bill, he merely has to make a few more great investments and hope Microsoft's stock price doesn't go up. He does not have to increase his wealth an order of magnitude. I on the other hand, have $5 (it was a good month). For me to become as rich as BillG, I have to increase my wealth 10 orders of magnitude. That means that I'd have 10 different types of hard challenges to overcome to match BillG's wealth.</p>

<ul>
 <li>Going from $5 to $50 may mean just working a bit and could be accomplished in a day.</li>
 <li>Going from $50 to $500 would mean working a few days.</li>
 <li>Going from $500 to $5,000 might mean getting a job that pays more.</li>
 <li>Going from $5,000 to $50,000 would mean getting a job that pays more, saving more, and doing that for a longer period.</li>
 <li>Going from $50,000 to $500,000 might mean doing all that, plus making some good investments.</li>
 <li>... and so forth.</li>
</ul>

<ul>
 <li>If your room is 200 square feet, the world is 13 orders of magnitude greater than your room.</li>
 <li>Google indexes 10,000,000,000 pages. This site is 10 pages. There are 9 orders of magnitude more pages in the Google Index.</li>
 <li>Facebook has 350 million users. Dropbox has 3 million. Facebook has 2 orders of magnitude more users.</li>
 <li>The population of California is about 35 million. The population of the US is one order of magnitude bigger, about 300 million. The population of China is about 4 times that of the U.S. at 1,300,000, which is less than an order of magnitude difference.</li>
 <li>Shaq is about 1 order of magnitude taller than a newborn, but besides that height is much more narrowly distributed. Everyone is within the same order of magnitude tall.</li>
</ul>

<p>Links</p>

<p><a href="http://www.wolframalpha.com">WolframAlpha</a></p>

<p>Thanks to Mairi and <a href="http://www.30words.com">Andrew Kitchell</a> for providing feedback.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//orders-of-magnitude.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="the-many-worlds-law"><a href="#the-many-worlds-law">The Many Worlds Law</a></h1>
<div class="scrollArticleDate">December 6, 2009 — </div>

<p>Imagine you are eating dinner with 9 friends and you all agree to play Credit Card Roulette. Credit Card Roulette is a game where everyone puts their credit card in a pile and the server randomly chooses one and charges the whole meal to it.</p>

<p>Imagine you are playing this game with your own friends. Pause for a second and picture it happening. </p>

<p>...</p>

<p>What did you see?</p>

<p>I bet you saw one person's card get picked and that person was sad and everyone else laughed.</p>

<p>Wrong!</p>

<p>This is <em>not what really happened</em>! In reality, despite the fact that you observed only one's person card getting picked, in reality <em>everyone's card got chosen</em>. </p>

<p>In reality, when you played the game, the world split into 10 paths, and every person's card got picked in one of those paths. You only observed one path, but trust me, there were 9 others. </p>

<p>This is a simple example of the many worlds law. You probably were not taught the many worlds law in school, which is a shame. It's one of the most important laws in the world. </p>


<p>Notes</p>

<p>1. I love this game because I don't have a credit card</p>
<p>2. You can benefit greatly from understanding the many worlds law. Take solace in the fact that somewhere out there you won the lottery and are drinking a pina colada on your private island right now. </p>
<p>3. The many worlds law could very well be wrong. There could be just 1 world. There could be 42. I don't think about that much. There may be no god, but betting there is one has benefits.</p>
<p>4. I called it the many worlds "law" because I don't want to use the word theory or hypothesis. Theory and hypothesis are too linked in people's minds with uncertainty, and some ideas, like evolution and many worlds, have way too much supporting evidence to leave any room for uncertainty, in as much as we can be uncertain about something. </p>
<p>5. One of the most important laws in most worlds, anyway.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//the-many-worlds-law.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="twelve-tips-to-master-programming-faster"><a href="#twelve-tips-to-master-programming-faster">Twelve Tips to Master Programming Faster</a></h1>
<div class="scrollArticleDate">December 4, 2009 — </div>

<p>Do you want to become a great coder? Do you have a <b>passion</b> for computers but not a thorough understanding of them? If so, this post is for you. </p>

<h3>Saying #1: 10,000 Hours</h3>

<p>There is a saying that it takes 10,000 hours of doing something to master it. </p>

<p>So, to master programming, it might take you 10,000 hours of being actively coding or thinking about coding. That translates to a consistent effort spread out over a number of years.</p>

<h3>Saying #2: No Speed Limit</h3>

<p>There is another saying that I just <a href="http://sivers.org/kimo">read</a>, which inspired me to write this, that says "there is no speed limit".</p>

<p>In that post, Derek Sivers claims that a talented and generous guy named Kimo Williams taught him 2 years worth of music theory in five lessons. I have been learning to program for 2 years, and despite the fact that I've made great progress, my process has been slow and inefficient. </p>

<p>I did not have a Kimo Williams. But now that I know a bit, I'll try and emulate him and help you learn faster by sharing my top 12 lessons.</p>

<p>I'll provide the tips first, then if you're curious, a little bit more history about my own process.</p>

<h3>The 12 Tips</h3>

<p>1. <b>Get started</b>. Do not feel bad that you are not an expert programmer yet. In 10,000 hours, you will be. All you need to do is start. Dedicate some time each day or week to checking things off this list. You can take as long as you want or move as fast as you want. If you've decided to become a great programmer, youve already accomplished the hardest part: planting the seed. Now you just have to add time and your skills will blossom. If you need any help with any of these steps, feel free to email me and Ill do my best to help.</p>

<p>2. <b>Dont worry</b>. Do not be intimated by how much you dont understand. Computers are still largely magic even to me. We all know that computers are fundamentally about 1s and 0s, but what the hell does that really mean? It took me a long time to figure it out--it has something to do with voltages and transistors. There are endless topics in computer science and endless terms that you won't understand. But if you stick with it, eventually almost everything will be demystified. So don't waste time or get stressed worrying about what you don't know. It will come, trust me. Remember, every great programmer at one time had NO IDEA what assembly was, or a compiler, or a pointer, or a class, or a closure, or a transistor. Many of them still dont! That's part of the fun of this subject--you'll always be learning.</p>

<p>3. <b>Silicon Valley</b>. Simply by moving to Silicon Valley, you have at least: 10x as many programmers to talk to, 10x as many programming job opportunities, 10x as many programming meetups, and so on. You don't have to do this, but it will make you move much faster. The first year of my programming career was in Boston. The second year was in San Francisco. I have learned at a much faster pace my second year.</p>

<p>4. <b>Read books</b>. In December of 2007 I spent a few hundred dollars on programming books. I bought like 20 of them because I had no idea where to begin. I felt guilty spending so much money on books back then. Looking back, it was worth it hundreds of times over. You will read and learn more from a good $30 paperback book than dozens of free blogs. I could probably explain why, but its not even worth it. The data is so very clear from my experience that trying to explain why it is that way is like trying to explain why pizza tastes better than broccoli: Im sure there are reasons but just try pizza and you'll agree with me.</p>

<p>5. <b>Get mentors</b>. I used to create websites for small businesses. Sometimes my clients would want something I didnt know how to do, simple things back then like forms. I used to search Google for the answers, and if I couldnt find them, I'd panic! Dont do that. When you get in over your head, ping mentors. They dont mind, trust me. Something that youll spend 5 hours panicking to learn will take them 2 minutes to explain to you. If you dont know any good coders, feel free to use me as your first mentor.</p>

<p>6. <b>Object Oriented</b>. This is the "language" the world codes in. Just as businessmen communicate primarily in English, coders communicate primarily in Object Oriented terms. Terms like classes and instances and inheritance. They were completely, completely, completely foreign and scary to me. Theyd make me sick to my stomach. Then I read a good book(Object Oriented PHP, Peter Lavin), and slowly practiced the techniques, and now I totally get it. Now I can communicate and work with other programmers.</p>

<p>7. <b>Publish code</b>. If you keep a private journal and write the sentence The car green is, you may keep writing that hundreds of times without realizing its bad grammar, until you happen to come upon the correct way of doing things. If you write that in an email, someone will instantly correctly you and you probably won't make the mistake again. You can speed up your learning <em>1-2 orders of magnitude</em> by sharing your work with others. Its embarrassing to make mistakes, but the only way to become great is to trudge through foul smelling swamp of embarrassment.</p>

<p>8. <b>Use github</b>. The term version control used to scare the hell out of me. Heck, it still can be pretty cryptic. But version control is crucial to becoming a great programmer. Every other developer uses it, and you can't become a great programmer by coding alone, so you'll have to start using it. Luckily, you're learning during an ideal time. Github has made learning and using version control much easier. Also, Dropbox is a great tool that your mom could use and yet that has some of the powerful sharing and version control features of something like git.</p>

<p>9. <b>Treat yourself</b>. Build things you think are cool. Build stuff you want to use. Its more fun to work on something you are interested in. Programming is like cooking, you don't know if what you make is good until you taste it. If something you cook tastes like dog food, how will you know unless you taste it? Build things you are going to consume yourself and you'll be more interested in making it taste not like dog food. </p>

<p>10. <b>Write English</b>. Code is surprisingly more like English than like math. Great code is easy to read. In great code functions, files, classes and variables are named well. Comments, when needed, are concise and helpful. In great code the language and vocabulary is not elitist: it is easy for the layman to understand. </p>

<p>11. <b>Be prolific</b>. You dont paint the Mona Lisa by spending 5 years working on 1 piece. You create the Mona Lisa by painting 1000 different works, one of them eventually happens to be the Mona Lisa. Write web apps, iPhone apps, Javascript apps, desktop apps, command line tools: as many things as you want. Start a small new project every week or even every day. You eventually have to strike a balance between quantity and quality, but when you are young the goal should be quantity. Quality will come in time. </p>

<p>12. <b>Learn Linux</b>. The command line is not user friendly. It will take time and lots of repetition to learn it. But again, its what the world uses, you'll need at least a basic grasp of the command line to become a great programmer. When you get good at the command line, its actually pretty damn cool. Youll appreciate how much of what we depend on today was written over the course of a few decades. And youll be amazed at how much you can do from the command line. If you use Windows, get CYGWIN! I just found it a few months ago, and it is much easier and faster than running virtualized Linux instances.</p>

<p><b>That's it, go get started!</b> </p>

<p>Actually, I'll give you one bonus tip:</p>

<p>13. <b>Contact me</b>. My email address is breck7 at Google's mail service. Feel free to ping me for personal help along your journey, and I'll do my best to lend a hand.</p>



<h3>My Story, briefly</h3>

<p>Two years ago, in December 2007, I decided to become a great programmer. Before then, I had probably spent under 1,000 hours "coding". From 1996 to 2007, age 12 to age 23, I spent around 1,000 hours "coding" simple things like websites, MSDOS bat scripts, simple php functions, and "hello world" type programs for an Introduction to Computer Science class. Despite the fact that I have always had an enormous fascination with computers, and spent a ton of time using them, I was <em>completely clueless</em> about how they worked and how to really program.</p>

<p>(If you're wondering why didn't I start coding seriously until I was 23 and out of college there's a simple and probably common reason: the whole time I was in school my goal was to be cool, and programming does not make you cool. Had I known I would never be cool anyway, I probably would have started coding sooner.)</p>

<p>Finally in December 2007 I decided to make programming my career and #1 hobby. Since then I estimate I've spent 20-50 hours per week either coding or practicing. By practicing I mean reading books about computers and code, thinking about coding, talking to others, and all other related activities that are not actually writing code.</p>

<p>That means I've spent between 2,000-5,000 hours developing my skills. Hopefully, by reading these tips, you can move much faster than I have over the past 2 years.</p>


<p>Links</p>

<ul>
 <li><a href="http://github.com">Github</a></li>
 <li><a href="http://dropbox.com">Dropbox</a></li>
 <li><a href="http://stackoverflow.com">Stackoverflow</a> - when you need help, and eventually where you can give help</li>
 <li><a href="http://www.cygwin.com/">Cygwin</a></li>
</ul>



<h3>Notes</h3>

<p>1. The saying that it takes 10,000 hours to master something may or may not be true but is indisputably popular (which is often an attribute of true ideas).</p>
<p>2. I added the quotes around "coding" when describing my past experience because it was simple stuff, and it felt funny funny calling it coding just as it would sound funny calling a 5 year old's work "writing". </p>
<p>3. I still have a long way to go to become a "great programmer", 2-4 more years I'd say.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//twelve-tips-to-master-programming-faster.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="whats-linear-algebra"><a href="#whats-linear-algebra">What's Linear Algebra?</a></h1>
<div class="scrollArticleDate">December 3, 2009 — </div>

<p>What would happen if instead of writing about subjects you understood, you wrote about subjects you didn't understand? Let's find out!</p>

<p>Today's topic is linear algebra. I know almost nothing about vectors, matrices, and linear algebra.</p>

<p>I did not take a Linear Algebra course in college. Multivariable calculus may have done a chapter on vectors, but I only remember the very basics: it's a size with a direction, or something like that.</p>

<p>I went to a Borders once specifically to find a good book to teach myself linear algebra with. I even bought one that I thought was the most entertaining of the bunch. Trust me, it's far from entertaining. Haven't made it much further than page 10.</p>

<p>I bet vectors, matrices, and linear algebra are important. In fact, I'm <em>positive</em> they are. But I don't know why. I don't know how to apply linear algreba in everyday life, or if that's something you even do with linear algebra.</p>

<p>I use lots of math throughout the day such as:</p>

<p>- Addition/subtraction when paying for things</p>
<p>- Multiplication when cooking for 6 roommates</p>
<p>- Probability when deciding whether to buy cell phone insurance</p>
<p>- Calculus when thinking about the distance needed to break fast while biking</p>
<p>- Exponents and logs when analyzing traffic graphs and programming</p>

<p>But I have no idea when I should be using vectors, matrices, and other linear algebra concepts throughout the day.</p>

<p>There are lots of books that teach <em>how</em> to do linear algebra. But are there any that explain <em>why</em>?</p>

<p>Would everyone benefit from linear algebra just as everyone would benefit from knowing probability theory? Would I benefit? </p>

<p>I don't know the answer to these questions. Fooled by Randomness revealed to me why probability is so incredibly important and inspired me to master it. Is there a similar book like that for linear algebra?</p>

<p>I guess when you write about what you don't know, you write mostly questions.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//whats-linear-algebra.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="fiction-or-nonfiction"><a href="#fiction-or-nonfiction">Fiction or Nonfiction?</a></h1>
<div class="scrollArticleDate">December 2, 2009 — </div>

<p>What books have changed your life? Seriously, pause for a few minutes and think about the question. I'll share my list in a moment, but first come up with yours.</p>


<p>Do you have your list yet? Writing it down may help. Try to write down 10 books that you think have most impacted your life. </p>

<p>Take all the time you need before moving on.</p>

<p>Are you done yet? Don't cheat. Write it down then continue reading.</p>



<p>Okay, at this point I'm assuming you've followed instructions and wrote down your list of 10 books. </p>

<p>Now you have one more step. To the right of each book title, write "fiction" or "nonfiction". You can use the abbreviations "F" and "NF" if you wish.</p>

<p>You should now have a list that looks something like mine:</p>

<ul>
 <li>How to Read a Book - NF</li>
 <li>Never Eat Alone - NF</li>
 <li>Fooled by Randomness - NF</li>
 <li>How to Win Friends and Influence People - NF</li>
 <li>Snowball - NF</li>
 <li>Influence - NF</li>
 <li>Object Oriented PHP - NF</li>
 <li>Life of Pi - F</li>
 <li>Lord of the Flies - F</li>
 <li>The Illiad - F</li>
</ul>

<p>Now, count the NF's. How many do you have? I have 7. So 7 out of the 10 books that I think have most impacted my life are non-fiction. Therefore, if I have to guess whether the next book I read that greatly impacts my life will be fiction or nonfiction, my guess is it will be nonfiction. </p>

<p>What's your list? Do you think the next book that will greatly impact your life will be fiction or non-fiction?</p>

<p>Share your results <a href="http://news.ycombinator.com/item?id=973741">here</a>.</p>


<h3>Notes:</h3>

<p>1. I read about equal amounts fiction and nonfiction. So on average, I get greater return from nonfiction reading.</p>
<p>2. Reading fiction is a more enjoyable form of entertainment.</p>
<p>3. This essay is in response to a <a href="http://news.ycombinator.com/item?id=917566">comment</a> I read a while back on HackerNews that got me thinking about the subject.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//fiction-or-nonfiction.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="experience-is-what-you-get"><a href="#experience-is-what-you-get">Experience is What You Get</a></h1>
<div class="scrollArticleDate">December 2, 2009 — </div>

<p>...when you don't get what you want.</p>

<p>How many times have you struggled towards a goal only to come up short? How many times have bad things happened to you that you wish hadn't happened? If you're like me, the answer to both of those is: a lot.</p>

<p>But luckily you always get something when you don't get what you want. You get experience. Experience is data. When accumulated and analyzed, it can be incredibly valuable.</p>

<p>To be successful in life you need to have good things happen to you. Some people call this "good luck". Luck is a confusing term. It was created by people who don't think clearly. Forget about the term "luck". There is not "good luck" and "bad luck". Instead, "good things happen", and "bad things happen". Your life is a constant bombardment of things happening, good and bad. Occasionally, despite making bad decisions steadily, some people have good things happen to them. But in most cases to have good things happen to you, you've got to make a steady stream of good decisions.</p>

<p>You've got to see patterns in the world and recognize cause and effect. You've got to think through your actions and foresee how each action you take will affect the chances of "good things happening" versus "bad things happening" down the line. </p>

<p>When you're fresh out of the gate, it's hard to make those predictions. You just don't have any data so you can't analyze cause and effect appropriately. But once you're out there attempting things, even if you screw up or don't get what you want, you get experience. You get data to use to make better decisions in the future.</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//experience-is-what-you-get.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="im-back"><a href="#im-back">I'm Back</a></h1>
<div class="scrollArticleDate">December 2, 2009 — </div>

<p>Decided to blog again. I missed it. Writing publicly, even when you only get 3 readers, two of which are bots and the other is your relative, is to the mind what exercise is to the body. It's fun and feels good; especially when you haven't done it in a while.</p>

<p>Also decided to go old school. No Wordpress or Tumblr, Blogger or Posterous. Instead, I'm writing this on pen and paper. Later I'll type it into HTML using Notepad++, vim, or equivalent(EDIT: after writing this I coded my own, simple blogging software called <a href="http://github.com/breck7/brecksblog">brecksblog</a>). It will just be text and links. Commenting works better on <a href="http://news.ycombinator.com">hackernews</a>, <a href="http://digg.com">digg</a>, or <a href="http://reddit.com">reddit</a> anyway. </p>

<p>Hopefully these steps will result in better content. Pen and paper make writing easier and more enjoyable, so hopefully I'll produce more. And the process of typing should serve as a filter. If something sucks, I won't take the time to type it.</p>

<p>I'm writing to get better at communicating, thinking, and just for fun. If anyone finds value in these posts, that's an added bonus.</p>

<p>Written 11/30/2009</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//im-back.scroll">Article source</a></p></div>
   <div class="scrollArticleCell"><h1 id="about-me"><a href="#about-me">About Me</a></h1>

<p>This is my personal <a href="https://github.com/treenotation/dumbdown/tree/master/scroll">Scroll</a>. I am a software engineer, data science and probability enthusiast, programming language tinkerer, data curator, angel investor, husband and father.</p>

<p>You can find me on <a href="https://github.com/breck7">github</a> or contact me via email. breck7 at google's awesome mail service.</p>

<p>If you could do me one favor, please take a moment to think about whether we should have Imaginary Property Laws. I believe every child deserves access to the world's best information. I hope you do too. #EndImaginaryProperty #AbolishCopyright #AbolishPatents</p><p class="scrollArticleSourceLink"><a href="https://github.com/breck7/breckyunits.com/blob/main//about.scroll">Article source</a></p></div>
</div>
</div>
 <div class="scrollChrome scrollIcons">
  <a href="mailto:breck7@gmail.com"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Gmail icon</title><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"/></svg></a>
  <a href="https://twitter.com/breckyunits"><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><title>Twitter icon</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg></a>
  <a href="https://github.com/breck7/breckyunits.com"><svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub icon</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a>
</div>
</body>
