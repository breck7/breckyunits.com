figure {
  margin: 0;
  padding: 0;
}
.dropcap:first-letter {
  font-size: 3rem;
  line-height: .9em;
  margin-right: .125rem;
  display: block;
  float: left;
}
.dinkus {
  text-align: center;
  padding: 1rem;
}
.dinkus span {
  vertical-align: sub;
}
details {
  margin-top: 10px;
}
summary {
  font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";
  cursor: pointer;
}
.scrollCaptionedFigure {
  display: block;
  break-inside: avoid;
  text-align: center;
}
.scrollCaptionedFigure img {
  max-width: 100%;
  height: auto;
  margin-top: .1875rem;
}
.scrollCaptionedFigure figcaption {
  font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";
  font-size: .8rem;
}
.scrollCaptionedFigure figcaption .scrollParagraph {
  margin-top: 0;
}
.scrollCodeBlock {
  overflow: auto;
  font-size: .8rem;
  hyphens: none;
  white-space: pre;
  break-inside: avoid;
  display: block;
  margin: .5rem 0;
  padding: .5rem;
  border-radius: 0;
  position: relative;
}
.scrollCodeBlock:hover .scrollCopyButton {
  opacity: .5;
}
.scrollCodeBlock:hover .scrollCopyButton:hover {
  opacity: .8;
}
.scrollCodeBlock:hover .scrollCopyButton:active {
  opacity: 1;
}
.scrollCopyButton {
  position: absolute;
  top: .125rem;
  right: .125rem;
  font-size: .875rem;
  cursor: pointer;
  opacity: 0;
}
.scrollCopyButton::after {
  content: "[ ]";
}
.scrollCopiedButton::after {
  content: "[âœ“]";
}
html,body,div,span,p,ol,ul,li,table,figure {
  margin: 0;
  padding: 0;
  border: 0;
  vertical-align: baseline;
  border-spacing: 0;
}
ol,ul {
  padding-left: 1rem;
}
li {
  margin-top: .4rem;
  line-height: 1.4;
}
a {
  text-decoration-color: transparent;
}
a:hover {
  text-decoration-color: initial;
}
sup,sub {
  vertical-align: baseline;
  position: relative;
  top: -.375rem;
}
sub {
  top: .375rem;
}
html {
  padding: .25rem;
  background-color: rgb(244,244,244);
  font-family: Exchange,Georgia,serif;
  color: #000;
  font-size: var(--base-font-size, 16px);
  hyphens: auto;
}
p {
  margin-top: .4rem;
  line-height: 1.4rem;
}
.scrollQuote {
  break-inside: avoid;
  display: block;
  margin: .5rem 0;
  padding: .5rem;
  background: rgba(204,204,204,.5);
  white-space: pre-line;
  border-left: .5rem solid rgba(204,204,204,.8);
}
code {
  font-size: .9rem;
  background-color: rgba(204,204,204,.5);
  padding: .125rem .25rem;
  border-radius: .25rem;
}
.scrollParagraph {
  text-align: justify;
}
.scrollColumns {
  column-count: auto;
  column-fill: balance;
  column-width: 35ch;
  column-gap: 1.5rem;
  padding-left: 1.25rem;
  padding-right: 1.25rem;
  margin: auto;
}
.scrollSnippetContainer {
  padding: 1ch 0;
  break-inside: avoid;
  text-align: justify;
}
h1,h2,h3,h4 {
  margin: .625rem 0;
}
h1 {
  font-size: 1.25rem;
}
h2 {
  font-size: 1.125rem;
}
h3,h4 {
  font-size: 1rem;
}
h1.scrollTitle {
  text-align: center;
  margin: auto;
  margin-bottom: .15625rem;
  margin-top: 0;
  font-size: 1.75rem;
  max-width: calc(100vw - 2 * (1.5625rem + 1.875rem));
}
h1.scrollTitle a {
  color: #000;
}
.scrollDateline {
  font-style: italic;
  line-height: 1.4rem;
  font-size: .75rem;
}
.scrollSection {
  break-inside: avoid;
}
.scrollSection h1,.scrollSection h2,.scrollSection h3,.scrollSection h4 {
  text-align: center;
}
h4.scrollQuestion {
  text-align: left;
  margin: 1.4rem 0 0 0;
}
.scrollSection:first-child h1,.scrollSection:first-child h2,.scrollSection:first-child h3,.scrollSection:first-child h4 {
  margin-top: 0;
}
.scrollSection:first-child h4.scrollQuestion {
  margin-top: 0;
}
.scrollNoteLink {
  opacity: .4;
  text-decoration: none;
}
.scrollNoteLink:hover {
  opacity: 1;
}
.scrollFootNoteUsageLink {
  opacity: .7;
  text-decoration: none;
}
.scrollFootNoteUsageLink:hover {
  opacity: 1;
}
.scrollHoverNote {
  text-decoration: underline dashed 1px rgba(0,0,0,.1);
  cursor: default;
}
.scrollCodeBlock {
  border-left: .5rem solid rgba(204,204,204,.8);
}
.scrollTable {
  table-layout: fixed;
  font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";
  margin: .5rem 0;
  overflow: hidden;
  font-size: .8rem;
  width: 100%;
  hyphens: none;
  border: 1px solid rgba(224,224,224,.8);
}
.scrollTable td,.scrollTable th {
  padding: .1875rem;
  overflow: hidden;
  white-space: nowrap;
}
.scrollTable td:hover {
  text-overflow: unset;
  overflow: unset;
  white-space: unset;
}
.scrollTable th {
  text-transform: capitalize;
}
.scrollTable th {
  border-bottom: 2px solid rgba(0,0,0,.6);
  text-align: left;
}
.scrollTable tr:nth-child(even) {
  background: rgba(224,224,224,.6);
}
.scrollByLine {
  font-size: .875rem;
  font-style: italic;
  margin: .25rem 0;
  text-align: center;
}
.scrollViewSource {
  text-align: center;
  font-family: Verdana;
  font-weight: 100;
}
.scrollViewSource a {
  color: rgba(204,204,204,.5);
}
.scrollViewSource a:hover {
  color: #333;
}
.scrollContinueReadingLink {
  display: block;
  text-align: center;
}
.scrollDashboard {
  width: 100%;
  font-size: 1.875rem;
  text-align: center;
  font-weight: bold;
  break-inside: avoid;
  margin-top: .5rem;
  margin-bottom: .5rem;
}
.scrollDashboard td {
  width: 33.3%;
  border: 1px solid #e8e8e8;
}
.scrollDashboard span {
  font-size: 1.25rem;
  display: block;
}
.scrollChat span {
  font-family: Verdana;
  margin-top: .3125rem;
  padding: .3125rem 1.25rem;
  border-radius: .9375rem;
  display: inline-block;
}
.scrollChatLeft span {
  background: rgba(204,204,204, .5);
}
.scrollChatRight span {
  color: white;
  background: rgb(0,132,255);
}
.scrollYouTubeHolder {
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 56.25%;
}
.scrollYouTubeEmbed {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

Naming Things
=============

October 20, 2012

I love to name things.

I spend a lot of time naming ideas in my work. At work I write my code using a program called TextMate. TextMate is a great little program with a pleasant purple theme. I spend a lot of time using TextMate. For the past year I've been using TextMate to write a program that now consists of a few hundred files. There are thousands of words in this program. There are hundreds of objects and concepts and functions that each have a name. The names are super simple like "Pen" for an object that draws on the screen, and "delete" for a method that deletes something. Some of the things in our program are more important than others and those really important ones I've renamed dozens of times searching for the right fit.

There's a feature in TextMate that lets me find and replace a word across all 400+ files in the project. If I am unhappy with my word choice for a variable or concept, I'll think about it for weeks if not months. I'll use Thesaurus.com, I'll read about similar concepts, I'll run a subconscious search for the simplest, best word. When I find it, I'll hit Command+Shift+F in TextMate and excitedly and carefully execute a find and replace across the whole project. Those are some of my favorite programming days--when I find a better name for an important part of the program.

Naming a thing is like creating life from inorganic material in a lab. You observe some pattern, combine a bunch of letters to form a name, and then see what happens. Sometimes your name doesn't fit and sits lifeless. But sometimes the name is just right. You use it in conversation or in code and people instantly get it. It catches on. It leaves the lab. Your name takes a life of its own and spreads.

Words are very contagious. The better the word, the more contagious it can be. Like viruses, small differences in the quality of a word can have exponential differences on it's spread.  So I like to spend time searching for the right words.

Great names are short. Short names are less effort to communicate. The quality of a name drops exponentially with each syllable you add. Coke is better than Coca-Cola. Human is better than homo sapiens.

Great names are visual. A good test of whether a name is accurate is whether you can draw a picture of the name that makes sense. Net is better than cyberspace. If you drew a picture of the physical components of the Internet, it would look a lot like a fishing net. Net is a great name.

Great names are used for great ideas. You should match the quality of a name to the quality of the idea compared to the other ideas in the space. This is particularly applicable in the digital world. If you are working on an important idea that will be used by a lot of people in a broad area, use a short, high quality name. If you are working on a smaller idea in that same area, don't hog a better name than your idea deserves. Linux is filled with great programs with bad names and bad programs with great names. I've been very happy so far with my experience with NPM, where it seems programmers who are using the best names are making their programs live up to them.

I think the exercise of naming things can be very helpful in improving things. Designing things from first principles is a proven way to arrive at novel, sometimes better ideas. Attempting to rename something is a great way to rethink the thing from the ground up.

For example, lately I've been trying to come up with a way to explain the fundamentals of computing. A strategy I recently employed was to change the names we use for the 2 boolean states from True and False to Absent or Present. It seems like it gets closer to the truth of how computers work. I mean, it doesn't make sense to ask a bit whether it is True or False. The only question an electronic bit can answer is whether a charge is present or absent. When we compare variable A to variable B, the CPU sets a flag in the comparison bit and we are really asking that bit whether a charge is present.

What I like about the idea of using the names Present and Absent is that it makes the fundamentals of computing align with the fundamentals of the world. The most fundamental questions in the world about being--of existence. Do we exist? Why do we exist? Will we exist tomorrow? Likewise, the most fundamental questions in computing is not whether or not there are ones and zeroes, it's whether or not a charge exists. Does a charge exist? Why does that charge exist? Will that charge exist in the next iteration? Computing is not about manipulating ones and zeroes. It's about using the concept of being, of existence, to solve problems. Computing is about using the concept of the presence or absence of charge to do many wonderful things.

****
